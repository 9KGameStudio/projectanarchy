/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 2.0.3
 * 
 * This file is not intended to be easily readable and contains a number of 
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG 
 * interface file instead. 
 * ----------------------------------------------------------------------------- */

#include <Vision/Runtime/EnginePlugins/VisionEnginePlugin/VisionEnginePluginPCH.h>
#include <Vision/Runtime/EnginePlugins/VisionEnginePlugin/Scripting/VScriptIncludes.hpp>
#include <Vision/Runtime/Base/System/Memory/VMemDbg.hpp>
#include <Vision/Runtime/EnginePlugins/VisionEnginePlugin/Scripting/Lua/VisionLuaModule_wrapper.hpp>

#include <Vision/Runtime/Base/System/DisableStaticAnalysis.hpp>

#ifndef _VISION_DOC

#if defined (__SNC__)
#pragma diag_push
#pragma diag_suppress=112
#pragma diag_push
#pragma diag_suppress=178
#pragma diag_push
#pragma diag_suppress=1111
#endif

#if defined(__ghs__)
#pragma ghs nowarning 1795
#pragma ghs nowarning 111
#pragma ghs nowarning 177
#endif

#define SWIGLUA


#ifdef __cplusplus
/* SwigValueWrapper is described in swig.swg */
template<typename T> class SwigValueWrapper {
  struct SwigMovePointer {
    T *ptr;
    SwigMovePointer(T *p) : ptr(p) { }
    ~SwigMovePointer() { delete ptr; }
    SwigMovePointer& operator=(SwigMovePointer& rhs) { T* oldptr = ptr; ptr = 0; delete oldptr; ptr = rhs.ptr; rhs.ptr = 0; return *this; }
  } pointer;
  SwigValueWrapper& operator=(const SwigValueWrapper<T>& rhs);
  SwigValueWrapper(const SwigValueWrapper<T>& rhs);
public:
  SwigValueWrapper() : pointer(0) { }
  SwigValueWrapper& operator=(const T& t) { SwigMovePointer tmp(new T(t)); pointer = tmp; return *this; }
  operator T&() const { return *pointer.ptr; }
  T *operator&() { return pointer.ptr; }
};

template <typename T> T SwigValueInit() {
  return T();
}
#endif

/* -----------------------------------------------------------------------------
 *  This section contains generic SWIG labels for method/variable
 *  declarations/attributes, and other compiler dependent labels.
 * ----------------------------------------------------------------------------- */

/* template workaround for compilers that cannot correctly implement the C++ standard */
#ifndef SWIGTEMPLATEDISAMBIGUATOR
# if defined(__SUNPRO_CC) && (__SUNPRO_CC <= 0x560)
#  define SWIGTEMPLATEDISAMBIGUATOR template
# elif defined(__HP_aCC)
/* Needed even with `aCC -AA' when `aCC -V' reports HP ANSI C++ B3910B A.03.55 */
/* If we find a maximum version that requires this, the test would be __HP_aCC <= 35500 for A.03.55 */
#  define SWIGTEMPLATEDISAMBIGUATOR template
# else
#  define SWIGTEMPLATEDISAMBIGUATOR
# endif
#endif

/* inline attribute */
#ifndef SWIGINLINE
# if defined(__cplusplus) || (defined(__GNUC__) && !defined(__STRICT_ANSI__))
#   define SWIGINLINE inline
# else
#   define SWIGINLINE
# endif
#endif

/* attribute recognised by some compilers to avoid 'unused' warnings */
#ifndef SWIGUNUSED
# if defined(__GNUC__)
#   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
#     define SWIGUNUSED __attribute__ ((__unused__)) 
#   else
#     define SWIGUNUSED
#   endif
# elif defined(__ICC)
#   define SWIGUNUSED __attribute__ ((__unused__)) 
# else
#   define SWIGUNUSED 
# endif
#endif

#ifndef SWIG_MSC_UNSUPPRESS_4505
# if defined(_MSC_VER)
#   pragma warning(disable : 4505) /* unreferenced local function has been removed */
# endif 
#endif

#ifndef SWIGUNUSEDPARM
# ifdef __cplusplus
#   define SWIGUNUSEDPARM(p)
# else
#   define SWIGUNUSEDPARM(p) p SWIGUNUSED 
# endif
#endif

/* internal SWIG method */
#ifndef SWIGINTERN
# define SWIGINTERN static SWIGUNUSED
#endif

/* internal inline SWIG method */
#ifndef SWIGINTERNINLINE
# define SWIGINTERNINLINE SWIGINTERN SWIGINLINE
#endif

/* exporting methods */
#if (__GNUC__ >= 4) || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)
#  ifndef GCC_HASCLASSVISIBILITY
#    define GCC_HASCLASSVISIBILITY
#  endif
#endif

#ifndef SWIGEXPORT
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   if defined(STATIC_LINKED)
#     define SWIGEXPORT
#   else
#     define SWIGEXPORT __declspec(dllexport)
#   endif
# else
#   if defined(__GNUC__) && defined(GCC_HASCLASSVISIBILITY)
#     define SWIGEXPORT __attribute__ ((visibility("default")))
#   else
#     define SWIGEXPORT
#   endif
# endif
#endif

/* calling conventions for Windows */
#ifndef SWIGSTDCALL
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   define SWIGSTDCALL __stdcall
# else
#   define SWIGSTDCALL
# endif 
#endif

/* Deal with Microsoft's attempt at deprecating C standard runtime functions */
#if !defined(SWIG_NO_CRT_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_CRT_SECURE_NO_DEPRECATE)
# define _CRT_SECURE_NO_DEPRECATE
#endif

/* Deal with Microsoft's attempt at deprecating methods in the standard C++ library */
#if !defined(SWIG_NO_SCL_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_SCL_SECURE_NO_DEPRECATE)
# define _SCL_SECURE_NO_DEPRECATE
#endif


/* -----------------------------------------------------------------------------
 * swigrun.swg
 *
 * This file contains generic C API SWIG runtime support for pointer
 * type checking.
 * ----------------------------------------------------------------------------- */

/* This should only be incremented when either the layout of swig_type_info changes,
   or for whatever reason, the runtime changes incompatibly */
#define SWIG_RUNTIME_VERSION "4"

/* define SWIG_TYPE_TABLE_NAME as "SWIG_TYPE_TABLE" */
#ifdef SWIG_TYPE_TABLE
# define SWIG_QUOTE_STRING(x) #x
# define SWIG_EXPAND_AND_QUOTE_STRING(x) SWIG_QUOTE_STRING(x)
# define SWIG_TYPE_TABLE_NAME SWIG_EXPAND_AND_QUOTE_STRING(SWIG_TYPE_TABLE)
#else
# define SWIG_TYPE_TABLE_NAME
#endif

/*
  You can use the SWIGRUNTIME and SWIGRUNTIMEINLINE macros for
  creating a static or dynamic library from the SWIG runtime code.
  In 99.9% of the cases, SWIG just needs to declare them as 'static'.
  
  But only do this if strictly necessary, ie, if you have problems
  with your compiler or suchlike.
*/

#ifndef SWIGRUNTIME
# define SWIGRUNTIME SWIGINTERN
#endif

#ifndef SWIGRUNTIMEINLINE
# define SWIGRUNTIMEINLINE SWIGRUNTIME SWIGINLINE
#endif

/*  Generic buffer size */
#ifndef SWIG_BUFFER_SIZE
# define SWIG_BUFFER_SIZE 1024
#endif

/* Flags for pointer conversions */
#define SWIG_POINTER_DISOWN        0x1
#define SWIG_CAST_NEW_MEMORY       0x2

/* Flags for new pointer objects */
#define SWIG_POINTER_OWN           0x1


/* 
   Flags/methods for returning states.
   
   The SWIG conversion methods, as ConvertPtr, return an integer 
   that tells if the conversion was successful or not. And if not,
   an error code can be returned (see swigerrors.swg for the codes).
   
   Use the following macros/flags to set or process the returning
   states.
   
   In old versions of SWIG, code such as the following was usually written:

     if (SWIG_ConvertPtr(obj,vptr,ty.flags) != -1) {
       // success code
     } else {
       //fail code
     }

   Now you can be more explicit:

    int res = SWIG_ConvertPtr(obj,vptr,ty.flags);
    if (SWIG_IsOK(res)) {
      // success code
    } else {
      // fail code
    }

   which is the same really, but now you can also do

    Type *ptr;
    int res = SWIG_ConvertPtr(obj,(void **)(&ptr),ty.flags);
    if (SWIG_IsOK(res)) {
      // success code
      if (SWIG_IsNewObj(res) {
        ...
	delete *ptr;
      } else {
        ...
      }
    } else {
      // fail code
    }
    
   I.e., now SWIG_ConvertPtr can return new objects and you can
   identify the case and take care of the deallocation. Of course that
   also requires SWIG_ConvertPtr to return new result values, such as

      int SWIG_ConvertPtr(obj, ptr,...) {         
        if (<obj is ok>) {			       
          if (<need new object>) {		       
            *ptr = <ptr to new allocated object>; 
            return SWIG_NEWOBJ;		       
          } else {				       
            *ptr = <ptr to old object>;	       
            return SWIG_OLDOBJ;		       
          } 				       
        } else {				       
          return SWIG_BADOBJ;		       
        }					       
      }

   Of course, returning the plain '0(success)/-1(fail)' still works, but you can be
   more explicit by returning SWIG_BADOBJ, SWIG_ERROR or any of the
   SWIG errors code.

   Finally, if the SWIG_CASTRANK_MODE is enabled, the result code
   allows to return the 'cast rank', for example, if you have this

       int food(double)
       int fooi(int);

   and you call
 
      food(1)   // cast rank '1'  (1 -> 1.0)
      fooi(1)   // cast rank '0'

   just use the SWIG_AddCast()/SWIG_CheckState()
*/

#define SWIG_OK                    (0) 
#define SWIG_ERROR                 (-1)
#define SWIG_IsOK(r)               (r >= 0)
#define SWIG_ArgError(r)           ((r != SWIG_ERROR) ? r : SWIG_TypeError)  

/* The CastRankLimit says how many bits are used for the cast rank */
#define SWIG_CASTRANKLIMIT         (1 << 8)
/* The NewMask denotes the object was created (using new/malloc) */
#define SWIG_NEWOBJMASK            (SWIG_CASTRANKLIMIT  << 1)
/* The TmpMask is for in/out typemaps that use temporal objects */
#define SWIG_TMPOBJMASK            (SWIG_NEWOBJMASK << 1)
/* Simple returning values */
#define SWIG_BADOBJ                (SWIG_ERROR)
#define SWIG_OLDOBJ                (SWIG_OK)
#define SWIG_NEWOBJ                (SWIG_OK | SWIG_NEWOBJMASK)
#define SWIG_TMPOBJ                (SWIG_OK | SWIG_TMPOBJMASK)
/* Check, add and del mask methods */
#define SWIG_AddNewMask(r)         (SWIG_IsOK(r) ? (r | SWIG_NEWOBJMASK) : r)
#define SWIG_DelNewMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_NEWOBJMASK) : r)
#define SWIG_IsNewObj(r)           (SWIG_IsOK(r) && (r & SWIG_NEWOBJMASK))
#define SWIG_AddTmpMask(r)         (SWIG_IsOK(r) ? (r | SWIG_TMPOBJMASK) : r)
#define SWIG_DelTmpMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_TMPOBJMASK) : r)
#define SWIG_IsTmpObj(r)           (SWIG_IsOK(r) && (r & SWIG_TMPOBJMASK))

/* Cast-Rank Mode */
#if defined(SWIG_CASTRANK_MODE)
#  ifndef SWIG_TypeRank
#    define SWIG_TypeRank             unsigned long
#  endif
#  ifndef SWIG_MAXCASTRANK            /* Default cast allowed */
#    define SWIG_MAXCASTRANK          (2)
#  endif
#  define SWIG_CASTRANKMASK          ((SWIG_CASTRANKLIMIT) -1)
#  define SWIG_CastRank(r)           (r & SWIG_CASTRANKMASK)
SWIGINTERNINLINE int SWIG_AddCast(int r) { 
  return SWIG_IsOK(r) ? ((SWIG_CastRank(r) < SWIG_MAXCASTRANK) ? (r + 1) : SWIG_ERROR) : r;
}
SWIGINTERNINLINE int SWIG_CheckState(int r) { 
  return SWIG_IsOK(r) ? SWIG_CastRank(r) + 1 : 0; 
}
#else /* no cast-rank mode */
#  define SWIG_AddCast
#  define SWIG_CheckState(r) (SWIG_IsOK(r) ? 1 : 0)
#endif


#include <string.h>

#ifdef __cplusplus
extern "C" {
#endif


/* 
  Compare two type names skipping the space characters, therefore
  "char*" == "char *" and "Class<int>" == "Class<int >", etc.

  Return 0 when the two name types are equivalent, as in
  strncmp, but skipping ' '.
*/
SWIGRUNTIME int
SWIG_TypeNameComp(const char *f1, const char *l1,
		  const char *f2, const char *l2) {
  for (;(f1 != l1) && (f2 != l2); ++f1, ++f2) {
    while ((*f1 == ' ') && (f1 != l1)) ++f1;
    while ((*f2 == ' ') && (f2 != l2)) ++f2;
    if (*f1 != *f2) return (*f1 > *f2) ? 1 : -1;
  }
  return (int)((l1 - f1) - (l2 - f2));
}

/*
  Check type equivalence in a name list like <name1>|<name2>|...
  Return 0 if not equal, 1 if equal
*/
SWIGRUNTIME int
SWIG_TypeEquiv(const char *nb, const char *tb) {
  int equiv = 0;
  const char* te = tb + strlen(tb);
  const char* ne = nb;
  while (!equiv && *ne) {
    for (nb = ne; *ne; ++ne) {
      if (*ne == '|') break;
    }
    equiv = (SWIG_TypeNameComp(nb, ne, tb, te) == 0) ? 1 : 0;
    if (*ne) ++ne;
  }
  return equiv;
}

/*
  Check type equivalence in a name list like <name1>|<name2>|...
  Return 0 if equal, -1 if nb < tb, 1 if nb > tb
*/
SWIGRUNTIME int
SWIG_TypeCompare(const char *nb, const char *tb) {
  int equiv = 0;
  const char* te = tb + strlen(tb);
  const char* ne = nb;
  while (!equiv && *ne) {
    for (nb = ne; *ne; ++ne) {
      if (*ne == '|') break;
    }
    equiv = (SWIG_TypeNameComp(nb, ne, tb, te) == 0) ? 1 : 0;
    if (*ne) ++ne;
  }
  return equiv;
}


/*
  Check the typename
*/
SWIGRUNTIME swig_cast_info *
SWIG_TypeCheck(const char *c, swig_type_info *ty) {
  if (ty) {
    swig_cast_info *iter = ty->cast;
    while (iter) {
      if (strcmp(iter->type->name, c) == 0) {
        if (iter == ty->cast)
          return iter;
        /* Move iter to the top of the linked list */
        iter->prev->next = iter->next;
        if (iter->next)
          iter->next->prev = iter->prev;
        iter->next = ty->cast;
        iter->prev = 0;
        if (ty->cast) ty->cast->prev = iter;
        ty->cast = iter;
        return iter;
      }
      iter = iter->next;
    }
  }
  return 0;
}

/* 
  Identical to SWIG_TypeCheck, except strcmp is replaced with a pointer comparison
*/
SWIGRUNTIME swig_cast_info *
SWIG_TypeCheckStruct(swig_type_info *from, swig_type_info *ty) {
  if (ty) {
    swig_cast_info *iter = ty->cast;
    while (iter) {
      if (iter->type == from) {
        if (iter == ty->cast)
          return iter;
        /* Move iter to the top of the linked list */
        iter->prev->next = iter->next;
        if (iter->next)
          iter->next->prev = iter->prev;
        iter->next = ty->cast;
        iter->prev = 0;
        if (ty->cast) ty->cast->prev = iter;
        ty->cast = iter;
        return iter;
      }
      iter = iter->next;
    }
  }
  return 0;
}

/*
  Cast a pointer up an inheritance hierarchy
*/
SWIGRUNTIMEINLINE void *
SWIG_TypeCast(swig_cast_info *ty, void *ptr, int *newmemory) {
  return ((!ty) || (!ty->converter)) ? ptr : (*ty->converter)(ptr, newmemory);
}

/* 
   Dynamic pointer casting. Down an inheritance hierarchy
*/
SWIGRUNTIME swig_type_info *
SWIG_TypeDynamicCast(swig_type_info *ty, void **ptr) {
  swig_type_info *lastty = ty;
  if (!ty || !ty->dcast) return ty;
  while (ty && (ty->dcast)) {
    ty = (*ty->dcast)(ptr);
    if (ty) lastty = ty;
  }
  return lastty;
}

/*
  Return the name associated with this type
*/
SWIGRUNTIMEINLINE const char *
SWIG_TypeName(const swig_type_info *ty) {
  return ty->name;
}

/*
  Return the pretty name associated with this type,
  that is an unmangled type name in a form presentable to the user.
*/
SWIGRUNTIME const char *
SWIG_TypePrettyName(const swig_type_info *type) {
  /* The "str" field contains the equivalent pretty names of the
     type, separated by vertical-bar characters.  We choose
     to print the last name, as it is often (?) the most
     specific. */
  if (!type) return NULL;
  if (type->str != NULL) {
    const char *last_name = type->str;
    const char *s;
    for (s = type->str; *s; s++)
      if (*s == '|') last_name = s+1;
    return last_name;
  }
  else
    return type->name;
}

/* 
   Set the clientdata field for a type
*/
SWIGRUNTIME void
SWIG_TypeClientData(swig_type_info *ti, void *clientdata) {
  swig_cast_info *cast = ti->cast;
  /* if (ti->clientdata == clientdata) return; */
  ti->clientdata = clientdata;
  
  while (cast) {
    if (!cast->converter) {
      swig_type_info *tc = cast->type;
      if (!tc->clientdata) {
	SWIG_TypeClientData(tc, clientdata);
      }
    }    
    cast = cast->next;
  }
}
SWIGRUNTIME void
SWIG_TypeNewClientData(swig_type_info *ti, void *clientdata) {
  SWIG_TypeClientData(ti, clientdata);
  ti->owndata = 1;
}
  
/*
  Search for a swig_type_info structure only by mangled name
  Search is a O(log #types)
  
  We start searching at module start, and finish searching when start == end.  
  Note: if start == end at the beginning of the function, we go all the way around
  the circular list.
*/
SWIGRUNTIME swig_type_info *
SWIG_MangledTypeQueryModule(swig_module_info *start, 
                            swig_module_info *end, 
		            const char *name) {
  swig_module_info *iter = start;
  do {
    if (iter->size) {
      register size_t l = 0;
      register size_t r = iter->size - 1;
      do {
	/* since l+r >= 0, we can (>> 1) instead (/ 2) */
	register size_t i = (l + r) >> 1; 
	const char *iname = iter->types[i]->name;
	if (iname) {
	  register int compare = strcmp(name, iname);
	  if (compare == 0) {	    
	    return iter->types[i];
	  } else if (compare < 0) {
	    if (i) {
	      r = i - 1;
	    } else {
	      break;
	    }
	  } else if (compare > 0) {
	    l = i + 1;
	  }
	} else {
	  break; /* should never happen */
	}
      } while (l <= r);
    }
    iter = iter->next;
  } while (iter != end);
  return 0;
}

/*
  Search for a swig_type_info structure for either a mangled name or a human readable name.
  It first searches the mangled names of the types, which is a O(log #types)
  If a type is not found it then searches the human readable names, which is O(#types).
  
  We start searching at module start, and finish searching when start == end.  
  Note: if start == end at the beginning of the function, we go all the way around
  the circular list.
*/
SWIGRUNTIME swig_type_info *
SWIG_TypeQueryModule(swig_module_info *start, 
                     swig_module_info *end, 
		     const char *name) {
  /* STEP 1: Search the name field using binary search */
  swig_type_info *ret = SWIG_MangledTypeQueryModule(start, end, name);
  if (ret) {
    return ret;
  } else {
    /* STEP 2: If the type hasn't been found, do a complete search
       of the str field (the human readable name) */
    swig_module_info *iter = start;
    do {
      register size_t i = 0;
      for (; i < iter->size; ++i) {
	if (iter->types[i]->str && (SWIG_TypeEquiv(iter->types[i]->str, name)))
	  return iter->types[i];
      }
      iter = iter->next;
    } while (iter != end);
  }
  
  /* neither found a match */
  return 0;
}

/* 
   Pack binary data into a string
*/
SWIGRUNTIME char *
SWIG_PackData(char *c, void *ptr, size_t sz) {
  static const char hex[17] = "0123456789abcdef";
  register const unsigned char *u = (unsigned char *) ptr;
  register const unsigned char *eu =  u + sz;
  for (; u != eu; ++u) {
    register unsigned char uu = *u;
    *(c++) = hex[(uu & 0xf0) >> 4];
    *(c++) = hex[uu & 0xf];
  }
  return c;
}

/* 
   Unpack binary data from a string
*/
SWIGRUNTIME const char *
SWIG_UnpackData(const char *c, void *ptr, size_t sz) {
  register unsigned char *u = (unsigned char *) ptr;
  register const unsigned char *eu = u + sz;
  for (; u != eu; ++u) {
    register char d = *(c++);
    register unsigned char uu;
    if ((d >= '0') && (d <= '9'))
      uu = ((d - '0') << 4);
    else if ((d >= 'a') && (d <= 'f'))
      uu = ((d - ('a'-10)) << 4);
    else 
      return (char *) 0;
    d = *(c++);
    if ((d >= '0') && (d <= '9'))
      uu |= (d - '0');
    else if ((d >= 'a') && (d <= 'f'))
      uu |= (d - ('a'-10));
    else 
      return (char *) 0;
    *u = uu;
  }
  return c;
}

/* 
   Pack 'void *' into a string buffer.
*/
SWIGRUNTIME char *
SWIG_PackVoidPtr(char *buff, void *ptr, const char *name, size_t bsz) {
  char *r = buff;
  if ((2*sizeof(void *) + 2) > bsz) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r,&ptr,sizeof(void *));
  if (strlen(name) + 1 > (bsz - (r - buff))) return 0;
  strcpy(r,name);
  return buff;
}

SWIGRUNTIME const char *
SWIG_UnpackVoidPtr(const char *c, void **ptr, const char *name) {
  if (*c != '_') {
    if (strcmp(c,"NULL") == 0) {
      *ptr = (void *) 0;
      return name;
    } else {
      return 0;
    }
  }
  return SWIG_UnpackData(++c,ptr,sizeof(void *));
}

SWIGRUNTIME char *
SWIG_PackDataName(char *buff, void *ptr, size_t sz, const char *name, size_t bsz) {
  char *r = buff;
  size_t lname = (name ? strlen(name) : 0);
  if ((2*sz + 2 + lname) > bsz) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r,ptr,sz);
  if (lname) {
    strncpy(r,name,lname+1);
  } else {
    *r = 0;
  }
  return buff;
}

SWIGRUNTIME const char *
SWIG_UnpackDataName(const char *c, void *ptr, size_t sz, const char *name) {
  if (*c != '_') {
    if (strcmp(c,"NULL") == 0) {
      memset(ptr,0,sz);
      return name;
    } else {
      return 0;
    }
  }
  return SWIG_UnpackData(++c,ptr,sz);
}

#ifdef __cplusplus
}
#endif

/* -----------------------------------------------------------------------------
 * luarun.swg
 *
 * This file contains the runtime support for Lua modules
 * and includes code for managing global variables and pointer
 * type checking.
 * ----------------------------------------------------------------------------- */

#ifdef __cplusplus
extern "C" {
#endif

/* Common SWIG API */
#define SWIG_NewPointerObj(L, ptr, type, owner)       SWIG_Lua_NewPointerObj(L, (void *)ptr, type, owner)
#define SWIG_ConvertPtr(L,idx, ptr, type, flags)    SWIG_Lua_ConvertPtr(L,idx,ptr,type,flags)
#define SWIG_MustGetPtr(L,idx, type,flags, argnum,fnname)  SWIG_Lua_MustGetPtr(L,idx, type,flags, argnum,fnname)
/* for C++ member pointers, ie, member methods */
#define SWIG_ConvertMember(L, idx, ptr, sz, ty)       SWIG_Lua_ConvertPacked(L, idx, ptr, sz, ty)
#define SWIG_NewMemberObj(L, ptr, sz, type)      SWIG_Lua_NewPackedObj(L, ptr, sz, type)

/* Runtime API */
#define SWIG_GetModule(clientdata) SWIG_Lua_GetModule((lua_State*)(clientdata))
#define SWIG_SetModule(clientdata, pointer) SWIG_Lua_SetModule((lua_State*) (clientdata), pointer)
#define SWIG_MODULE_CLIENTDATA_TYPE lua_State*

/* Contract support */
#define SWIG_contract_assert(expr, msg)  \
  if (!(expr)) { lua_pushstring(L, (char *) msg); goto fail; } else

/* helper #defines */
#define SWIG_fail {goto fail;}
#define SWIG_fail_arg(func_name,argnum,type) \
  {lua_pushfstring(L,"Error in %s (arg %d), expected '%s' got '%s'",\
  func_name,argnum,type,SWIG_Lua_typename(L,argnum));\
  goto fail;}
#define SWIG_fail_ptr(func_name,argnum,type) \
  SWIG_fail_arg(func_name,argnum,(type && type->str)?type->str:"void*")
#define SWIG_check_num_args(func_name,a,b) \
  if (lua_gettop(L)<a || lua_gettop(L)>b) \
  {lua_pushfstring(L,"Error in %s expected %d..%d args, got %d",func_name,a,b,lua_gettop(L));\
  goto fail;}


#define SWIG_Lua_get_table(L,n) \
  (lua_pushstring(L, n), lua_rawget(L,-2))

#define SWIG_Lua_add_function(L,n,f) \
  (lua_pushstring(L, n), \
      lua_pushcfunction(L, f), \
      lua_rawset(L,-3))

/* special helper for allowing 'nil' for usertypes */
#define SWIG_isptrtype(L,I) (lua_isuserdata(L,I) || lua_isnil(L,I))

#ifdef __cplusplus
/* Special helper for member function pointers 
it gets the address, casts it, then dereferences it */
//#define SWIG_mem_fn_as_voidptr(a)  (*((char**)&(a)))
#endif

/* storing/access of swig_module_info */
SWIGRUNTIME swig_module_info *
SWIG_Lua_GetModule(lua_State* L) {
  swig_module_info *ret = 0;
  lua_pushstring(L,"swig_runtime_data_type_pointer" SWIG_RUNTIME_VERSION SWIG_TYPE_TABLE_NAME);
  lua_rawget(L,LUA_REGISTRYINDEX);
  if (lua_islightuserdata(L,-1))
    ret=(swig_module_info*)lua_touserdata(L,-1);
  lua_pop(L,1);  /* tidy */
  return ret;
}

SWIGRUNTIME void
SWIG_Lua_SetModule(lua_State* L, swig_module_info *module) {
  /* add this all into the Lua registry: */
  lua_pushstring(L,"swig_runtime_data_type_pointer" SWIG_RUNTIME_VERSION SWIG_TYPE_TABLE_NAME);
  lua_pushlightuserdata(L,(void*)module);
  lua_rawset(L,LUA_REGISTRYINDEX);
}

/* -----------------------------------------------------------------------------
 * global variable support code: modules
 * ----------------------------------------------------------------------------- */

/* this function is called when trying to set an immutable.
default value is to print an error.
This can removed with a compile flag SWIGLUA_IGNORE_SET_IMMUTABLE */
SWIGINTERN int SWIG_Lua_set_immutable(lua_State* L)
{
/*  there should be 1 param passed in: the new value */
#ifndef SWIGLUA_IGNORE_SET_IMMUTABLE
  lua_pop(L,1);  /* remove it */
  lua_pushstring(L,"This variable is immutable");
  lua_error(L);
#endif
    return 0;   /* should not return anything */
}

/* the module.get method used for getting linked data */
SWIGINTERN int SWIG_Lua_module_get(lua_State* L)
{
/*  there should be 2 params passed in
  (1) table (not the meta table)
  (2) string name of the attribute
  printf("SWIG_Lua_module_get %p(%s) '%s'\n",
   lua_topointer(L,1),lua_typename(L,lua_type(L,1)),
   lua_tostring(L,2));
*/
  /* get the metatable */
  assert(lua_istable(L,1));  /* just in case */
  lua_getmetatable(L,1);  /* get the metatable */
  assert(lua_istable(L,-1));  /* just in case */
  SWIG_Lua_get_table(L,".get");  /* get the .get table */
  lua_remove(L,3);  /* remove metatable */
  if (lua_istable(L,-1))
  {
    /* look for the key in the .get table */
    lua_pushvalue(L,2);  /* key */
    lua_rawget(L,-2);
    lua_remove(L,3);  /* remove .get */
    if (lua_iscfunction(L,-1))
    {  /* found it so call the fn & return its value */
      lua_call(L,0,1);
      return 1;
    }
    lua_pop(L,1);  /* remove the top */
  }
  lua_pop(L,1);  /* remove the .get */
  lua_pushnil(L);  /* return a nil */
    return 1;
}

/* the module.set method used for setting linked data */
SWIGINTERN int SWIG_Lua_module_set(lua_State* L)
{
/*  there should be 3 params passed in
  (1) table (not the meta table)
  (2) string name of the attribute
  (3) any for the new value
*/
  /* get the metatable */
  assert(lua_istable(L,1));  /* just in case */
  lua_getmetatable(L,1);  /* get the metatable */
  assert(lua_istable(L,-1));  /* just in case */
  SWIG_Lua_get_table(L,".set");  /* get the .set table */
  lua_remove(L,4);  /* remove metatable */
  if (lua_istable(L,-1))
  {
    /* look for the key in the .set table */
    lua_pushvalue(L,2);  /* key */
    lua_rawget(L,-2);
    lua_remove(L,4);  /* remove .set */
    if (lua_iscfunction(L,-1))
    {  /* found it so call the fn & return its value */
      lua_pushvalue(L,3);  /* value */
      lua_call(L,1,0);
      return 0;
    }
  }
  lua_settop(L,3);  /* reset back to start */
  /* we now have the table, key & new value, so just set directly */
  lua_rawset(L,1);  /* add direct */
  return 0;
}

/* registering a module in lua */
SWIGINTERN void  SWIG_Lua_module_begin(lua_State* L,const char* name)
{
  assert(lua_istable(L,-1));  /* just in case */
  lua_pushstring(L,name);
  lua_newtable(L);   /* the table */
  /* add meta table */
  lua_newtable(L);    /* the meta table */
  SWIG_Lua_add_function(L,"__index",SWIG_Lua_module_get);
  SWIG_Lua_add_function(L,"__newindex",SWIG_Lua_module_set);
  lua_pushstring(L,".get");
  lua_newtable(L);    /* the .get table */
  lua_rawset(L,-3);  /* add .get into metatable */
  lua_pushstring(L,".set");
  lua_newtable(L);    /* the .set table */
  lua_rawset(L,-3);  /* add .set into metatable */
  lua_setmetatable(L,-2);  /* sets meta table in module */
  lua_rawset(L,-3);        /* add module into parent */
  SWIG_Lua_get_table(L,name);   /* get the table back out */
}

/* ending the register */
SWIGINTERN void  SWIG_Lua_module_end(lua_State* L)
{
  lua_pop(L,1);       /* tidy stack (remove module) */
}

/* adding a linked variable to the module */
SWIGINTERN void SWIG_Lua_module_add_variable(lua_State* L,const char* name,lua_CFunction getFn,lua_CFunction setFn)
{
  assert(lua_istable(L,-1));  /* just in case */
  lua_getmetatable(L,-1);  /* get the metatable */
  assert(lua_istable(L,-1));  /* just in case */
  SWIG_Lua_get_table(L,".get"); /* find the .get table */
  assert(lua_istable(L,-1));  /* should be a table: */
  SWIG_Lua_add_function(L,name,getFn);
  lua_pop(L,1);       /* tidy stack (remove table) */
  if (setFn)  /* if there is a set fn */
  {
    SWIG_Lua_get_table(L,".set"); /* find the .set table */
    assert(lua_istable(L,-1));  /* should be a table: */
    SWIG_Lua_add_function(L,name,setFn);
    lua_pop(L,1);       /* tidy stack (remove table) */
  }
  lua_pop(L,1);       /* tidy stack (remove meta) */
}

/* adding a function module */
SWIGINTERN void  SWIG_Lua_module_add_function(lua_State* L,const char* name,lua_CFunction fn)
{
  SWIG_Lua_add_function(L,name,fn);
}

/* -----------------------------------------------------------------------------
 * global variable support code: classes
 * ----------------------------------------------------------------------------- */

//Expecting the same stack format as SWIG:
//stack: userdata, key, ..., TOP
//afterwards: userdata, key, ..., value, TOP
SWIGINTERN void VisionLuaClassGet(lua_State *L)
{
  //solution 1: retrieve element when accessing an user data object from a global $node-POINTER_ADR-NAME_OF_ELEM$
  //(+): fast and allows user to associate elemets with an instance of an user data object
  //(-): elements are not stored in a table, so you cannot iterate over all elements of an instance
  
  const char * pKey = lua_tostring(L, 2);
  const void * pPtr = lua_topointer(L, 1);

  lua_pushfstring(L, "$node-%p-%s$", pPtr, pKey);  //stack: userdata, key, ..., new key, TOP
  lua_gettable(L, LUA_GLOBALSINDEX); 		      //stack: userdata, key, ..., requested val, TOP
  
/*
  //solution 2: get element from a global table $node-POINTER_ADR$
  //(+): user data object instance behaves like a table (you can iterate on this table)
  //(-): slower than solution 1
  
  int iPtr = (int) lua_topointer(L, 1);
  lua_pushfstring(L, "$node-%p$", iPtr);          //stack: userdata, key, ..., instance string, TOP
  lua_gettable(L, LUA_GLOBALSINDEX); 		      //stack: userdata, key, ..., table of instance or nil, TOP
  
  if(!lua_isnil(L, -1))
  {
    lua_pushvalue(L, 2);		  				  //stack: userdata, key, ..., table of instance, dup key, TOP
    lua_gettable(L, -2); 	     				  //stack: userdata, key, ..., table of instance, requested val, TOP
    lua_replace(L, -2);		  					  //stack: userdata, key, ..., requested val or nil, TOP
  }
  
*/
}

/* the class.get method, performs the lookup of class attributes */
SWIGINTERN int  SWIG_Lua_class_get(lua_State* L)
{
/*  there should be 2 params passed in
  (1) userdata (not the meta table)
  (2) string name of the attribute
*/
  assert(lua_isuserdata(L,-2));  /* just in case */
  lua_getmetatable(L,-2);    /* get the meta table */
  assert(lua_istable(L,-1));  /* just in case */
  SWIG_Lua_get_table(L,".get"); /* find the .get table */
  assert(lua_istable(L,-1));  /* just in case */
  /* look for the key in the .get table */
  lua_pushvalue(L,2);  /* key */
  lua_rawget(L,-2);
  lua_remove(L,-2); /* stack tidy, remove .get table */
  if (lua_iscfunction(L,-1))
  {  /* found it so call the fn & return its value */
    lua_pushvalue(L,1);  /* the userdata */
    lua_call(L,1,1);  /* 1 value in (userdata),1 out (result) */
    lua_remove(L,-2); /* stack tidy, remove metatable */
    return 1;
  }
  lua_pop(L,1);  /* remove whatever was there */
  /* ok, so try the .fn table */
  SWIG_Lua_get_table(L,".fn"); /* find the .get table */
  assert(lua_istable(L,-1));  /* just in case */
  lua_pushvalue(L,2);  /* key */
  lua_rawget(L,-2);  /* look for the fn */
  lua_remove(L,-2); /* stack tidy, remove .fn table */
  if (lua_isfunction(L,-1)) /* note: if its a C function or lua function */
  {  /* found it so return the fn & let lua call it */
    lua_remove(L,-2); /* stack tidy, remove metatable */
    return 1;
  }
  lua_pop(L,1);  /* remove whatever was there */
  /* NEW: looks for the __getitem() fn
  this is a user provided get fn */
  SWIG_Lua_get_table(L,"__getitem"); /* find the __getitem fn */
  if (lua_iscfunction(L,-1))  /* if its there */
  {  /* found it so call the fn & return its value */
    lua_pushvalue(L,1);  /* the userdata */
    lua_pushvalue(L,2);  /* the parameter */
    lua_call(L,2,1);  /* 2 value in (userdata),1 out (result) */
    lua_remove(L,-2); /* stack tidy, remove metatable */
    return 1;
  }
  
  //////////////////////
  // Vision Extension //
  
  VisionLuaClassGet(L);
  if (!lua_isnil(L, -1))
    return 1;

  // End of Extension //
  //////////////////////

  return 0;  /* sorry not known */
}

//Expecting the same stack format as SWIG:
//stack: userdata, key, value, ..., TOP
SWIGINTERN void VisionLuaClassSet(lua_State *L)
{
  //solution 1: store all elements when accessing an user data objects as a global $node-POINTER_ADR-NAME_OF_ELEM$
  //(+): fast and allows user to associate elemets with an instance of an user data object
  //(-): elements are not stored in a table, so you cannot iterate over all elements of an instance
  
  const char * pKey = lua_tostring(L, 2);
  const void * pPtr = lua_topointer(L, 1);
  
  lua_pushfstring(L, "$node-%p-%s$", pPtr, pKey);   //stack: userdata, key, value, ..., new key, TOP
  
  lua_pushvalue(L, 3);                              //stack: userdata, key, value, ..., new key, value, TOP
  lua_settable(L, LUA_GLOBALSINDEX);                //stack: userdata, key, value, ..., TOP

/*  
  //solution 2: create a table $node-POINTER_ADR$ and save the element as element of this table
  //(+): user data object instance behaves like a table (you can iterate on this table)
  //(-): much slower than solution 1
  
  int iPtr = (int) lua_topointer(L, 1);
  lua_pushfstring(L, "$node-%p$", iPtr);      //stack: userdata, key, value, ..., instance string, TOP
  lua_gettable(L, LUA_GLOBALSINDEX); 		      //stack: userdata, key, value, ..., table of instance (maybe nil), TOP
  
  if(lua_isnil(L, -1))
  {
    //create a new empty table
    lua_pop(L, 1);                            //stack: userdata, key, value, ..., TOP
	  lua_pushfstring(L, "$node-%p$", iPtr);    //stack: userdata, key, value, ..., instance string, TOP
  	lua_newtable(L);						              //stack: userdata, key, value, ..., instance string, new table, TOP
	  lua_settable(L, LUA_GLOBALSINDEX);        //stack: userdata, key, value, ..., TOP
	
	  //query empty table
	  lua_pushfstring(L, "$node-%p$", iPtr);    //stack: userdata, key, value, ..., instance string, TOP
	  lua_gettable(L, LUA_GLOBALSINDEX); 		    //stack: userdata, key, value, ..., table of instance, TOP
	
	  //ensure that this time the table is present
	  assert(!lua_isnil(L, -1));
  }
  
  lua_pushvalue(L, 2);		  				          //stack: userdata, key, value, ..., table of instance, dup key, TOP
  lua_pushvalue(L, 3);		  				          //stack: userdata, key, value, ..., table of instance, dup key, dup value, TOP
  lua_settable(L, -3); 	     				          //stack: userdata, key, value, ..., table of instance, TOP
  lua_pop(L, 1);                                    //stack: userdata, key, value, ..., TOP
*/
}

/* the class.set method, performs the lookup of class attributes */
SWIGINTERN int  SWIG_Lua_class_set(lua_State* L)
{
/*  there should be 3 params passed in
  (1) table (not the meta table)
  (2) string name of the attribute
  (3) any for the new value
printf("SWIG_Lua_class_set %p(%s) '%s' %p(%s)\n",
      lua_topointer(L,1),lua_typename(L,lua_type(L,1)),
      lua_tostring(L,2),
      lua_topointer(L,3),lua_typename(L,lua_type(L,3)));*/

  assert(lua_isuserdata(L,1));  /* just in case */
  lua_getmetatable(L,1);    /* get the meta table */
  assert(lua_istable(L,-1));  /* just in case */

  SWIG_Lua_get_table(L,".set"); /* find the .set table */
  if (lua_istable(L,-1))
  {
    /* look for the key in the .set table */
    lua_pushvalue(L,2);  /* key */
    lua_rawget(L,-2);
    if (lua_iscfunction(L,-1))
    {  /* found it so call the fn & return its value */
      lua_pushvalue(L,1);  /* userdata */
      lua_pushvalue(L,3);  /* value */
      lua_call(L,2,0);
      return 0;
    }
    lua_pop(L,1);  /* remove the value */
  }
  lua_pop(L,1);  /* remove the value .set table */
  /* NEW: looks for the __setitem() fn
  this is a user provided set fn */
  SWIG_Lua_get_table(L,"__setitem"); /* find the fn */
  if (lua_iscfunction(L,-1))  /* if its there */
  {  /* found it so call the fn & return its value */
    lua_pushvalue(L,1);  /* the userdata */
    lua_pushvalue(L,2);  /* the parameter */
    lua_pushvalue(L,3);  /* the value */
    lua_call(L,3,0);  /* 3 values in ,0 out */
    lua_remove(L,-2); /* stack tidy, remove metatable */
    return 1;
  }
  
  //////////////////////
  // Vision Extension //

  VisionLuaClassSet(L); 

  // End of Extension //
  //////////////////////

  return 0;
}

/* the class.destruct method called by the interpreter */
SWIGINTERN int  SWIG_Lua_class_destruct(lua_State* L)
{
/*  there should be 1 params passed in
  (1) userdata (not the meta table) */
  swig_lua_userdata* usr;
  swig_lua_class* clss;
  assert(lua_isuserdata(L,-1));  /* just in case */
  usr=(swig_lua_userdata*)lua_touserdata(L,-1);  /* get it */
  /* if must be destroyed & has a destructor */
  if (usr->own) /* if must be destroyed */
  {
    clss=(swig_lua_class*)usr->type->clientdata;  /* get the class */
    if (clss && clss->destructor)  /* there is a destroy fn */
    {
      clss->destructor(usr->ptr);  /* bye bye */
    }
  }
  return 0;
}

/* gets the swig class registry (or creates it) */
SWIGINTERN void  SWIG_Lua_get_class_registry(lua_State* L)
{
  /* add this all into the swig registry: */
  lua_pushstring(L,"SWIG");
  lua_rawget(L,LUA_REGISTRYINDEX);  /* get the registry */
  if (!lua_istable(L,-1))  /* not there */
  {  /* must be first time, so add it */
    lua_pop(L,1);  /* remove the result */
    lua_pushstring(L,"SWIG");
    lua_newtable(L);
    lua_rawset(L,LUA_REGISTRYINDEX);
    /* then get it */
    lua_pushstring(L,"SWIG");
    lua_rawget(L,LUA_REGISTRYINDEX);
  }
}

/* helper fn to get the classes metatable from the register */
SWIGINTERN void  SWIG_Lua_get_class_metatable(lua_State* L,const char* cname)
{
  SWIG_Lua_get_class_registry(L);  /* get the registry */
  lua_pushstring(L,cname);  /* get the name */
  lua_rawget(L,-2);    /* get it */
  lua_remove(L,-2);    /* tidy up (remove registry) */
}

/* helper add a variable to a registered class */
SWIGINTERN void  SWIG_Lua_add_class_variable(lua_State* L,const char* name,lua_CFunction getFn,lua_CFunction setFn)
{
  assert(lua_istable(L,-1));  /* just in case */
  SWIG_Lua_get_table(L,".get"); /* find the .get table */
  assert(lua_istable(L,-1));  /* just in case */
  SWIG_Lua_add_function(L,name,getFn);
  lua_pop(L,1);       /* tidy stack (remove table) */
  if (setFn)
  {
    SWIG_Lua_get_table(L,".set"); /* find the .set table */
    assert(lua_istable(L,-1));  /* just in case */
    SWIG_Lua_add_function(L,name,setFn);
    lua_pop(L,1);       /* tidy stack (remove table) */
  }
}

/* helper to recursively add class details (attributes & operations) */
SWIGINTERN void  SWIG_Lua_add_class_details(lua_State* L,swig_lua_class* clss)
{
  int i;
  /* call all the base classes first: we can then override these later: */
  for(i=0;clss->bases[i];i++)
  {
    SWIG_Lua_add_class_details(L,clss->bases[i]);
  }
  /* add fns */
  for(i=0;clss->attributes[i].name;i++){
    SWIG_Lua_add_class_variable(L,clss->attributes[i].name,clss->attributes[i].getmethod,clss->attributes[i].setmethod);
  }
  /* add methods to the metatable */
  SWIG_Lua_get_table(L,".fn"); /* find the .fn table */
  assert(lua_istable(L,-1));  /* just in case */
  for(i=0;clss->methods[i].name;i++){
    SWIG_Lua_add_function(L,clss->methods[i].name,clss->methods[i].method);
  }
  lua_pop(L,1);       /* tidy stack (remove table) */
  /*   add operator overloads
    these look ANY method which start with "__" and assume they
    are operator overloads & add them to the metatable
    (this might mess up is someone defines a method __gc (the destructor)*/
  for(i=0;clss->methods[i].name;i++){
    if (clss->methods[i].name[0]=='_' && clss->methods[i].name[1]=='_'){
      SWIG_Lua_add_function(L,clss->methods[i].name,clss->methods[i].method);
    }
  }
}

/* set up the base classes pointers.
Each class structure has a list of pointers to the base class structures.
This function fills them.
It cannot be done at compile time, as this will not work with hireachies
spread over more than one swig file. 
Therefore it must be done at runtime, querying the SWIG type system.
*/
SWIGINTERN void SWIG_Lua_init_base_class(lua_State* L,swig_lua_class* clss)
{
  int i=0;
  swig_module_info* module=SWIG_GetModule(L);
  for(i=0;clss->base_names[i];i++)
  {
    if (clss->bases[i]==0) /* not found yet */
    {
      /* lookup and cache the base class */
      swig_type_info *info = SWIG_TypeQueryModule(module,module,clss->base_names[i]);
      if (info) clss->bases[i] = (swig_lua_class *) info->clientdata;
    }
  }	
}

/* performs the entire class registration process */
SWIGINTERN void  SWIG_Lua_class_register(lua_State* L,swig_lua_class* clss)
{
  /*  add its constructor to module with the name of the class
  so you can do MyClass(...) as well as new_MyClass(...)
  BUT only if a constructor is defined
  (this overcomes the problem of pure virtual classes without constructors)*/
  if (clss->constructor)
    SWIG_Lua_add_function(L,clss->name,clss->constructor);

  SWIG_Lua_get_class_registry(L);  /* get the registry */
  lua_pushstring(L,clss->name);  /* get the name */
  lua_newtable(L);    /* create the metatable */
  /* add string of class name called ".type" */
  lua_pushstring(L,".type");
  lua_pushstring(L,clss->name);
  lua_rawset(L,-3);
  /* add a table called ".get" */
  lua_pushstring(L,".get");
  lua_newtable(L);
  lua_rawset(L,-3);
  /* add a table called ".set" */
  lua_pushstring(L,".set");
  lua_newtable(L);
  lua_rawset(L,-3);
  /* add a table called ".fn" */
  lua_pushstring(L,".fn");
  lua_newtable(L);
  lua_rawset(L,-3);
  /* add accessor fns for using the .get,.set&.fn */
  SWIG_Lua_add_function(L,"__index",SWIG_Lua_class_get);
  SWIG_Lua_add_function(L,"__newindex",SWIG_Lua_class_set);
  SWIG_Lua_add_function(L,"__gc",SWIG_Lua_class_destruct);
  /* add it */
  lua_rawset(L,-3);  /* metatable into registry */
  lua_pop(L,1);      /* tidy stack (remove registry) */

  SWIG_Lua_get_class_metatable(L,clss->name);
  SWIG_Lua_add_class_details(L,clss);  /* recursive adding of details (atts & ops) */
  lua_pop(L,1);      /* tidy stack (remove class metatable) */
}

/* -----------------------------------------------------------------------------
 * Class/structure conversion fns
 * ----------------------------------------------------------------------------- */

/* helper to add metatable to new lua object */
SWIGINTERN void _SWIG_Lua_AddMetatable(lua_State* L,swig_type_info *type)
{
  if (type->clientdata)  /* there is clientdata: so add the metatable */
  {
    SWIG_Lua_get_class_metatable(L,((swig_lua_class*)(type->clientdata))->name);
    if (lua_istable(L,-1))
    {
      lua_setmetatable(L,-2);
    }
    else
    {
      lua_pop(L,1);
    }
  }
}

/* pushes a new object into the lua stack */
SWIGRUNTIME void SWIG_Lua_NewPointerObj(lua_State* L,void* ptr,swig_type_info *type, int own)
{
  swig_lua_userdata* usr;
  if (!ptr){
    lua_pushnil(L);
    return;
  }
  usr=(swig_lua_userdata*)lua_newuserdata(L,sizeof(swig_lua_userdata));  /* get data */
  usr->ptr=ptr;  /* set the ptr */
  usr->type=type;
  usr->own=own;
  _SWIG_Lua_AddMetatable(L,type); /* add metatable */
}

/* takes a object from the lua stack & converts it into an object of the correct type
 (if possible) */
SWIGRUNTIME int  SWIG_Lua_ConvertPtr(lua_State* L,int index,void** ptr,swig_type_info *type,int flags)
{
  swig_lua_userdata* usr;
  swig_cast_info *cast;
  if (lua_isnil(L,index)){*ptr=0; return SWIG_OK;}    /* special case: lua nil => NULL pointer */
  usr=(swig_lua_userdata*)lua_touserdata(L,index);  /* get data */
  if (usr)
  {
    if (flags & SWIG_POINTER_DISOWN) /* must disown the object */
    {
        usr->own=0;
    }
    if (!type)            /* special cast void*, no casting fn */
    {
      *ptr=usr->ptr;
      return SWIG_OK; /* ok */
    }
    cast=SWIG_TypeCheckStruct(usr->type,type); /* performs normal type checking */
    if (cast)
    {
      int newmemory = 0;
      *ptr=SWIG_TypeCast(cast,usr->ptr,&newmemory);
      assert(!newmemory); /* newmemory handling not yet implemented */
      return SWIG_OK;  /* ok */
    }
  }
  return SWIG_ERROR;  /* error */
}

SWIGRUNTIME void* SWIG_Lua_MustGetPtr(lua_State* L,int index,swig_type_info *type,int flags,
       int argnum,const char* func_name){
  void* result;
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,index,&result,type,flags))){
    lua_pushfstring(L,"Error in %s, expected a %s at argument number %d\n",
      func_name,(type && type->str)?type->str:"void*",argnum);
    lua_error(L);
  }
  return result;
}

/* pushes a packed userdata. user for member fn pointers only */
SWIGRUNTIME void SWIG_Lua_NewPackedObj(lua_State* L,void* ptr,size_t size,swig_type_info *type)
{
  swig_lua_rawdata* raw;
  assert(ptr); /* not acceptable to pass in a NULL value */
  raw=(swig_lua_rawdata*)lua_newuserdata(L,sizeof(swig_lua_rawdata)-1+size);  /* alloc data */
  raw->type=type;
  raw->own=0;
  memcpy(raw->data,ptr,size); /* copy the data */
  _SWIG_Lua_AddMetatable(L,type); /* add metatable */
}
    
/* converts a packed userdata. user for member fn pointers only */
SWIGRUNTIME int  SWIG_Lua_ConvertPacked(lua_State* L,int index,void* ptr,size_t size,swig_type_info *type)
{
  swig_lua_rawdata* raw;
  raw=(swig_lua_rawdata*)lua_touserdata(L,index);  /* get data */
  if (!raw) return SWIG_ERROR;  /* error */
  if (type==0 || type==raw->type) /* void* or identical type */
  {
    memcpy(ptr,raw->data,size); /* copy it */
    return SWIG_OK; /* ok */
  }
  return SWIG_ERROR;  /* error */
}

/* a function to get the typestring of a piece of data */
SWIGRUNTIME const char *SWIG_Lua_typename(lua_State *L, int tp)
{
  swig_lua_userdata* usr;
  if (lua_isuserdata(L,tp))
  {
    usr=(swig_lua_userdata*)lua_touserdata(L,tp);  /* get data */
    if (usr && usr->type && usr->type->str)
      return usr->type->str;
    return "userdata (unknown type)";
  }
  return lua_typename(L,lua_type(L,tp));
}

/* lua callable function to get the userdata's type */
SWIGRUNTIME int SWIG_Lua_type(lua_State* L)
{
  lua_pushstring(L,SWIG_Lua_typename(L,1));
  return 1;
}

/* lua callable function to compare userdata's value
the issue is that two userdata may point to the same thing
but to lua, they are different objects */
SWIGRUNTIME int SWIG_Lua_equal(lua_State* L)
{
  int result;
  swig_lua_userdata *usr1,*usr2;
  if (!lua_isuserdata(L,1) || !lua_isuserdata(L,2))  /* just in case */
    return 0;  /* nil reply */
  usr1=(swig_lua_userdata*)lua_touserdata(L,1);  /* get data */
  usr2=(swig_lua_userdata*)lua_touserdata(L,2);  /* get data */
  /*result=(usr1->ptr==usr2->ptr && usr1->type==usr2->type); only works if type is the same*/
  result=(usr1->ptr==usr2->ptr);
   lua_pushboolean(L,result);
  return 1;
}

/* -----------------------------------------------------------------------------
 * global variable support code: class/struct typemap functions
 * ----------------------------------------------------------------------------- */

/* Install Constants */
SWIGINTERN void
SWIG_Lua_InstallConstants(lua_State* L, swig_lua_const_info constants[]) {
  int i;
  for (i = 0; constants[i].type; i++) {
    switch(constants[i].type) {
    case SWIG_LUA_INT:
      lua_pushstring(L,constants[i].name);
      lua_pushnumber(L,(lua_Number)constants[i].lvalue);
      lua_rawset(L,-3);
      break;
    case SWIG_LUA_FLOAT:
      lua_pushstring(L,constants[i].name);
      lua_pushnumber(L,(lua_Number)constants[i].dvalue);
      lua_rawset(L,-3);
      break;
    case SWIG_LUA_CHAR:
      lua_pushstring(L,constants[i].name);
      lua_pushfstring(L,"%c",(char)constants[i].lvalue);
      lua_rawset(L,-3);
      break;
    case SWIG_LUA_STRING:
      lua_pushstring(L,constants[i].name);
      lua_pushstring(L,(char *) constants[i].pvalue);
      lua_rawset(L,-3);
      break;
    case SWIG_LUA_POINTER:
      lua_pushstring(L,constants[i].name);
      SWIG_NewPointerObj(L,constants[i].pvalue, *(constants[i]).ptype,0);
      lua_rawset(L,-3);
      break;
    case SWIG_LUA_BINARY:
      lua_pushstring(L,constants[i].name);
      SWIG_NewMemberObj(L,constants[i].pvalue,constants[i].lvalue,*(constants[i]).ptype);
      lua_rawset(L,-3);
      break;
    default:
      break;
    }
  }
}

/* -----------------------------------------------------------------------------
 * executing lua code from within the wrapper
 * ----------------------------------------------------------------------------- */

#ifndef SWIG_DOSTRING_FAIL /* Allows redefining of error function */
#define SWIG_DOSTRING_FAIL(S) fprintf(stderr,"%s\n",S)
#endif
/* Executes a C string in Lua a really simple way of calling lua from C
Unfortunately lua keeps changing its API's, so we need a conditional compile
In lua 5.0.X its lua_dostring()
In lua 5.1.X its luaL_dostring()
*/
SWIGINTERN int 
SWIG_Lua_dostring(lua_State *L, const char* str) {
  int ok,top;
  if (str==0 || str[0]==0) return 0; /* nothing to do */
  top=lua_gettop(L); /* save stack */
#if (defined(LUA_VERSION_NUM) && (LUA_VERSION_NUM>=501))
  ok=luaL_dostring(L,str);	/* looks like this is lua 5.1.X or later, good */
#else
  ok=lua_dostring(L,str);	/* might be lua 5.0.x, using lua_dostring */
#endif
  if (ok!=0) {
    SWIG_DOSTRING_FAIL(lua_tostring(L,-1));
  }
  lua_settop(L,top); /* restore the stack */
  return ok;
}    

#ifdef __cplusplus
}
#endif

/* ------------------------------ end luarun.swg  ------------------------------ */


swig_type_info *swig_types[65];
swig_module_info swig_module = {swig_types, 64, 0, 0, 0, 0};

#define SWIG_name      "Vision"
#define SWIG_init      luaopen_Vision
#define SWIG_init_user luaopen_Vision_user

#define SWIG_LUACODE   luaopen_Vision_luacode


namespace swig {
typedef struct{} LANGUAGE_OBJ;
}


#ifdef __cplusplus	/* generic alloc/dealloc fns*/
#define SWIG_ALLOC_ARRAY(TYPE,LEN) 	new TYPE[LEN]
#define SWIG_FREE_ARRAY(PTR)		delete[] PTR
#else
#define SWIG_ALLOC_ARRAY(TYPE,LEN) 	(TYPE *)malloc(LEN*sizeof(TYPE))
#define SWIG_FREE_ARRAY(PTR)		free(PTR)
#endif
/* counting the size of arrays:*/
SWIGINTERN int SWIG_itable_size(lua_State* L, int index)
{
	int n=0;
	while(1){
		lua_rawgeti(L,index,n+1);
		if (lua_isnil(L,-1))break;
		++n;
		lua_pop(L,1);
	}
	lua_pop(L,1);
	return n;
}

SWIGINTERN int SWIG_table_size(lua_State* L, int index)
{
	int n=0;
	lua_pushnil(L);  /* first key*/
	while (lua_next(L, index) != 0) {
		++n;
		lua_pop(L, 1);  /* removes `value'; keeps `key' for next iteration*/
	}
	return n;
}

/* super macro to declare array typemap helper fns */
#define SWIG_DECLARE_TYPEMAP_ARR_FN(NAME,TYPE)\
	SWIGINTERN int SWIG_read_##NAME##_num_array(lua_State* L,int index,TYPE *array,int size){\
		int i;\
		for (i = 0; i < size; i++) {\
			lua_rawgeti(L,index,i+1);\
			if (lua_isnumber(L,-1)){\
				array[i] = (TYPE)lua_tonumber(L,-1);\
			} else {\
				lua_pop(L,1);\
				return 0;\
			}\
			lua_pop(L,1);\
		}\
		return 1;\
	}\
	SWIGINTERN TYPE* SWIG_get_##NAME##_num_array_fixed(lua_State* L, int index, int size){\
		TYPE *array;\
		if (!lua_istable(L,index) || SWIG_itable_size(L,index) != size) {\
			lua_pushfstring(L,"expected a table of size %d",size);\
			return 0;\
		}\
		array=SWIG_ALLOC_ARRAY(TYPE,size);\
		if (!SWIG_read_##NAME##_num_array(L,index,array,size)){\
			lua_pushstring(L,"table must contain numbers");\
			SWIG_FREE_ARRAY(array);\
			return 0;\
		}\
		return array;\
	}\
	SWIGINTERN TYPE* SWIG_get_##NAME##_num_array_var(lua_State* L, int index, int* size)\
	{\
		TYPE *array;\
		if (!lua_istable(L,index)) {\
			lua_pushstring(L,"expected a table");\
			return 0;\
		}\
		*size=SWIG_itable_size(L,index);\
		if (*size<1){\
			lua_pushstring(L,"table appears to be empty");\
			return 0;\
		}\
		array=SWIG_ALLOC_ARRAY(TYPE,*size);\
		if (!SWIG_read_##NAME##_num_array(L,index,array,*size)){\
			lua_pushstring(L,"table must contain numbers");\
			SWIG_FREE_ARRAY(array);\
			return 0;\
		}\
		return array;\
	}\
	SWIGINTERN void SWIG_write_##NAME##_num_array(lua_State* L,TYPE *array,int size){\
		int i;\
		lua_newtable(L);\
		for (i = 0; i < size; i++){\
			lua_pushnumber(L,(lua_Number)array[i]);\
			lua_rawseti(L,-2,i+1);/* -1 is the number, -2 is the table*/ \
		}\
	}

SWIG_DECLARE_TYPEMAP_ARR_FN(schar,signed char);
SWIG_DECLARE_TYPEMAP_ARR_FN(uchar,unsigned char);
SWIG_DECLARE_TYPEMAP_ARR_FN(int,int);
SWIG_DECLARE_TYPEMAP_ARR_FN(uint,unsigned int);
SWIG_DECLARE_TYPEMAP_ARR_FN(short,short);
SWIG_DECLARE_TYPEMAP_ARR_FN(ushort,unsigned short);
SWIG_DECLARE_TYPEMAP_ARR_FN(long,long);
SWIG_DECLARE_TYPEMAP_ARR_FN(ulong,unsigned long);
SWIG_DECLARE_TYPEMAP_ARR_FN(float,float);
SWIG_DECLARE_TYPEMAP_ARR_FN(double,double);

SWIGINTERN int SWIG_read_ptr_array(lua_State* L,int index,void **array,int size,swig_type_info *type){
	int i;
	for (i = 0; i < size; i++) {
		lua_rawgeti(L,index,i+1);
		if (!lua_isuserdata(L,-1) || SWIG_ConvertPtr(L,-1,&array[i],type,0)==-1){
			lua_pop(L,1);
			return 0;
		}
		lua_pop(L,1);
	}
	return 1;
}
SWIGINTERN void** SWIG_get_ptr_array_fixed(lua_State* L, int index, int size,swig_type_info *type){
	void **array;
	if (!lua_istable(L,index) || SWIG_itable_size(L,index) != size) {
		lua_pushfstring(L,"expected a table of size %d",size);
		return 0;
	}
	array=SWIG_ALLOC_ARRAY(void*,size);
	if (!SWIG_read_ptr_array(L,index,array,size,type)){
		lua_pushfstring(L,"table must contain pointers of type %s",type->name);
		SWIG_FREE_ARRAY(array);
		return 0;
	}
	return array;
}
SWIGINTERN void** SWIG_get_ptr_array_var(lua_State* L, int index, int* size,swig_type_info *type){
	void **array;
	if (!lua_istable(L,index)) {
		lua_pushstring(L,"expected a table");
		return 0;
	}
	*size=SWIG_itable_size(L,index);
	if (*size<1){
		lua_pushstring(L,"table appears to be empty");
		return 0;
	}
	array=SWIG_ALLOC_ARRAY(void*,*size);
	if (!SWIG_read_ptr_array(L,index,array,*size,type)){
		lua_pushfstring(L,"table must contain pointers of type %s",type->name);
		SWIG_FREE_ARRAY(array);
		return 0;
	}
	return array;
}
SWIGINTERN void SWIG_write_ptr_array(lua_State* L,void **array,int size,swig_type_info *type,int own){
	int i;
	lua_newtable(L);
	for (i = 0; i < size; i++){
		SWIG_NewPointerObj(L,array[i],type,own);
		lua_rawseti(L,-2,i+1);/* -1 is the number, -2 is the table*/
	}
}


  #include <Vision/Runtime/Base/VGL/VGL.hpp>
  #include <Vision/Runtime/Engine/SceneElements/VisApiPathNode.hpp>
  #include <Vision/Runtime/EnginePlugins/VisionEnginePlugin/GUI/VMenuIncludes.hpp>
  #include <Vision/Runtime/EnginePlugins/VisionEnginePlugin/Scene/VPrefab.hpp>
  #include <Vision/Runtime/EnginePlugins/VisionEnginePlugin/Entities/TriggerBoxEntity.hpp>
  #include <Vision/Runtime/EnginePlugins/VisionEnginePlugin/Particles/ParticleGroupBase.hpp>
  #include <Vision/Runtime/EnginePlugins/VisionEnginePlugin/Particles/ParticleGroupManager.hpp>
  #include <Vision/Runtime/EnginePlugins/VisionEnginePlugin/Animation/Transition/VTransitionStateMachine.hpp>
  #include <Vision/Runtime/EnginePlugins/VisionEnginePlugin/Animation/Transition/VTransitionManager.hpp>
  #include <Vision/Runtime/EnginePlugins/VisionEnginePlugin/Scripting/Components/VAnimationComponent.hpp>
  #include <Vision/Runtime/EnginePlugins/VisionEnginePlugin/Scripting/Components/VTimedValueComponent.hpp>
  #include <Vision/Runtime/EnginePlugins/VisionEnginePlugin/Scripting/Lua/VScriptConstants.hpp>
  #include <Vision/Runtime/EnginePlugins/VisionEnginePlugin/Scripting/Lua/VScriptDraw_wrapper.hpp>
  #include <Vision/Runtime/EnginePlugins/VisionEnginePlugin/Scripting/Lua/VScriptInput_wrapper.hpp>
  #include <Vision/Runtime/EnginePlugins/VisionEnginePlugin/Scripting/Lua/VScriptDebug_wrapper.hpp>
  #include <Vision/Runtime/EnginePlugins/VisionEnginePlugin/Scripting/Lua/VScriptScreen_wrapper.hpp>
  #include <Vision/Runtime/EnginePlugins/VisionEnginePlugin/Scripting/Lua/VScriptRenderer_wrapper.hpp>
  #include <Vision/Runtime/EnginePlugins/VisionEnginePlugin/Scripting/Lua/VScriptUtil_wrapper.hpp>
  #include <Vision/Runtime/EnginePlugins/VisionEnginePlugin/Scripting/Lua/VScriptApp_wrapper.hpp>
  #include <Vision/Runtime/EnginePlugins/VisionEnginePlugin/Scripting/Lua/VBitmask.hpp>
  #include <Vision/Runtime/EnginePlugins/VisionEnginePlugin/Components/VEnginePluginElementManager.hpp>
  #include <Vision/Runtime/EnginePlugins/VisionEnginePlugin/Rendering/RendererNode/VRendererNodeCommon.hpp>
  #include <Vision/Runtime/EnginePlugins/VisionEnginePlugin/Rendering/Postprocessing/PostProcessBase.hpp>  
  #include <Vision/Runtime/EnginePlugins/VisionEnginePlugin/Rendering/Effects/CubeMapHandle.hpp>
  #include <Vision/Runtime/EnginePlugins/VisionEnginePlugin/Entities/PathCameraEntity.hpp>
  #include <Vision/Runtime/EnginePlugins/VisionEnginePlugin/Entities/VCustomVolumeManager.hpp>
  #include <Vision/Runtime/EnginePlugins/VisionEnginePlugin/Entities/VCustomVolumeObject.hpp>

SWIGINTERN bool hkvVec3_normalizeIfNotZero(hkvVec3 *self){
      return self->normalizeIfNotZero()==HKV_SUCCESS;
    }
SWIGINTERN bool hkvVec3_setLength(hkvVec3 *self,float f){
      return self->setLength(f)==HKV_SUCCESS;
    }
SWIGINTERN hkvVec3 *new_hkvVec3__SWIG_3(bool bInitialize=true){
      if(bInitialize) return new hkvVec3(0.0f);
      return new hkvVec3(hkvNoInitialization);
    }
SWIGINTERN void hkvVec3_makeOrthogonalTo(hkvVec3 *self,hkvVec3 const &vNormal){
      self->makeOrthogonalTo(vNormal.getNormalized());
    }
SWIGINTERN hkvVec3 hkvVec3_clone(hkvVec3 const *self){
      return *self; //will call the copy constructor
    }
SWIGINTERN hkvVec3 const hkvVec3_compMul__SWIG_1(hkvVec3 *self,float x,float y,float z){
      return self->compMul(hkvVec3(x,y,z));
    }
SWIGINTERN hkvVec3 const hkvVec3_compDiv__SWIG_1(hkvVec3 *self,float x,float y,float z){
      return self->compDiv(hkvVec3(x,y,z));
    }
SWIGINTERN float hkvVec3___len(hkvVec3 const *self,hkvVec3 const *vec){
      //the query looks odd ,but in some cases this can happen in Lua with SWIG
      return self==NULL ? 0 : self->getLength();
    }
SWIGINTERN bool hkvVec3___eq(hkvVec3 const *self,hkvVec3 const *pRhs){
      if(pRhs==NULL) return false;
      return pRhs->isEqual(*self, HKVMATH_DEFAULT_EPSILON);
    }
SWIGINTERN hkvVec3 hkvVec3___add(hkvVec3 *self,hkvVec3 const *pRhs){
     if(pRhs==NULL) return *self;
      return (*self + *pRhs);
    }
SWIGINTERN hkvVec3 hkvVec3___sub(hkvVec3 *self,hkvVec3 const *pRhs){
      if(pRhs==NULL) return *self;
      return (*self - *pRhs);
    }
SWIGINTERN hkvVec3 hkvVec3___mul(hkvVec3 *self,float f){
      return (*self * f);
    }
SWIGINTERN hkvVec3 hkvVec3___div(hkvVec3 *self,float f){
      return (*self / f);
    }
SWIGINTERN float hkvVec3___getitem__(hkvVec3 *self,int iElem){
      if(iElem>=0 && iElem<3)
        return self->data[iElem];
        
      return 0;
    }
SWIGINTERN void hkvVec3___setitem__(hkvVec3 *self,int iElem,float fValue){
      if(iElem>=0 && iElem<3) 
        self->data[iElem] = fValue;
    }

  SWIGINTERN int hkvVec3_Concat(lua_State *L)
  {
    //this will move this function to the method table of the specified class
    
    bool ARGS_OK = true;
    
    const char *pszString = NULL;
    int iIndex = -1;
    
    //The concat operator allows "foo"..self and self.."bar" so that
    //we have to consider self as first and as second stack element.
    
    //handle string as first (top) element
    if(lua_isstring(L,iIndex))
    {
      pszString = lua_tostring(L,iIndex);
      iIndex--;
    }
    
    SWIG_CONVERT_POINTER(L, iIndex, hkvVec3, self)
    iIndex--;
    
    //handle string as second element
    if(iIndex==-2)
    {
      pszString = lua_tostring(L,iIndex);
    }
        
    unsigned int uiLen = (unsigned int) strlen(pszString);
    char *pszBuffer = new char[uiLen+128];
   
    sprintf(pszBuffer, "[%1.2f,%1.2f,%1.2f]",self->x,self->y,self->z); //format as requested
    
    //the new buffer should have the size of the old string and the new format string
    VASSERT_MSG(128>(strlen(pszBuffer)+uiLen), "Please increase your temp buffer size!");
    
    //append or prepend old buffer buffer (depending on the position inside the lua stack)
    if(iIndex==-3) //append old string
    {
      memcpy(pszBuffer+strlen(pszBuffer),pszString,uiLen+1); //also copy the terminator at the end
    }
    else //prepend old string
    {
      memmove(pszBuffer+uiLen,pszBuffer, strlen(pszBuffer)+1); //also move the terminator at the end
      memcpy(pszBuffer,pszString,uiLen); //insert the old string
    }

    lua_pushstring(L, pszBuffer);
  
    V_SAFE_DELETE_ARRAY(pszBuffer);

    return 1;
  }


  SWIGINTERN int hkvVec3_ToString(lua_State *L)
  {
    //this will move this function to the method table of the specified class
    
    SWIG_CONVERT_POINTER(L, -1, hkvVec3, self)
    
    char pszBuffer[1024];
    
    sprintf(pszBuffer, "hkvVec3: [%1.2f,%1.2f,%1.2f]",self->x,self->y,self->z); //format as requested
      
    lua_pushstring(L, pszBuffer);
    
    return 1;
  }

SWIGINTERN bool hkvMat3_invert(hkvMat3 *self){
      return self->invert()==HKV_SUCCESS;
    }
SWIGINTERN void hkvMat3_setScalingFactors__SWIG_1(hkvMat3 *self,float x,float y,float z){
      self->setScalingFactors(hkvVec3(x,y,z));
    }
SWIGINTERN float hkvMat3_getElement__SWIG_0(hkvMat3 *self,unsigned int iNthElement,bool bUseColumnMajor=true){
      return self->getElement(iNthElement, (bUseColumnMajor ? hkvMat3::ColumnMajor : hkvMat3::RowMajor));
    }
SWIGINTERN void hkvMat3_setElement__SWIG_0(hkvMat3 *self,unsigned int iNthElement,float f,bool bUseColumnMajor=true){
      self->setElement(iNthElement, f, (bUseColumnMajor ? hkvMat3::ColumnMajor : hkvMat3::RowMajor));
    }
SWIGINTERN void hkvMat3_setRow__SWIG_1(hkvMat3 *self,unsigned int iRow,float r0,float r1,float r2){
      self->setRow(iRow, hkvVec3(r0, r1, r2));
    }
SWIGINTERN void hkvMat3_setColumn__SWIG_1(hkvMat3 *self,unsigned int iColumn,float c0,float c1,float c2){
      self->setColumn(iColumn, hkvVec3(c0, c1, c2));
    }
SWIGINTERN void hkvMat3_setAxis__SWIG_0(hkvMat3 *self,unsigned int iAxisXYZ,float x,float y,float z){
      self->setAxis(iAxisXYZ, hkvVec3(x, y, z));
    }
SWIGINTERN void hkvMat3_setScalingMatrix__SWIG_0(hkvMat3 *self,float x,float y,float z){
      self->setScalingMatrix(hkvVec3(x, y, z));
    }
SWIGINTERN void hkvMat3_setRotationMatrix(hkvMat3 *self,hkvVec3 const *pAxis,float fDegree){
      if(pAxis!=NULL)
        self->setRotationMatrix(pAxis->getNormalized(), fDegree);
    }
SWIGINTERN hkvMat3 *new_hkvMat3__SWIG_0(bool bInitialize=true){
      hkvMat3 *pNew = new hkvMat3(hkvNoInitialization);
    
      if(!bInitialize) return pNew;
      
      pNew->setIdentity();
      return pNew;
    }
SWIGINTERN hkvMat3 *new_hkvMat3__SWIG_2(hkvMat3 const *pOther){     
      hkvMat3 *pNew = new hkvMat3(hkvNoInitialization);
    
      if(pOther!=NULL) pNew->set(pOther->m_ElementsCM, hkvMat3::ColumnMajor);
      
      return pNew;
    }
SWIGINTERN hkvMat3 *new_hkvMat3__SWIG_3(float c0r0,float c1r0,float c2r0,float c0r1,float c1r1,float c2r1,float c0r2,float c1r2,float c2r2,bool bUseColumnMajor=false){
      return new hkvMat3(c0r0, c1r0, c2r0, c0r1, c1r1, c2r1, c0r2, c1r2, c2r2, (bUseColumnMajor ? hkvMat3::ColumnMajor : hkvMat3::RowMajor) );
    }
SWIGINTERN void hkvMat3_set__SWIG_0(hkvMat3 *self,float c0r0,float c1r0,float c2r0,float c0r1,float c1r1,float c2r1,float c0r2,float c1r2,float c2r2,bool bUseColumnMajor=false){
      self->set(c0r0, c1r0, c2r0, c0r1, c1r1, c2r1, c0r2, c1r2, c2r2, (bUseColumnMajor ? hkvMat3::ColumnMajor : hkvMat3::RowMajor) );
    }
SWIGINTERN hkvMat3 hkvMat3_clone(hkvMat3 const *self){
      return *self; //will call the copy constructor
    }
SWIGINTERN bool hkvMat3___eq(hkvMat3 const *self,hkvMat3 const *pRhs){
      if(pRhs==NULL) return false;
      return pRhs->isEqual(*self, HKVMATH_DEFAULT_EPSILON);
    }
SWIGINTERN hkvMat3 hkvMat3___add(hkvMat3 *self,hkvMat3 const *pRhs){
      if(pRhs==NULL) return *self;
      return (*self + *pRhs);
    }
SWIGINTERN hkvMat3 hkvMat3___sub(hkvMat3 *self,hkvMat3 const *pRhs){
      if(pRhs==NULL) return *self;
      return (*self - *pRhs);
    }
SWIGINTERN hkvMat3 hkvMat3___mul__SWIG_0(hkvMat3 *self,hkvMat3 const *pRhs){
      #ifdef HKVMATH_ENABLE_NEW_OPERATORS
        if(pRhs==NULL) return *self;
        return (*self * *pRhs);
      #else
        Vision::Error.SystemMessage("Warning: Calling 'hkvMat3 operator* (const hkvMat3& lhs, const hkvMat3& rhs)' without enabling 'HKVMATH_ENABLE_NEW_OPERATORS'!");
        return *self;
      #endif
    }
SWIGINTERN hkvMat3 hkvMat3___mul__SWIG_1(hkvMat3 *self,float rhs){
      return (*self * rhs);
    }
SWIGINTERN hkvMat3 hkvMat3___div(hkvMat3 *self,float rhs){
      return (*self / rhs);
    }
SWIGINTERN float hkvMat3___getitem__(hkvMat3 *self,int iElem){
      if(iElem>=0 && iElem<9)  
        return self->m_ElementsCM[iElem];
        
      return 0;
    }
SWIGINTERN void hkvMat3___setitem__(hkvMat3 *self,int iElem,float fValue){
      if(iElem>=0 && iElem<9)      
        self->m_ElementsCM[iElem] = fValue;
    }

  SWIGINTERN int hkvMat3_Concat(lua_State *L)
  {
    //this will move this function to the method table of the specified class
    
    bool ARGS_OK = true;
    
    const char *pszString = NULL;
    int iIndex = -1;
    
    //The concat operator allows "foo"..self and self.."bar" so that
    //we have to consider self as first and as second stack element.
    
    //handle string as first (top) element
    if(lua_isstring(L,iIndex))
    {
      pszString = lua_tostring(L,iIndex);
      iIndex--;
    }
    
    SWIG_CONVERT_POINTER(L, iIndex, hkvMat3, self)
    iIndex--;
    
    //handle string as second element
    if(iIndex==-2)
    {
      pszString = lua_tostring(L,iIndex);
    }
        
    unsigned int uiLen = (unsigned int) strlen(pszString);
    char *pszBuffer = new char[uiLen+256];
   
    sprintf(pszBuffer, "[%1.2f,%1.2f,%1.2f][%1.2f,%1.2f,%1.2f][%1.2f,%1.2f,%1.2f]",self->m_ElementsCM[0],self->m_ElementsCM[1],self->m_ElementsCM[2],self->m_ElementsCM[3],self->m_ElementsCM[4],self->m_ElementsCM[5],self->m_ElementsCM[6],self->m_ElementsCM[7],self->m_ElementsCM[8]); //format as requested
    
    //the new buffer should have the size of the old string and the new format string
    VASSERT_MSG(256>(strlen(pszBuffer)+uiLen), "Please increase your temp buffer size!");
    
    //append or prepend old buffer buffer (depending on the position inside the lua stack)
    if(iIndex==-3) //append old string
    {
      memcpy(pszBuffer+strlen(pszBuffer),pszString,uiLen+1); //also copy the terminator at the end
    }
    else //prepend old string
    {
      memmove(pszBuffer+uiLen,pszBuffer, strlen(pszBuffer)+1); //also move the terminator at the end
      memcpy(pszBuffer,pszString,uiLen); //insert the old string
    }

    lua_pushstring(L, pszBuffer);
  
    V_SAFE_DELETE_ARRAY(pszBuffer);

    return 1;
  }


  SWIGINTERN int hkvMat3_ToString(lua_State *L)
  {
    //this will move this function to the method table of the specified class
    
    SWIG_CONVERT_POINTER(L, -1, hkvMat3, self)
    
    char pszBuffer[1024];
    
    sprintf(pszBuffer, "hkvMat3 CM: c0[%1.2f,%1.2f,%1.2f]  c1[%1.2f,%1.2f,%1.2f] c2[%1.2f,%1.2f,%1.2f]",self->m_ElementsCM[0],self->m_ElementsCM[1],self->m_ElementsCM[2],self->m_ElementsCM[3],self->m_ElementsCM[4],self->m_ElementsCM[5],self->m_ElementsCM[6],self->m_ElementsCM[7],self->m_ElementsCM[8]); //format as requested
      
    lua_pushstring(L, pszBuffer);
    
    return 1;
  }

SWIGINTERN hkvAlignedBBox *new_hkvAlignedBBox__SWIG_1(bool bInitialize=true){
      hkvAlignedBBox *pBox = new hkvAlignedBBox(hkvNoInitialization);
      if(!bInitialize) return pBox;
      pBox->setInvalid();
      return pBox;
    }
SWIGINTERN hkvAlignedBBox *new_hkvAlignedBBox__SWIG_3(float x1,float y1,float z1,float x2,float y2,float z2){
      return new hkvAlignedBBox(hkvVec3(x1, y1, z1), hkvVec3(x2, y2, z2));
    }
SWIGINTERN void hkvAlignedBBox_set__SWIG_1(hkvAlignedBBox *self,float x1,float y1,float z1,float x2,float y2,float z2){
      self->set(hkvVec3(x1, y1, z1), hkvVec3(x2, y2, z2));
    }
SWIGINTERN hkvAlignedBBox hkvAlignedBBox_clone(hkvAlignedBBox const *self){
      return *self; //will call the copy constructor
    }
SWIGINTERN bool hkvAlignedBBox___eq(hkvAlignedBBox const *self,hkvAlignedBBox const *pRhs){
      if(pRhs==NULL) return false;
      return pRhs->isEqual(*self, HKVMATH_DEFAULT_EPSILON);
    }

  SWIGINTERN int hkvAlignedBBox_Concat(lua_State *L)
  {
    //this will move this function to the method table of the specified class
    
    bool ARGS_OK = true;
    
    const char *pszString = NULL;
    int iIndex = -1;
    
    //The concat operator allows "foo"..self and self.."bar" so that
    //we have to consider self as first and as second stack element.
    
    //handle string as first (top) element
    if(lua_isstring(L,iIndex))
    {
      pszString = lua_tostring(L,iIndex);
      iIndex--;
    }
    
    SWIG_CONVERT_POINTER(L, iIndex, hkvAlignedBBox, self)
    iIndex--;
    
    //handle string as second element
    if(iIndex==-2)
    {
      pszString = lua_tostring(L,iIndex);
    }
        
    unsigned int uiLen = (unsigned int) strlen(pszString);
    char *pszBuffer = new char[uiLen+64];
   
    sprintf(pszBuffer, "[%1.2f,%1.2f,%1.2f][%1.2f,%1.2f,%1.2f]",self->m_vMin.x,self->m_vMin.y,self->m_vMin.z,self->m_vMax.x,self->m_vMax.y,self->m_vMax.z); //format as requested
    
    //the new buffer should have the size of the old string and the new format string
    VASSERT_MSG(64>(strlen(pszBuffer)+uiLen), "Please increase your temp buffer size!");
    
    //append or prepend old buffer buffer (depending on the position inside the lua stack)
    if(iIndex==-3) //append old string
    {
      memcpy(pszBuffer+strlen(pszBuffer),pszString,uiLen+1); //also copy the terminator at the end
    }
    else //prepend old string
    {
      memmove(pszBuffer+uiLen,pszBuffer, strlen(pszBuffer)+1); //also move the terminator at the end
      memcpy(pszBuffer,pszString,uiLen); //insert the old string
    }

    lua_pushstring(L, pszBuffer);
  
    V_SAFE_DELETE_ARRAY(pszBuffer);

    return 1;
  }


  SWIGINTERN int hkvAlignedBBox_ToString(lua_State *L)
  {
    //this will move this function to the method table of the specified class
    
    SWIG_CONVERT_POINTER(L, -1, hkvAlignedBBox, self)
    
    char pszBuffer[1024];
    
    sprintf(pszBuffer, "hkvAlignedBBox: Min[%1.2f,%1.2f,%1.2f] - Max[%1.2f,%1.2f,%1.2f]",self->m_vMin.x,self->m_vMin.y,self->m_vMin.z,self->m_vMax.x,self->m_vMax.y,self->m_vMax.z); //format as requested
      
    lua_pushstring(L, pszBuffer);
    
    return 1;
  }


  SWIGINTERN int hkvAlignedBBox_getCorners(lua_State *L)
  {
    
    SWIG_CONVERT_POINTER(L, 1, hkvAlignedBBox, pBox)

    lua_newtable(L); //create an empty table (or an array if you would like to see it this way)
    
    hkvVec3 vecs[8];
    
    pBox->getCorners(vecs);
    
    SWIG_Lua_NewPointerObj(L,new hkvVec3(vecs[0]),SWIGTYPE_p_hkvVec3, VLUA_MANAGE_MEM_BY_LUA);
    lua_rawseti(L, -2, 1);
    SWIG_Lua_NewPointerObj(L,new hkvVec3(vecs[1]),SWIGTYPE_p_hkvVec3, VLUA_MANAGE_MEM_BY_LUA);
    lua_rawseti(L, -2, 2);
    SWIG_Lua_NewPointerObj(L,new hkvVec3(vecs[2]),SWIGTYPE_p_hkvVec3, VLUA_MANAGE_MEM_BY_LUA);
    lua_rawseti(L, -2, 3);
    SWIG_Lua_NewPointerObj(L,new hkvVec3(vecs[3]),SWIGTYPE_p_hkvVec3, VLUA_MANAGE_MEM_BY_LUA);
    lua_rawseti(L, -2, 4);
    
    SWIG_Lua_NewPointerObj(L,new hkvVec3(vecs[4]),SWIGTYPE_p_hkvVec3, VLUA_MANAGE_MEM_BY_LUA);
    lua_rawseti(L, -2, 5);
    SWIG_Lua_NewPointerObj(L,new hkvVec3(vecs[5]),SWIGTYPE_p_hkvVec3, VLUA_MANAGE_MEM_BY_LUA);
    lua_rawseti(L, -2, 6);
    SWIG_Lua_NewPointerObj(L,new hkvVec3(vecs[6]),SWIGTYPE_p_hkvVec3, VLUA_MANAGE_MEM_BY_LUA);
    lua_rawseti(L, -2, 7);
    SWIG_Lua_NewPointerObj(L,new hkvVec3(vecs[7]),SWIGTYPE_p_hkvVec3, VLUA_MANAGE_MEM_BY_LUA);
    lua_rawseti(L, -2, 8);
    
    return 1; //the table 
  }

SWIGINTERN VColorRef *new_VColorRef__SWIG_3(VColorRef const &other){
      return new VColorRef(other.r, other.g, other.b, other.a);
    }
SWIGINTERN VColorRef VColorRef_Clone(VColorRef *self){
      return VColorRef(self->r, self->g, self->b, self->a);
    }
SWIGINTERN VColorRef VColorRef_clone(VColorRef *self){
      return VColorRef(self->r, self->g, self->b, self->a);
    }

  SWIGINTERN int VColorRef_Concat(lua_State *L)
  {
    //this will move this function to the method table of the specified class
    
    bool ARGS_OK = true;
    
    const char *pszString = NULL;
    int iIndex = -1;
    
    //The concat operator allows "foo"..self and self.."bar" so that
    //we have to consider self as first and as second stack element.
    
    //handle string as first (top) element
    if(lua_isstring(L,iIndex))
    {
      pszString = lua_tostring(L,iIndex);
      iIndex--;
    }
    
    SWIG_CONVERT_POINTER(L, iIndex, VColorRef, self)
    iIndex--;
    
    //handle string as second element
    if(iIndex==-2)
    {
      pszString = lua_tostring(L,iIndex);
    }
        
    unsigned int uiLen = (unsigned int) strlen(pszString);
    char *pszBuffer = new char[uiLen+32];
   
    sprintf(pszBuffer, "[%d,%d,%d,%d]",self->r,self->g,self->b,self->a); //format as requested
    
    //the new buffer should have the size of the old string and the new format string
    VASSERT_MSG(32>(strlen(pszBuffer)+uiLen), "Please increase your temp buffer size!");
    
    //append or prepend old buffer buffer (depending on the position inside the lua stack)
    if(iIndex==-3) //append old string
    {
      memcpy(pszBuffer+strlen(pszBuffer),pszString,uiLen+1); //also copy the terminator at the end
    }
    else //prepend old string
    {
      memmove(pszBuffer+uiLen,pszBuffer, strlen(pszBuffer)+1); //also move the terminator at the end
      memcpy(pszBuffer,pszString,uiLen); //insert the old string
    }

    lua_pushstring(L, pszBuffer);
  
    V_SAFE_DELETE_ARRAY(pszBuffer);

    return 1;
  }


  SWIGINTERN int VColorRef_ToString(lua_State *L)
  {
    //this will move this function to the method table of the specified class
    
    SWIG_CONVERT_POINTER(L, -1, VColorRef, self)
    
    char pszBuffer[1024];
    
    sprintf(pszBuffer, "VColorRef: R %d, G %d, B %d, A %d",self->r,self->g,self->b,self->a); //format as requested
      
    lua_pushstring(L, pszBuffer);
    
    return 1;
  }


SWIGINTERN int SWIG_lua_isnilstring(lua_State *L, int idx) {
  int ret = lua_isstring(L, idx);
  if (!ret)
   ret = lua_isnil(L, idx);
  return ret;
}

SWIGINTERN VBitmask VBitmask_Clone(VBitmask *self){
      return VBitmask(*self);
    }

  SWIGINTERN int VBitmask_Concat(lua_State *L)
  {
    //this will move this function to the method table of the specified class
    
    bool ARGS_OK = true;
    
    const char *pszString = NULL;
    int iIndex = -1;
    
    //The concat operator allows "foo"..self and self.."bar" so that
    //we have to consider self as first and as second stack element.
    
    //handle string as first (top) element
    if(lua_isstring(L,iIndex))
    {
      pszString = lua_tostring(L,iIndex);
      iIndex--;
    }
    
    SWIG_CONVERT_POINTER(L, iIndex, VBitmask, self)
    iIndex--;
    
    //handle string as second element
    if(iIndex==-2)
    {
      pszString = lua_tostring(L,iIndex);
    }
        
    unsigned int uiLen = (unsigned int) strlen(pszString);
    char *pszBuffer = new char[uiLen+16];
   
    sprintf(pszBuffer, "0x%04x",self->Get()); //format as requested
    
    //the new buffer should have the size of the old string and the new format string
    VASSERT_MSG(16>(strlen(pszBuffer)+uiLen), "Please increase your temp buffer size!");
    
    //append or prepend old buffer buffer (depending on the position inside the lua stack)
    if(iIndex==-3) //append old string
    {
      memcpy(pszBuffer+strlen(pszBuffer),pszString,uiLen+1); //also copy the terminator at the end
    }
    else //prepend old string
    {
      memmove(pszBuffer+uiLen,pszBuffer, strlen(pszBuffer)+1); //also move the terminator at the end
      memcpy(pszBuffer,pszString,uiLen); //insert the old string
    }

    lua_pushstring(L, pszBuffer);
  
    V_SAFE_DELETE_ARRAY(pszBuffer);

    return 1;
  }


  SWIGINTERN int VBitmask_ToString(lua_State *L)
  {
    //this will move this function to the method table of the specified class
    
    SWIG_CONVERT_POINTER(L, -1, VBitmask, self)
    
    char pszBuffer[1024];
    
    sprintf(pszBuffer, "VBitmask [0x%04x]",self->Get()); //format as requested
      
    lua_pushstring(L, pszBuffer);
    
    return 1;
  }

SWIGINTERN char const *VTypedObject_GetType(VTypedObject const *self){
      return self->GetTypeId()->m_lpszClassName;
    }
SWIGINTERN bool VTypedObject_IsOfType(VTypedObject *self,char const *szType){
      return self->IsOfType(szType)==TRUE;
    }
SWIGINTERN char const *VTypedObject_GetPropertyType(VTypedObject *self,char const *propName){
      if(propName==NULL)
        return NULL; // avoid problems with nil values
      VisVariable_cl *pVar = self->GetVariable(propName);
      int type = pVar ? pVar->type : -1;
      switch (type) {
          case VULPTYPE_STRING:
          case VULPTYPE_VSTRING:
          case VULPTYPE_MODEL:
          case VULPTYPE_PSTRING:
          case VULPTYPE_ENTITY_KEY:
          case VULPTYPE_PRIMITIVE_KEY:
          case VULPTYPE_VERTEX_KEY:
          case VULPTYPE_LIGHTSOURCE_KEY:
          case VULPTYPE_WORLDANIMATION_KEY:
          case VULPTYPE_PATH_KEY:
            return "string";
          case VULPTYPE_ENUM:
          case VULPTYPE_INT:
          case VULPTYPE_FLOAT:
          case VULPTYPE_DOUBLE:
            return "number";
          case VULPTYPE_BOOL:	
            return "boolean";
          case VULPTYPE_VECTOR_INT:
          case VULPTYPE_VECTOR_FLOAT:
          case VULPTYPE_VECTOR_DOUBLE:
            return "hkvVec3";
          case VULPTYPE_BYTE_COLOR4:
            return "VColorRef";
          default:
            Vision::Error.Warning("Type of property '%s' is unknown in Lua.", propName);
            return NULL;
      }
    }
SWIGINTERN bool VTypedObject_operator_Se__Se_(VTypedObject *self,VTypedObject const &other){
      return self==&other;
    }

  SWIGINTERN int VTypedObject_GetProperties(lua_State *L)
  {
    
    SWIG_CONVERT_POINTER(L, 1, VTypedObject, pTypedObject)

    lua_newtable(L); //create an empty table (or an array if you would like to see it this way)
    
    int iCount = pTypedObject->GetNumVariables();

    for(int i=0;i<iCount;++i)
    {
      const char * szName = pTypedObject->GetVariableName(i);
      
      lua_newtable(L);             // create a new sub table             stack: table, table, TOP      
      lua_pushstring(L, "Name");   // push the key                       stack: table, table, key, TOP
      lua_pushstring(L, szName);   // push the value                     stack: table, table, key, value, TOP
      lua_settable(L, -3);         // set key and value as entry         stack: table, table, TOP
      
      lua_pushstring(L, "Type");   // push the key                       stack: table, table, key, TOP
      
      switch(pTypedObject->GetVariable(szName)->type)
      {
        case VULPTYPE_STRING:
        case VULPTYPE_VSTRING:
        case VULPTYPE_MODEL:
        case VULPTYPE_PSTRING:
        case VULPTYPE_ENTITY_KEY:
        case VULPTYPE_PRIMITIVE_KEY:
        case VULPTYPE_VERTEX_KEY:
        case VULPTYPE_LIGHTSOURCE_KEY:
        case VULPTYPE_WORLDANIMATION_KEY:
        case VULPTYPE_PATH_KEY:
          lua_pushstring(L, "string");
          break;
        case VULPTYPE_ENUM:	
        case VULPTYPE_INT:	
        case VULPTYPE_FLOAT:
        case VULPTYPE_DOUBLE:
          lua_pushstring(L, "number");
          break;
        case VULPTYPE_BOOL:
          lua_pushstring(L, "boolean");
          break;
        case VULPTYPE_VECTOR_INT:
        case VULPTYPE_VECTOR_FLOAT:
        case VULPTYPE_VECTOR_DOUBLE:
          lua_pushstring(L, "hkvVec3");
          break;
        case VULPTYPE_BYTE_COLOR4:
          lua_pushstring(L, "VColorRef");
          break;
        default:
          lua_pushstring(L, "unknown");
          break;
      }
      //after switch:                                                 stack: table, table, key, value, TOP
      
      lua_settable(L, -3);      //set key and value as entry          stack: table, table, TOP
      lua_rawseti(L, -2, i+1);  //add to overall table                stack: table, TOP
    }
    
    return 1; //the table is always on the stack (even if empty)
  }


  SWIGINTERN int VTypedObject_GetProperty(lua_State *L)
  {
    
    DECLARE_ARGS_OK;
  
    SWIG_CONVERT_POINTER(L, 1, VTypedObject, pTypedObject)

    GET_ARG(2, const char *, pszName);
    lua_pop(L,2);

    if (ARGS_OK) {
      VisVariable_cl *pVar = pTypedObject->GetVariable(pszName);
      if (!pVar) {
        luaL_error(L, "Called getter of unknown property '%s'", pszName);
        lua_pushnil(L);
        return 1;
      }
      
      switch (pVar->type) {
        case VULPTYPE_STRING:
        case VULPTYPE_MODEL:
        case VULPTYPE_PSTRING:
        case VULPTYPE_ENTITY_KEY:
        case VULPTYPE_PRIMITIVE_KEY:
        case VULPTYPE_VERTEX_KEY:
        case VULPTYPE_LIGHTSOURCE_KEY:
        case VULPTYPE_WORLDANIMATION_KEY:
        case VULPTYPE_PATH_KEY:
          {
            const char *pStr = NULL;
            pVar->GetValueDirect(pTypedObject, (void*) &pStr, true);
            lua_pushstring(L, pStr);
          }
          break;
        case VULPTYPE_VSTRING:
          {
            VString vstr;
            pVar->GetValueDirect(pTypedObject, (void*) &vstr, true);
            lua_pushstring(L, vstr.AsChar());
          }
          break;
        case VULPTYPE_ENUM:	
        case VULPTYPE_INT:	
          {
            int n;
            pVar->GetValueDirect(pTypedObject, (void*) &n, true);
            lua_pushnumber(L, (lua_Number) n);
          }
          break;
        case VULPTYPE_FLOAT:
          {
            float n;
            pVar->GetValueDirect(pTypedObject, (void*) &n, true);
            lua_pushnumber(L, (lua_Number) n);
          }
          break;
        case VULPTYPE_DOUBLE:
          {
            double n;
            pVar->GetValueDirect(pTypedObject, (void*) &n, true);
            lua_pushnumber(L, (lua_Number) n);
          }
          break;
        case VULPTYPE_BOOL:	
          {
            BOOL b;
            pVar->GetValueDirect(pTypedObject, (void*) &b, true);
            lua_pushboolean(L, (int) b);
          }
          break;
        case VULPTYPE_VECTOR_INT:
          {
            int pN[3];
            pVar->GetValueDirect(pTypedObject, (void*) pN, true);
            hkvVec3 *vector = new hkvVec3((float)pN[0], (float)pN[1], (float)pN[2]);
            SWIG_Lua_NewPointerObj(L,vector,SWIGTYPE_p_hkvVec3, VLUA_MANAGE_MEM_BY_LUA);
          }
          break;
        case VULPTYPE_VECTOR_FLOAT:
          {
            float pN[3];
            pVar->GetValueDirect(pTypedObject, (void*) pN, true);
            hkvVec3 *vector = new hkvVec3(pN[0], pN[1], pN[2]);
            SWIG_Lua_NewPointerObj(L,vector,SWIGTYPE_p_hkvVec3, VLUA_MANAGE_MEM_BY_LUA);
          }
          break;
        case VULPTYPE_VECTOR_DOUBLE:
          {
            double pN[3];
            pVar->GetValueDirect(pTypedObject, (void*) pN, true);
            hkvVec3 *vector = new hkvVec3((float)pN[0], (float)pN[1], (float)pN[2]);
            SWIG_Lua_NewPointerObj(L,vector,SWIGTYPE_p_hkvVec3, VLUA_MANAGE_MEM_BY_LUA);
          }
          break;
        case VULPTYPE_BYTE_COLOR4:
          {
            VColorRef *color = new VColorRef();
            pVar->GetValueDirect(pTypedObject, (void*) color, true);
            SWIG_Lua_NewPointerObj(L,color,SWIGTYPE_p_VColorRef, VLUA_MANAGE_MEM_BY_LUA);
          }
          break;
        default:
          luaL_error(L, "Called getter of unknown type %d (%s)", pVar->type, pszName);
          lua_pushnil(L);
          break;
      }
      return 1;
    }
    return 0;
  }


  SWIGINTERN int VTypedObject_SetProperty(lua_State *L)
  {
    
    DECLARE_ARGS_OK;

    SWIG_CONVERT_POINTER(L, 1, VTypedObject, pTypedObject)

    GET_ARG(2, const char *, pszName);

    if (ARGS_OK)
    {
      VisVariable_cl *pVar = pTypedObject->GetVariable(pszName);

      if (!pVar)
      {
        luaL_error(L, "Called setter of unknown property '%s'", pszName);
        lua_pushnil(L);
        return 1;
      }
      
      switch (pVar->type) {
        case VULPTYPE_STRING:
        case VULPTYPE_VSTRING:
        case VULPTYPE_MODEL:
        case VULPTYPE_PSTRING:
        case VULPTYPE_ENTITY_KEY:
        case VULPTYPE_PRIMITIVE_KEY:
        case VULPTYPE_VERTEX_KEY:
        case VULPTYPE_LIGHTSOURCE_KEY:
        case VULPTYPE_WORLDANIMATION_KEY:
        case VULPTYPE_PATH_KEY:
          {
            GET_ARG(3, const char *, pszVal);
            pVar->SetValue(pTypedObject, pszVal, true);
          }
          break;
        case VULPTYPE_ENUM:	
        case VULPTYPE_INT:	
          {
            GET_ARG(3, lua_Number, n);
            int i = (int) n;
            pVar->SetValueDirect(pTypedObject, (void*) &i, true);
          }
          break;
        case VULPTYPE_FLOAT:
          {
            GET_ARG(3, lua_Number, n);
            float f = (float) n;
            pVar->SetValueDirect(pTypedObject, (void*) &f, true);
          }
          break;
        case VULPTYPE_DOUBLE:
          {
            GET_ARG(3, lua_Number, n);
            double d = (double) n;
            pVar->SetValueDirect(pTypedObject, (void*) &d, true);
          }
          break;
        case VULPTYPE_BOOL:	
          {
            GET_ARG(3, bool, n);
            BOOL b = (BOOL) n;
            pVar->SetValueDirect(pTypedObject, (void*) &b, true);
          }
          break;
        case VULPTYPE_VECTOR_INT:
          {
            GET_ARG(3, hkvVec3, vec);
            int pI[3] = {(int) vec.x, (int) vec.y, (int) vec.z};
            pVar->SetValueDirect(pTypedObject, (void*) pI, true);
          }
          break;
        case VULPTYPE_VECTOR_FLOAT:
          {
            GET_ARG(3, hkvVec3, vec);
            float pF[3] = {vec.x, vec.y, vec.z};
            pVar->SetValueDirect(pTypedObject, (void*) pF, true);
          }
          break;
        case VULPTYPE_VECTOR_DOUBLE:
          {
            GET_ARG(3, hkvVec3, vec);
            double pD[3] = {(double) vec.x, (double) vec.y, (double) vec.z};
            pVar->SetValueDirect(pTypedObject, (void*) pD, true);
          }
          break;
        case VULPTYPE_BYTE_COLOR4:
          {
            GET_ARG(3, VColorRef, col);
            pVar->SetValueDirect(pTypedObject, (void*) &col, true);
          }
          break;
        default:
          luaL_error(L, "Called setter of unknown type %d (%s)", pVar->type, pszName);
          break;
      }
    }

    //remove all stack items
    lua_settop(L, 0);
    //LUA_STACK_DUMP(L);
    return 0;
  }


  SWIGINTERN int VTypedObject_Concat(lua_State *L)
  {
    //this will move this function to the method table of the specified class
    
    bool ARGS_OK = true;
    
    const char *pszString = NULL;
    int iIndex = -1;
    
    //The concat operator allows "foo"..self and self.."bar" so that
    //we have to consider self as first and as second stack element.
    
    //handle string as first (top) element
    if(lua_isstring(L,iIndex))
    {
      pszString = lua_tostring(L,iIndex);
      iIndex--;
    }
    
    SWIG_CONVERT_POINTER(L, iIndex, VTypedObject, self)
    iIndex--;
    
    //handle string as second element
    if(iIndex==-2)
    {
      pszString = lua_tostring(L,iIndex);
    }
        
    unsigned int uiLen = (unsigned int) strlen(pszString);
    char *pszBuffer = new char[uiLen+128];
   
    sprintf(pszBuffer, "%s",self->GetClassTypeId()->m_lpszClassName); //format as requested
    
    //the new buffer should have the size of the old string and the new format string
    VASSERT_MSG(128>(strlen(pszBuffer)+uiLen), "Please increase your temp buffer size!");
    
    //append or prepend old buffer buffer (depending on the position inside the lua stack)
    if(iIndex==-3) //append old string
    {
      memcpy(pszBuffer+strlen(pszBuffer),pszString,uiLen+1); //also copy the terminator at the end
    }
    else //prepend old string
    {
      memmove(pszBuffer+uiLen,pszBuffer, strlen(pszBuffer)+1); //also move the terminator at the end
      memcpy(pszBuffer,pszString,uiLen); //insert the old string
    }

    lua_pushstring(L, pszBuffer);
  
    V_SAFE_DELETE_ARRAY(pszBuffer);

    return 1;
  }


  SWIGINTERN int VTypedObject_ToString(lua_State *L)
  {
    //this will move this function to the method table of the specified class
    
    SWIG_CONVERT_POINTER(L, -1, VTypedObject, self)
    
    char pszBuffer[1024];
    
    sprintf(pszBuffer, "%s: 0x%p",self->GetClassTypeId()->m_lpszClassName,self); //format as requested
      
    lua_pushstring(L, pszBuffer);
    
    return 1;
  }

SWIGINTERN int VisTypedEngineObject_cl_GetComponentCount(VisTypedEngineObject_cl *self){
      return self->Components().Count();
    }
SWIGINTERN bool VisTypedEngineObject_cl_AddComponent(VisTypedEngineObject_cl *self,IVObjectComponent *component){
      if (component == NULL) return false;
      return self->AddComponent(component)==TRUE;
    }
SWIGINTERN bool VisTypedEngineObject_cl_RemoveComponent(VisTypedEngineObject_cl *self,IVObjectComponent *component){
      if (component == NULL) return false;
      return self->RemoveComponent(component)==TRUE;
    }
SWIGINTERN bool VisTypedEngineObject_cl_RemoveComponentOfType__SWIG_0(VisTypedEngineObject_cl *self,char const *szTypeName,char const *szOptionalComponentName=NULL){
      if(szTypeName==NULL)
        return false;
      
      IVObjectComponent *pComponent = NULL;
      
      if(szOptionalComponentName)
        pComponent = self->Components().GetComponentOfTypeAndName(szTypeName, szOptionalComponentName);
      else
        pComponent = self->Components().GetComponentOfType(szTypeName);
      
      if(pComponent==NULL)
        return false;
        
      return self->RemoveComponent(pComponent)==TRUE;
    }

  SWIGINTERN int VisTypedEngineObject_cl_AddComponentOfType(lua_State *L)
  {

    SWIG_CONVERT_POINTER(L, 1, VisTypedEngineObject_cl, pSelf)

    //param #2: type name of the component
    if(!SWIG_lua_isnilstring(L,2)) luaL_error(L, "Expected a string value as parameter 2 for VisTypedEngineObject_AddComponentOfType");
    const char * szComponentType = lua_tostring(L, 2);       
    
    //param #3: optional name of the component
    const char * szComponentName = NULL;
    if(lua_isstring(L, 3))  szComponentName = lua_tostring(L, 3);
    
    bool bCreateDynamicProperty = true;
    if(lua_isboolean(L, 4)) bCreateDynamicProperty = lua_toboolean(L,4)==TRUE;

    // Search for a component type with the specified name
    VType *pType = Vision::GetTypeManager()->GetType(szComponentType);
    if (pType==NULL)
    {
      Vision::Error.Warning("[Lua] AddComponentOfType: did not find component of the specified type: %s", szComponentType);
      lua_settop(L, 0); //remove all items from the stack
      lua_pushnil(L);
      return 1;
    }

    // Create an instance of that component type
    VSmartPtr<IVObjectComponent> spComponent = (IVObjectComponent *)pType->CreateInstance();
    if (spComponent==NULL)
    {
      Vision::Error.Warning("[Lua] AddComponentOfType: Failed construction an instance of the specified component type: %s", szComponentType);
      lua_settop(L, 0); //remove all items from the stack
      lua_pushnil(L);
      return 1;
    }

    if(szComponentName && bCreateDynamicProperty)
    {
      spComponent->SetComponentName(szComponentName);
        
      //prepare stack in order to set the result of the casted object component as property
      //remove everything, expect self
      lua_settop(L, 1);                                           //stack: userdata, TOP
      lua_pushstring(L, szComponentName);                         //stack: userdata, key, TOP
      LUA_PushObjectProxy(L, spComponent, pSelf);                  //stack: userdata, key, result, TOP

      //set the dynamic property
      VisionLuaClassSet(L);                                       //stack: userdata, key, result, TOP
      lua_replace(L, 1);                                          //stack: result, key, TOP
      lua_pop(L, 1);                                              //stack: result, TOP

    }
    else
    {   
      //if the component has a name, but the user likes to avoid a dynamic property,
      //we only set the name of the component and try to cast
      
      if(szComponentName) spComponent->SetComponentName(szComponentName);
      
      //clean stack (remove all call params including self)
      lua_settop(L, 0);                                          //stack: TOP
      LUA_PushObjectProxy(L, spComponent, pSelf);                 //stack: result, TOP
    }

    // Check if the component can actually be added. Don't do it if it can't.
    VString sCanAddError;
    if (!pSelf->CanAddComponent(spComponent, sCanAddError))
    {
      Vision::Error.Warning("[Lua] AddComponentOfType: Can't add component of type '%s'. Error: %s", szComponentType, sCanAddError.AsChar());
      lua_settop(L, 0); //remove all items from the stack
      lua_pushnil(L);
      return 1;
    }

    // Add the component to the current object
    pSelf->AddComponent(spComponent);
    
    return 1;
  }


  SWIGINTERN int VisTypedEngineObject_cl_GetComponentAt(lua_State *L)
  {

    SWIG_CONVERT_POINTER(L, 1, VisTypedEngineObject_cl, pSelf)

    //param #2: type name of the component
    if(!lua_isnumber(L,2)) luaL_error(L, "Expected a numeric index as parameter 2 for VisTypedEngineObject_cl_GetComponentAt");
    int iIndex = (int)lua_tonumber(L, 2);
   
    lua_settop(L, 0);                                              //stack: TOP
    if(iIndex>0 && iIndex<=pSelf->Components().Count())
      LUA_PushObjectProxy(L, pSelf->Components().GetAt(iIndex-1)); //stack: result, TOP
    else
      lua_pushnil(L);                                              //stack: nil, TOP

    return 1;
  }


  SWIGINTERN int VisTypedEngineObject_cl_AddTriggerTarget(lua_State *L)
  {
    
    //insert the class name of the component as parameter #2
    lua_pushstring(L, "VisTriggerTargetComponent_cl");
    lua_insert(L, 2);
    
    return VisTypedEngineObject_cl_AddComponentOfType(L);
  }


  SWIGINTERN int VisTypedEngineObject_cl_AddTriggerSource(lua_State *L)
  {
    
    //insert the class name of the component as parameter #2
    lua_pushstring(L, "VisTriggerSourceComponent_cl");
    lua_insert(L, 2);
    
    return VisTypedEngineObject_cl_AddComponentOfType(L);
  }


  SWIGINTERN int VisTypedEngineObject_cl_AddAnimation(lua_State *L)
  {
    
    //insert the class name of the component as parameter #2
    lua_pushstring(L, "VAnimationComponent");
    lua_insert(L, 2);
    
    return VisTypedEngineObject_cl_AddComponentOfType(L);
  }


  SWIGINTERN int VisTypedEngineObject_cl_AddTimedValue(lua_State *L)
  {
    
    //insert the class name of the component as parameter #2
    lua_pushstring(L, "VTimedValueComponent");
    lua_insert(L, 2);
    
    return VisTypedEngineObject_cl_AddComponentOfType(L);
  }


  SWIGINTERN int VisTypedEngineObject_cl_AddTransitionStateMachine(lua_State *L)
  {
    
    //insert the class name of the component as parameter #2
    lua_pushstring(L, "VTransitionStateMachine");
    lua_insert(L, 2);
    
    return VisTypedEngineObject_cl_AddComponentOfType(L);
  }


  SWIGINTERN int VisTypedEngineObject_cl_GetComponentOfType(lua_State *L)
  {

    SWIG_CONVERT_POINTER(L, 1, VisTypedEngineObject_cl, pSelf)

    //param #2: type name of the component
    if(!SWIG_lua_isnilstring(L,2)) luaL_error(L, "Expected a string value as parameter 2 for VisTypedEngineObject_GetComponentOfType");
    const char * szComponentType = lua_tostring(L, 2);       
    
    //param #3: optional name of the component
    const char * szComponentName = NULL;
    if(lua_isstring(L, 3))  szComponentName = lua_tostring(L, 3);
    
    IVObjectComponent *pComponent = NULL;
    
    if(szComponentName)
      pComponent = pSelf->Components().GetComponentOfTypeAndName(szComponentType, szComponentName);
    else
      pComponent = pSelf->Components().GetComponentOfType(szComponentType);    

    //clean stack (remove all call params including self)
    lua_settop(L, 0);                                             //stack: TOP

    if(pComponent) LUA_PushObjectProxy(L, pComponent);            //stack: result, TOP
    else           lua_pushnil(L);                                //stack: nil, TOP

    return 1;
  }


  SWIGINTERN int VisTypedEngineObject_cl_GetComponentOfBaseType(lua_State *L)
  {

    SWIG_CONVERT_POINTER(L, 1, VisTypedEngineObject_cl, pSelf)

    //param #2: type name of the component
    if(!SWIG_lua_isnilstring(L,2)) luaL_error(L, "Expected a string value as parameter 2 for VisTypedEngineObject_GetComponentOfBaseType");
    const char * szBaseTypeName = lua_tostring(L, 2);       
    
    //param #3: optional name of the component
    const char * szComponentName = NULL;
    if(lua_isstring(L, 3))  szComponentName = lua_tostring(L, 3);
        
    IVObjectComponent *pComponent = NULL;
    
    if(szComponentName)
      pComponent = pSelf->Components().GetComponentOfBaseTypeAndName(szBaseTypeName, szComponentName);
    else
      pComponent = pSelf->Components().GetComponentOfBaseType(szBaseTypeName);

    //clean stack (remove all call params including self)
    lua_settop(L, 0);                                             //stack: TOP

    if(pComponent) LUA_PushObjectProxy(L, pComponent);            //stack: result, TOP
    else           lua_pushnil(L);                                //stack: nil, TOP
    
    return 1;
  }


  SWIGINTERN int VisTypedEngineObject_cl_Concat(lua_State *L)
  {
    //this will move this function to the method table of the specified class
    
    bool ARGS_OK = true;
    
    const char *pszString = NULL;
    int iIndex = -1;
    
    //The concat operator allows "foo"..self and self.."bar" so that
    //we have to consider self as first and as second stack element.
    
    //handle string as first (top) element
    if(lua_isstring(L,iIndex))
    {
      pszString = lua_tostring(L,iIndex);
      iIndex--;
    }
    
    SWIG_CONVERT_POINTER(L, iIndex, VisTypedEngineObject_cl, self)
    iIndex--;
    
    //handle string as second element
    if(iIndex==-2)
    {
      pszString = lua_tostring(L,iIndex);
    }
        
    unsigned int uiLen = (unsigned int) strlen(pszString);
    char *pszBuffer = new char[uiLen+128];
   
    sprintf(pszBuffer, "%s",self->GetClassTypeId()->m_lpszClassName); //format as requested
    
    //the new buffer should have the size of the old string and the new format string
    VASSERT_MSG(128>(strlen(pszBuffer)+uiLen), "Please increase your temp buffer size!");
    
    //append or prepend old buffer buffer (depending on the position inside the lua stack)
    if(iIndex==-3) //append old string
    {
      memcpy(pszBuffer+strlen(pszBuffer),pszString,uiLen+1); //also copy the terminator at the end
    }
    else //prepend old string
    {
      memmove(pszBuffer+uiLen,pszBuffer, strlen(pszBuffer)+1); //also move the terminator at the end
      memcpy(pszBuffer,pszString,uiLen); //insert the old string
    }

    lua_pushstring(L, pszBuffer);
  
    V_SAFE_DELETE_ARRAY(pszBuffer);

    return 1;
  }


  SWIGINTERN int VisTypedEngineObject_cl_ToString(lua_State *L)
  {
    //this will move this function to the method table of the specified class
    
    SWIG_CONVERT_POINTER(L, -1, VisTypedEngineObject_cl, self)
    
    char pszBuffer[1024];
    
    sprintf(pszBuffer, "%s: 0x%p",self->GetClassTypeId()->m_lpszClassName,self); //format as requested
      
    lua_pushstring(L, pszBuffer);
    
    return 1;
  }

SWIGINTERN bool VisObjectKey_cl_HasKey__SWIG_0(VisObjectKey_cl *self,char const *szKey,bool bIgnoreCase=true){
      return self->HasObjectKey(szKey, bIgnoreCase)==TRUE;
    }
SWIGINTERN hkvVec3 VisObject3D_cl_GetPosition(VisObject3D_cl *self){
      return hkvVec3(self->GetPosition()); // return by value
    }
SWIGINTERN void VisObject3D_cl_SetPosition__SWIG_1(VisObject3D_cl *self,float x,float y,float z){
      self->SetPosition(hkvVec3(x,y,z));
    }
SWIGINTERN void VisObject3D_cl_IncPosition__SWIG_1(VisObject3D_cl *self,float x,float y,float z){
      self->IncPosition(hkvVec3(x,y,z));
    }
SWIGINTERN void VisObject3D_cl_SetOrientation__SWIG_0(VisObject3D_cl *self,float x,float y,float z){
      self->SetOrientation(hkvVec3(x,y,z));
    }
SWIGINTERN void VisObject3D_cl_IncOrientation__SWIG_0(VisObject3D_cl *self,float x,float y,float z){
      self->IncOrientation(hkvVec3(x,y,z));
    }
SWIGINTERN void VisObject3D_cl_SetUseEulerAngles(VisObject3D_cl *self,bool bValue){
    self->SetUseEulerAngles(bValue);
  }
SWIGINTERN bool VisObject3D_cl_GetUseEulerAngles(VisObject3D_cl const *self){
    return self->GetUseEulerAngles()==TRUE;
  }
SWIGINTERN hkvVec3 VisObject3D_cl_GetMotionDeltaWorldSpace(VisObject3D_cl const *self){
    return hkvVec3(self->GetMotionDeltaWorldSpace());
  }
SWIGINTERN hkvVec3 VisObject3D_cl_GetMotionDeltaLocalSpace(VisObject3D_cl const *self){
    return hkvVec3(self->GetMotionDeltaLocalSpace());
  }
SWIGINTERN bool VisObject3D_cl_HasRotationDelta(VisObject3D_cl const *self){
    return self->HasRotationDelta()==TRUE;
  }
SWIGINTERN hkvVec3 VisObject3D_cl_GetRotationDelta(VisObject3D_cl const *self){
    return hkvVec3(self->GetRotationDelta());
  }

  SWIGINTERN int VisObject3D_cl_GetParent(lua_State *L)
  {

    SWIG_CONVERT_POINTER(L, 1, VisObject3D_cl, pSelf)

    lua_settop(L, 0);
    LUA_PushObjectProxy(L, pSelf->GetParent()); //will handle NULL as well

    return 1;
  }


  SWIGINTERN int VisObject3D_cl_GetChild(lua_State *L)
  {
    SWIG_CONVERT_POINTER(L, 1, VisObject3D_cl, pSelf)
    
    if(lua_isnumber(L, 2))  
    {
      int iIndex = (int)lua_tonumber(L, 2);
      
      const int iCount = pSelf->GetNumChildren();
      
      if(iIndex<iCount)
      {
        LUA_PushObjectProxy(L, (VisObject3D_cl *)pSelf->GetChild(iIndex)); //will handle NULL as well
        return 1;
      }
    }
    else if(lua_isstring(L, 2))
    {
      const char *  pszName = lua_tostring(L, 2);

      const int iCount = pSelf->GetNumChildren();
      for (int i=0;i<iCount;i++)
      {
        VisObject3D_cl *pChild = (VisObject3D_cl *)pSelf->GetChild(i);
        if (pChild && pChild->HasObjectKey(pszName))
        {
          LUA_PushObjectProxy(L, pChild);
          return 1;
        }
      }
    }
    
    //parameters invalid
    lua_pushnil(L);
  
    return 1;
  }


  SWIGINTERN int VisObject3D_cl_Concat(lua_State *L)
  {
    //this will move this function to the method table of the specified class
    
    bool ARGS_OK = true;
    
    const char *pszString = NULL;
    int iIndex = -1;
    
    //The concat operator allows "foo"..self and self.."bar" so that
    //we have to consider self as first and as second stack element.
    
    //handle string as first (top) element
    if(lua_isstring(L,iIndex))
    {
      pszString = lua_tostring(L,iIndex);
      iIndex--;
    }
    
    SWIG_CONVERT_POINTER(L, iIndex, VisObject3D_cl, self)
    iIndex--;
    
    //handle string as second element
    if(iIndex==-2)
    {
      pszString = lua_tostring(L,iIndex);
    }
        
    unsigned int uiLen = (unsigned int) strlen(pszString);
    char *pszBuffer = new char[uiLen+128];
   
    sprintf(pszBuffer, "[%1.2f,%1.2f,%1.2f]",self->GetPosition().x,self->GetPosition().y,self->GetPosition().z); //format as requested
    
    //the new buffer should have the size of the old string and the new format string
    VASSERT_MSG(128>(strlen(pszBuffer)+uiLen), "Please increase your temp buffer size!");
    
    //append or prepend old buffer buffer (depending on the position inside the lua stack)
    if(iIndex==-3) //append old string
    {
      memcpy(pszBuffer+strlen(pszBuffer),pszString,uiLen+1); //also copy the terminator at the end
    }
    else //prepend old string
    {
      memmove(pszBuffer+uiLen,pszBuffer, strlen(pszBuffer)+1); //also move the terminator at the end
      memcpy(pszBuffer,pszString,uiLen); //insert the old string
    }

    lua_pushstring(L, pszBuffer);
  
    V_SAFE_DELETE_ARRAY(pszBuffer);

    return 1;
  }


  SWIGINTERN int VisObject3D_cl_ToString(lua_State *L)
  {
    //this will move this function to the method table of the specified class
    
    SWIG_CONVERT_POINTER(L, -1, VisObject3D_cl, self)
    
    char pszBuffer[1024];
    
    sprintf(pszBuffer, "%s: '%s' [%1.2f,%1.2f,%1.2f]",self->GetClassTypeId()->m_lpszClassName,self->GetObjectKey(),self->GetPosition().x,self->GetPosition().y,self->GetPosition().z); //format as requested
      
    lua_pushstring(L, pszBuffer);
    
    return 1;
  }

SWIGINTERN bool IVObjectComponent_CanAttachToObject(IVObjectComponent *self,VisTypedEngineObject_cl *typedObject){
      VString sError;
      bool bPossible = self->CanAttachToObject(typedObject, sError) == TRUE;
      if(!bPossible) Vision::Error.Warning("%s", sError.AsChar());
      return bPossible;
    }

  SWIGINTERN int IVObjectComponent_GetOwner(lua_State *L)
  {

    SWIG_CONVERT_POINTER(L, 1, IVObjectComponent, pSelf)

    lua_settop(L, 0);
    LUA_PushObjectProxy(L, pSelf->GetOwner()); //will handle NULL as well
 
    return 1;
  }


  SWIGINTERN int IVObjectComponent_Concat(lua_State *L)
  {
    //this will move this function to the method table of the specified class
    
    bool ARGS_OK = true;
    
    const char *pszString = NULL;
    int iIndex = -1;
    
    //The concat operator allows "foo"..self and self.."bar" so that
    //we have to consider self as first and as second stack element.
    
    //handle string as first (top) element
    if(lua_isstring(L,iIndex))
    {
      pszString = lua_tostring(L,iIndex);
      iIndex--;
    }
    
    SWIG_CONVERT_POINTER(L, iIndex, IVObjectComponent, self)
    iIndex--;
    
    //handle string as second element
    if(iIndex==-2)
    {
      pszString = lua_tostring(L,iIndex);
    }
        
    unsigned int uiLen = (unsigned int) strlen(pszString);
    char *pszBuffer = new char[uiLen+128];
   
    sprintf(pszBuffer, "%s",self->GetComponentName()==NULL?self->GetClassTypeId()->m_lpszClassName:self->GetComponentName()); //format as requested
    
    //the new buffer should have the size of the old string and the new format string
    VASSERT_MSG(128>(strlen(pszBuffer)+uiLen), "Please increase your temp buffer size!");
    
    //append or prepend old buffer buffer (depending on the position inside the lua stack)
    if(iIndex==-3) //append old string
    {
      memcpy(pszBuffer+strlen(pszBuffer),pszString,uiLen+1); //also copy the terminator at the end
    }
    else //prepend old string
    {
      memmove(pszBuffer+uiLen,pszBuffer, strlen(pszBuffer)+1); //also move the terminator at the end
      memcpy(pszBuffer,pszString,uiLen); //insert the old string
    }

    lua_pushstring(L, pszBuffer);
  
    V_SAFE_DELETE_ARRAY(pszBuffer);

    return 1;
  }


  SWIGINTERN int IVObjectComponent_ToString(lua_State *L)
  {
    //this will move this function to the method table of the specified class
    
    SWIG_CONVERT_POINTER(L, -1, IVObjectComponent, self)
    
    char pszBuffer[1024];
    
    sprintf(pszBuffer, "%s: %s",self->GetClassTypeId()->m_lpszClassName,self->GetComponentName()); //format as requested
      
    lua_pushstring(L, pszBuffer);
    
    return 1;
  }

SWIGINTERN bool VisBaseEntity_cl_SetMesh__SWIG_0(VisBaseEntity_cl *self,char const *szMeshFile){
      return self->SetMesh(szMeshFile) == TRUE;
    }
SWIGINTERN bool VisBaseEntity_cl_SetMesh__SWIG_1(VisBaseEntity_cl *self,VDynamicMesh *pMesh){
      self->SetMesh(pMesh);
      return true; //unify the return signature
    }
SWIGINTERN void VisBaseEntity_cl_SetThinkFunctionStatus(VisBaseEntity_cl *self,bool bEnable){
      for(int i=0; i<self->Components().Count();i++)
      {
        if( self->Components().GetPtrs()[i]->IsOfType(VScriptComponent::GetClassTypeId()) )
        {
          ((VScriptComponent *)(self->Components().GetPtrs()[i]))->SetThinkFunctionStatus(bEnable);
        }
      }
      self->SetThinkFunctionStatus(bEnable?TRUE:FALSE);
    }
SWIGINTERN bool VisBaseEntity_cl_GetThinkFunctionStatus(VisBaseEntity_cl const *self){
    return self->GetThinkFunctionStatus()==TRUE;
  }
SWIGINTERN bool VisBaseEntity_cl_HasMesh(VisBaseEntity_cl const *self){
    return self->HasMesh()==TRUE;
  }
SWIGINTERN void VisBaseEntity_cl_SetCastShadows(VisBaseEntity_cl *self,bool bValue){
    self->SetCastShadows(bValue);
  }
SWIGINTERN bool VisBaseEntity_cl_GetCastShadows(VisBaseEntity_cl const *self){
    return self->GetCastShadows()==TRUE;
  }
SWIGINTERN bool VisBaseEntity_cl_SetScaling__SWIG_0(VisBaseEntity_cl *self,float fScaling){
      return self->SetScaling(fScaling)==TRUE;
    }
SWIGINTERN bool VisBaseEntity_cl_SetScaling__SWIG_1(VisBaseEntity_cl *self,float x,float y,float z){
      return self->SetScaling(hkvVec3(x,y,z))==TRUE;
    }
SWIGINTERN bool VisBaseEntity_cl_SetScaling__SWIG_2(VisBaseEntity_cl *self,hkvVec3 const *pScale){
      if(pScale) return self->SetScaling(*pScale)==TRUE;
      return false;
    }
SWIGINTERN hkvVec3 VisBaseEntity_cl_GetScaling(VisBaseEntity_cl const *self){
    return hkvVec3(self->GetScaling());
  }
SWIGINTERN hkvAlignedBBox VisBaseEntity_cl_GetCustomTraceBBox(VisBaseEntity_cl *self){
      return *(self->GetCustomTraceBBox()); //return by value
    }
SWIGINTERN void VisBaseEntity_cl_SetTraceAccuracy(VisBaseEntity_cl *self,int iTraceAccuracy){
      self->SetTraceAccuracy((VisTraceAccuracy_e) iTraceAccuracy);
    }
SWIGINTERN bool VisBaseEntity_cl_WasVisibleInLastFrame(VisBaseEntity_cl const *self){
      return self->WasVisibleLastFrame(NULL) == TRUE;
    }
SWIGINTERN bool VisBaseEntity_cl_WasVisibleInAnyLastFrame(VisBaseEntity_cl const *self){
      return self->WasVisibleInAnyLastFrame() == TRUE;
    }
SWIGINTERN hkvAlignedBBox VisBaseEntity_cl_GetBoundingBox(VisBaseEntity_cl *self){
      hkvAlignedBBox newBox;
      self->GetCurrentVisBoundingBox(newBox);
      return newBox; //return by value
    }
SWIGINTERN hkvAlignedBBox VisBaseEntity_cl_GetCollisionBoundingBox(VisBaseEntity_cl *self){
      hkvAlignedBBox newBox;
      self->GetCollisionBoundingBox(newBox);
      return newBox; //return by value
    }
SWIGINTERN void VisBaseEntity_cl_SetVisible(VisBaseEntity_cl *self,bool bVisible){
      self->SetVisibleBitmask(bVisible ? VIS_ENTITY_VISIBLE : VIS_ENTITY_INVISIBLE);
    }
SWIGINTERN bool VisBaseEntity_cl_IsVisible(VisBaseEntity_cl *self){
      return (self->GetVisibleBitmask() & VIS_ENTITY_VISIBLE) != FALSE;
    }
SWIGINTERN void VisBaseEntity_cl_SetVisibleBitmask(VisBaseEntity_cl *self,VBitmask *pBitmask){
    if(pBitmask) self->SetVisibleBitmask(pBitmask->Get());
  }
SWIGINTERN VBitmask VisBaseEntity_cl_GetVisibleBitmask(VisBaseEntity_cl const *self){
    return VBitmask(self->GetVisibleBitmask());
  }
SWIGINTERN void VisBaseEntity_cl_SetLightInfluenceBitmask(VisBaseEntity_cl *self,VBitmask *pBitmask){
    if(pBitmask) self->SetLightInfluenceBitMask(pBitmask->Get());
  }
SWIGINTERN VBitmask VisBaseEntity_cl_GetLightInfluenceBitmask(VisBaseEntity_cl const *self){
    return VBitmask(self->GetLightInfluenceBitMask());
  }
SWIGINTERN bool VisBaseEntity_cl_SetTechnique__SWIG_0(VisBaseEntity_cl *self,VisSurface_cl *pSurface,char const *szShaderLib,char const *szTechnique,char const *szParamString=""){
      if(!self->HasMesh()) return false;
      return VScriptRenderer_wrapper::SetTechniqueForSurface(self, NULL, pSurface, szShaderLib, szTechnique, szParamString, true);
    }
SWIGINTERN bool VisBaseEntity_cl_SetTechnique__SWIG_2(VisBaseEntity_cl *self,int iSurfaceIndex,char const *szShaderLib,char const *szTechnique,char const *szParamString=""){
      if(!self->HasMesh()) return false;
      if(iSurfaceIndex>=self->GetMesh()->GetSurfaceCount() || iSurfaceIndex<0) return false;
      
      VisSurface_cl *pSurface = self->GetMesh()->GetSurface(iSurfaceIndex);
      return VScriptRenderer_wrapper::SetTechniqueForSurface(self, NULL, pSurface, szShaderLib, szTechnique, szParamString, true);
    }
SWIGINTERN bool VisBaseEntity_cl_SetTechnique__SWIG_4(VisBaseEntity_cl *self,char const *szSurfaceName,char const *szShaderLib,char const *szTechnique,char const *szParamString=""){
      if(!self->HasMesh()) return false;
      VisSurface_cl *pSurface = self->GetMesh()->GetSurfaceByName(szSurfaceName);
      return VScriptRenderer_wrapper::SetTechniqueForSurface(self, NULL, pSurface, szShaderLib, szTechnique, szParamString, true);
    }
SWIGINTERN bool VisBaseEntity_cl_AddTechnique__SWIG_0(VisBaseEntity_cl *self,VisSurface_cl *pSurface,char const *szShaderLib,char const *szTechnique,char const *szParamString=""){
      if(!self->HasMesh()) return false;
      return VScriptRenderer_wrapper::SetTechniqueForSurface(self, NULL, pSurface, szShaderLib, szTechnique, szParamString, false);
    }
SWIGINTERN bool VisBaseEntity_cl_AddTechnique__SWIG_2(VisBaseEntity_cl *self,int iSurfaceIndex,char const *szShaderLib,char const *szTechnique,char const *szParamString=""){
      if(!self->HasMesh()) return false;
      if(iSurfaceIndex>=self->GetMesh()->GetSurfaceCount() || iSurfaceIndex<0) return false;
      
      VisSurface_cl *pSurface = self->GetMesh()->GetSurface(iSurfaceIndex);
      return VScriptRenderer_wrapper::SetTechniqueForSurface(self, NULL, pSurface, szShaderLib, szTechnique, szParamString, false);
    }
SWIGINTERN bool VisBaseEntity_cl_AddTechnique__SWIG_4(VisBaseEntity_cl *self,char const *szSurfaceName,char const *szShaderLib,char const *szTechnique,char const *szParamString=""){
      if(!self->HasMesh()) return false;
      VisSurface_cl *pSurface = self->GetMesh()->GetSurfaceByName(szSurfaceName);
      return VScriptRenderer_wrapper::SetTechniqueForSurface(self, NULL, pSurface, szShaderLib, szTechnique, szParamString, false);
    }
SWIGINTERN bool VisBaseEntity_cl_SetEffect__SWIG_0(VisBaseEntity_cl *self,VisSurface_cl *pSurface,char const *szShaderLib,char const *szEffect,char const *szParamString=""){
      if(!self->HasMesh()) return false;
      return VScriptRenderer_wrapper::SetEffectForSurface(self, NULL, pSurface, szShaderLib, szEffect, szParamString, true);
    }
SWIGINTERN bool VisBaseEntity_cl_SetEffect__SWIG_2(VisBaseEntity_cl *self,int iSurfaceIndex,char const *szShaderLib,char const *szEffect,char const *szParamString=""){
      if(!self->HasMesh()) return false;
      if(iSurfaceIndex>=self->GetMesh()->GetSurfaceCount() || iSurfaceIndex<0) return false;
      
      VisSurface_cl *pSurface = self->GetMesh()->GetSurface(iSurfaceIndex);
      return VScriptRenderer_wrapper::SetEffectForSurface(self, NULL, pSurface, szShaderLib, szEffect, szParamString, true);
    }
SWIGINTERN bool VisBaseEntity_cl_SetEffect__SWIG_4(VisBaseEntity_cl *self,char const *szSurfaceName,char const *szShaderLib,char const *szEffect,char const *szParamString=""){
      if(!self->HasMesh()) return false;
      VisSurface_cl *pSurface = self->GetMesh()->GetSurfaceByName(szSurfaceName);
      return VScriptRenderer_wrapper::SetEffectForSurface(self, NULL, pSurface, szShaderLib, szEffect, szParamString, true);
    }
SWIGINTERN bool VisBaseEntity_cl_AddEffect__SWIG_0(VisBaseEntity_cl *self,VisSurface_cl *pSurface,char const *szShaderLib,char const *szEffect,char const *szParamString=""){
      if(!self->HasMesh()) return false;
      return VScriptRenderer_wrapper::SetEffectForSurface(self, NULL, pSurface, szShaderLib, szEffect, szParamString, false);
    }
SWIGINTERN bool VisBaseEntity_cl_AddEffect__SWIG_2(VisBaseEntity_cl *self,int iSurfaceIndex,char const *szShaderLib,char const *szEffect,char const *szParamString=""){
      if(!self->HasMesh()) return false;
      if(iSurfaceIndex>=self->GetMesh()->GetSurfaceCount() || iSurfaceIndex<0) return false;
      
      VisSurface_cl *pSurface = self->GetMesh()->GetSurface(iSurfaceIndex);
      return VScriptRenderer_wrapper::SetEffectForSurface(self, NULL, pSurface, szShaderLib, szEffect, szParamString, false);
    }
SWIGINTERN bool VisBaseEntity_cl_AddEffect__SWIG_4(VisBaseEntity_cl *self,char const *szSurfaceName,char const *szShaderLib,char const *szEffect,char const *szParamString=""){
      if(!self->HasMesh()) return false;
      VisSurface_cl *pSurface = self->GetMesh()->GetSurfaceByName(szSurfaceName);
      return VScriptRenderer_wrapper::SetEffectForSurface(self, NULL, pSurface, szShaderLib, szEffect, szParamString, false);
    }
SWIGINTERN bool VisBaseEntity_cl_SetTextureForSurface__SWIG_0(VisBaseEntity_cl *self,VTextureObject *pTexture,VisSurface_cl *pSurface,int iTextureType=0){
      return VScriptRenderer_wrapper::SetTextureForSurface(self, pTexture, pSurface, NULL, -1, iTextureType);
    }
SWIGINTERN bool VisBaseEntity_cl_SetTextureForSurface__SWIG_2(VisBaseEntity_cl *self,VTextureObject *pTexture,char const *szSurfaceName,int iTextureType=0){
      return VScriptRenderer_wrapper::SetTextureForSurface(self, pTexture, NULL, szSurfaceName, -1, iTextureType);
    }
SWIGINTERN bool VisBaseEntity_cl_SetTextureForSurface__SWIG_4(VisBaseEntity_cl *self,VTextureObject *pTexture,int iSurfaceIndex,int iTextureType=0){
      return VScriptRenderer_wrapper::SetTextureForSurface(self, pTexture, NULL, NULL, iSurfaceIndex, iTextureType);
    }
SWIGINTERN bool VisBaseEntity_cl_SetTextureForSurface__SWIG_6(VisBaseEntity_cl *self,char const *szTextureFile,VisSurface_cl *pSurface,int iTextureType=0){
      VTextureObject *pTexture = Vision::TextureManager.Load2DTexture(szTextureFile);
      return VScriptRenderer_wrapper::SetTextureForSurface(self, pTexture, pSurface, NULL, -1, iTextureType);
    }
SWIGINTERN bool VisBaseEntity_cl_SetTextureForSurface__SWIG_8(VisBaseEntity_cl *self,char const *szTextureFile,char const *szSurfaceName,int iTextureType=0){
      VTextureObject *pTexture = Vision::TextureManager.Load2DTexture(szTextureFile);
      return VScriptRenderer_wrapper::SetTextureForSurface(self, pTexture, NULL, szSurfaceName, -1, iTextureType);
    }
SWIGINTERN bool VisBaseEntity_cl_SetTextureForSurface__SWIG_10(VisBaseEntity_cl *self,char const *szTextureFile,int iSurfaceIndex,int iTextureType=0){
      VTextureObject *pTexture = Vision::TextureManager.Load2DTexture(szTextureFile);
      return VScriptRenderer_wrapper::SetTextureForSurface(self, pTexture, NULL, NULL, iSurfaceIndex, iTextureType);
    }
SWIGINTERN void VisBaseEntity_cl_ClearShaderSet(VisBaseEntity_cl *self){
      self->SetShaderSet(NULL);
    }
SWIGINTERN void VisBaseEntity_cl_SetPrimarySortingKey(VisBaseEntity_cl *self,int iKey){
      self->SetPrimarySortingKey((signed char)iKey);
    }
SWIGINTERN int VisBaseEntity_cl_GetPrimarySortingKey(VisBaseEntity_cl *self){
      return self->GetPrimarySortingKey();
    }

  SWIGINTERN int VisBaseEntity_cl_Concat(lua_State *L)
  {
    //this will move this function to the method table of the specified class
    
    bool ARGS_OK = true;
    
    const char *pszString = NULL;
    int iIndex = -1;
    
    //The concat operator allows "foo"..self and self.."bar" so that
    //we have to consider self as first and as second stack element.
    
    //handle string as first (top) element
    if(lua_isstring(L,iIndex))
    {
      pszString = lua_tostring(L,iIndex);
      iIndex--;
    }
    
    SWIG_CONVERT_POINTER(L, iIndex, VisBaseEntity_cl, self)
    iIndex--;
    
    //handle string as second element
    if(iIndex==-2)
    {
      pszString = lua_tostring(L,iIndex);
    }
        
    unsigned int uiLen = (unsigned int) strlen(pszString);
    char *pszBuffer = new char[uiLen+128];
   
    sprintf(pszBuffer, "[%s/%s/%s : %1.2f,%1.2f,%1.2f]",(self->GetVisibleBitmask() & VIS_ENTITY_VISIBLE)!=FALSE?"V":"-",self->GetMesh()?"M":"-",self->GetThinkFunctionStatus()?"T":"-",self->GetPosition().x,self->GetPosition().y,self->GetPosition().z); //format as requested
    
    //the new buffer should have the size of the old string and the new format string
    VASSERT_MSG(128>(strlen(pszBuffer)+uiLen), "Please increase your temp buffer size!");
    
    //append or prepend old buffer buffer (depending on the position inside the lua stack)
    if(iIndex==-3) //append old string
    {
      memcpy(pszBuffer+strlen(pszBuffer),pszString,uiLen+1); //also copy the terminator at the end
    }
    else //prepend old string
    {
      memmove(pszBuffer+uiLen,pszBuffer, strlen(pszBuffer)+1); //also move the terminator at the end
      memcpy(pszBuffer,pszString,uiLen); //insert the old string
    }

    lua_pushstring(L, pszBuffer);
  
    V_SAFE_DELETE_ARRAY(pszBuffer);

    return 1;
  }


  SWIGINTERN int VisBaseEntity_cl_ToString(lua_State *L)
  {
    //this will move this function to the method table of the specified class
    
    SWIG_CONVERT_POINTER(L, -1, VisBaseEntity_cl, self)
    
    char pszBuffer[1024];
    
    hkvVec3 vPos = self->GetPosition();
    
    sprintf(pszBuffer, "%s: '%s' [%s/%s/%s : %1.2f,%1.2f,%1.2f]",self->GetClassTypeId()->m_lpszClassName,self->GetObjectKey(),(self->GetVisibleBitmask() & VIS_ENTITY_VISIBLE)!=FALSE?"V":"-",self->GetMesh()?"M":"-",self->GetThinkFunctionStatus()?"T":"-",vPos.x,vPos.y,vPos.z); //format as requested
      
    lua_pushstring(L, pszBuffer);
    
    return 1;
  }

SWIGINTERN void VisParticleEffect_cl_SetVisibleBitmask(VisParticleEffect_cl *self,VBitmask *pBitmask){
    if(pBitmask) self->SetVisibleBitmask(pBitmask->Get());
  }
SWIGINTERN char const *VisParticleEffect_cl_GetName(VisParticleEffect_cl *self){
      return self->GetSourceEffect()->GetFilename();
    }
SWIGINTERN void VisParticleEffect_cl_IncPosition__SWIG_0(VisParticleEffect_cl *self,float x,float y,float z,bool bMoveParticles=false){
      self->IncPosition(hkvVec3(x,y,z), bMoveParticles);
    }
SWIGINTERN void VisParticleEffect_cl_ContinueSimulationWhenInvisible(VisParticleEffect_cl *self,bool bContinue){
        self->SetHandleWhenVisible(!bContinue); //this is a very confusing method name
    }
SWIGINTERN hkvAlignedBBox VisParticleEffect_cl_GetLocalBoundingBox(VisParticleEffect_cl *self){
      hkvAlignedBBox box;
      self->GetLocalBoundingBox(box);
      return box;
    }

  SWIGINTERN int VisParticleEffect_cl_Concat(lua_State *L)
  {
    //this will move this function to the method table of the specified class
    
    bool ARGS_OK = true;
    
    const char *pszString = NULL;
    int iIndex = -1;
    
    //The concat operator allows "foo"..self and self.."bar" so that
    //we have to consider self as first and as second stack element.
    
    //handle string as first (top) element
    if(lua_isstring(L,iIndex))
    {
      pszString = lua_tostring(L,iIndex);
      iIndex--;
    }
    
    SWIG_CONVERT_POINTER(L, iIndex, VisParticleEffect_cl, self)
    iIndex--;
    
    //handle string as second element
    if(iIndex==-2)
    {
      pszString = lua_tostring(L,iIndex);
    }
        
    unsigned int uiLen = (unsigned int) strlen(pszString);
    char *pszBuffer = new char[uiLen+128];
   
    sprintf(pszBuffer, "[%s/%s/%s : %1.2f,%1.2f,%1.2f]",self->IsVisible()?"V":"-",self->IsPaused()?"P":"-",self->IsHalted()?"H":"-",self->GetPosition().x,self->GetPosition().y,self->GetPosition().z); //format as requested
    
    //the new buffer should have the size of the old string and the new format string
    VASSERT_MSG(128>(strlen(pszBuffer)+uiLen), "Please increase your temp buffer size!");
    
    //append or prepend old buffer buffer (depending on the position inside the lua stack)
    if(iIndex==-3) //append old string
    {
      memcpy(pszBuffer+strlen(pszBuffer),pszString,uiLen+1); //also copy the terminator at the end
    }
    else //prepend old string
    {
      memmove(pszBuffer+uiLen,pszBuffer, strlen(pszBuffer)+1); //also move the terminator at the end
      memcpy(pszBuffer,pszString,uiLen); //insert the old string
    }

    lua_pushstring(L, pszBuffer);
  
    V_SAFE_DELETE_ARRAY(pszBuffer);

    return 1;
  }


  SWIGINTERN int VisParticleEffect_cl_ToString(lua_State *L)
  {
    //this will move this function to the method table of the specified class
    
    SWIG_CONVERT_POINTER(L, -1, VisParticleEffect_cl, self)
    
    char pszBuffer[1024];
    
    hkvVec3 vPos = self->GetPosition();
    
    sprintf(pszBuffer, "VisParticleEffect_cl '%s' [%s/%s/%s : %1.2f,%1.2f,%1.2f]",self->GetObjectKey()==NULL?self->GetSourceEffect()->GetFilename():self->GetObjectKey(),self->IsVisible()?"V":"-",self->IsPaused()?"P":"-",self->IsHalted()?"H":"-",vPos.x,vPos.y,vPos.z); //format as requested
      
    lua_pushstring(L, pszBuffer);
    
    return 1;
  }

SWIGINTERN hkvAlignedBBox VDynamicMesh_GetBoundingBox(VDynamicMesh const *self){
    return hkvAlignedBBox(self->GetBoundingBox());
  }
SWIGINTERN bool VDynamicMesh_ReloadShaderAssignment(VDynamicMesh *self,char const *szFilename){
      return self->ReloadShaderAssignmentFile(szFilename)==TRUE;
    }
SWIGINTERN bool VDynamicMesh_SetTechnique__SWIG_0(VDynamicMesh *self,VisSurface_cl *pSurface,char const *szShaderLib,char const *szTechnique,char const *szParamString=""){
      return VScriptRenderer_wrapper::SetTechniqueForSurface(NULL, self, pSurface, szShaderLib, szTechnique, szParamString, true);
    }
SWIGINTERN bool VDynamicMesh_SetTechnique__SWIG_2(VDynamicMesh *self,int iSurfaceIndex,char const *szShaderLib,char const *szTechnique,char const *szParamString=""){
      if(iSurfaceIndex>=self->GetSurfaceCount() || iSurfaceIndex<0) return false;
      
      VisSurface_cl *pSurface = self->GetSurface(iSurfaceIndex);
      return VScriptRenderer_wrapper::SetTechniqueForSurface(NULL, self, pSurface, szShaderLib, szTechnique, szParamString, true);
    }
SWIGINTERN bool VDynamicMesh_SetTechnique__SWIG_4(VDynamicMesh *self,char const *szSurfaceName,char const *szShaderLib,char const *szTechnique,char const *szParamString=""){
      VisSurface_cl *pSurface = self->GetSurfaceByName(szSurfaceName);
      return VScriptRenderer_wrapper::SetTechniqueForSurface(NULL, self, pSurface, szShaderLib, szTechnique, szParamString, true);
    }
SWIGINTERN bool VDynamicMesh_AddTechnique__SWIG_0(VDynamicMesh *self,VisSurface_cl *pSurface,char const *szShaderLib,char const *szTechnique,char const *szParamString=""){
      return VScriptRenderer_wrapper::SetTechniqueForSurface(NULL, self, pSurface, szShaderLib, szTechnique, szParamString, false);
    }
SWIGINTERN bool VDynamicMesh_AddTechnique__SWIG_2(VDynamicMesh *self,int iSurfaceIndex,char const *szShaderLib,char const *szTechnique,char const *szParamString=""){
      if(iSurfaceIndex>=self->GetSurfaceCount() || iSurfaceIndex<0) return false;
      
      VisSurface_cl *pSurface = self->GetSurface(iSurfaceIndex);
      return VScriptRenderer_wrapper::SetTechniqueForSurface(NULL, self, pSurface, szShaderLib, szTechnique, szParamString, false);
    }
SWIGINTERN bool VDynamicMesh_AddTechnique__SWIG_4(VDynamicMesh *self,char const *szSurfaceName,char const *szShaderLib,char const *szTechnique,char const *szParamString=""){
      VisSurface_cl *pSurface = self->GetSurfaceByName(szSurfaceName);
      return VScriptRenderer_wrapper::SetTechniqueForSurface(NULL, self, pSurface, szShaderLib, szTechnique, szParamString, false);
    }
SWIGINTERN bool VDynamicMesh_SetEffect__SWIG_0(VDynamicMesh *self,VisSurface_cl *pSurface,char const *szShaderLib,char const *szEffect,char const *szParamString=""){
      return VScriptRenderer_wrapper::SetEffectForSurface(NULL, self, pSurface, szShaderLib, szEffect, szParamString, true);
    }
SWIGINTERN bool VDynamicMesh_SetEffect__SWIG_2(VDynamicMesh *self,int iSurfaceIndex,char const *szShaderLib,char const *szEffect,char const *szParamString=""){
      if(iSurfaceIndex>=self->GetSurfaceCount() || iSurfaceIndex<0) return false;
      
      VisSurface_cl *pSurface = self->GetSurface(iSurfaceIndex);
      return VScriptRenderer_wrapper::SetEffectForSurface(NULL, self, pSurface, szShaderLib, szEffect, szParamString, true);
    }
SWIGINTERN bool VDynamicMesh_SetEffect__SWIG_4(VDynamicMesh *self,char const *szSurfaceName,char const *szShaderLib,char const *szEffect,char const *szParamString=""){
      VisSurface_cl *pSurface = self->GetSurfaceByName(szSurfaceName);
      return VScriptRenderer_wrapper::SetEffectForSurface(NULL, self, pSurface, szShaderLib, szEffect, szParamString, true);
    }
SWIGINTERN bool VDynamicMesh_AddEffect__SWIG_0(VDynamicMesh *self,VisSurface_cl *pSurface,char const *szShaderLib,char const *szEffect,char const *szParamString=""){
      return VScriptRenderer_wrapper::SetEffectForSurface(NULL, self, pSurface, szShaderLib, szEffect, szParamString, false);
    }
SWIGINTERN bool VDynamicMesh_AddEffect__SWIG_2(VDynamicMesh *self,int iSurfaceIndex,char const *szShaderLib,char const *szEffect,char const *szParamString=""){
      if(iSurfaceIndex>=self->GetSurfaceCount() || iSurfaceIndex<0) return false;
      
      VisSurface_cl *pSurface = self->GetSurface(iSurfaceIndex);
      return VScriptRenderer_wrapper::SetEffectForSurface(NULL, self, pSurface, szShaderLib, szEffect, szParamString, false);
    }
SWIGINTERN bool VDynamicMesh_AddEffect__SWIG_4(VDynamicMesh *self,char const *szSurfaceName,char const *szShaderLib,char const *szEffect,char const *szParamString=""){
      VisSurface_cl *pSurface = self->GetSurfaceByName(szSurfaceName);
      return VScriptRenderer_wrapper::SetEffectForSurface(NULL, self, pSurface, szShaderLib, szEffect, szParamString, false);
    }
SWIGINTERN bool VDynamicMesh_operator_Se__Se_(VDynamicMesh *self,VDynamicMesh const &other){
      return self==&other;
    }

  SWIGINTERN int VDynamicMesh_GetAllSurfaces(lua_State *L)
  {
      
    SWIG_CONVERT_POINTER(L, 1, VDynamicMesh, pMesh)

    lua_newtable(L);                                        //stack: ..., table
    
    int iCount = pMesh->GetSurfaceCount();
    VisSurface_cl** ppSurfaces = pMesh->GetSurfaceArray();

    for(int i=0;i<iCount;++i)
    {
      VSWIG_PUSH_PROXY(L, VisSurface_cl, ppSurfaces[i]);    //stack: ..., table, surface
      lua_rawseti(L, -2, i+1);                         //stack: ..., table
    } 
    
    return 1; //return the table as stack param
  }


  SWIGINTERN int VDynamicMesh_Concat(lua_State *L)
  {
    //this will move this function to the method table of the specified class
    
    bool ARGS_OK = true;
    
    const char *pszString = NULL;
    int iIndex = -1;
    
    //The concat operator allows "foo"..self and self.."bar" so that
    //we have to consider self as first and as second stack element.
    
    //handle string as first (top) element
    if(lua_isstring(L,iIndex))
    {
      pszString = lua_tostring(L,iIndex);
      iIndex--;
    }
    
    SWIG_CONVERT_POINTER(L, iIndex, VDynamicMesh, self)
    iIndex--;
    
    //handle string as second element
    if(iIndex==-2)
    {
      pszString = lua_tostring(L,iIndex);
    }
        
    unsigned int uiLen = (unsigned int) strlen(pszString);
    char *pszBuffer = new char[uiLen+128];
   
    sprintf(pszBuffer, "[%s]",self->GetFilename()); //format as requested
    
    //the new buffer should have the size of the old string and the new format string
    VASSERT_MSG(128>(strlen(pszBuffer)+uiLen), "Please increase your temp buffer size!");
    
    //append or prepend old buffer buffer (depending on the position inside the lua stack)
    if(iIndex==-3) //append old string
    {
      memcpy(pszBuffer+strlen(pszBuffer),pszString,uiLen+1); //also copy the terminator at the end
    }
    else //prepend old string
    {
      memmove(pszBuffer+uiLen,pszBuffer, strlen(pszBuffer)+1); //also move the terminator at the end
      memcpy(pszBuffer,pszString,uiLen); //insert the old string
    }

    lua_pushstring(L, pszBuffer);
  
    V_SAFE_DELETE_ARRAY(pszBuffer);

    return 1;
  }


  SWIGINTERN int VDynamicMesh_ToString(lua_State *L)
  {
    //this will move this function to the method table of the specified class
    
    SWIG_CONVERT_POINTER(L, -1, VDynamicMesh, self)
    
    char pszBuffer[1024];
    
    sprintf(pszBuffer, "VDynamicMesh: '%s' (%d surfaces, %d sub meshes)",self->GetFilename(),self->GetSurfaceCount(),self->GetSubmeshCount()); //format as requested
      
    lua_pushstring(L, pszBuffer);
    
    return 1;
  }

SWIGINTERN void VisLightSource_cl_SetCoronaTexture(VisLightSource_cl *self,char const *textureFile){
      IVObjectComponent* pComponent = self->GetCoronaComponent();
      pComponent->SetVariable("CoronaTexture", textureFile);
    }
SWIGINTERN void VisLightSource_cl_SetupAppearance(VisLightSource_cl *self,bool bUseCorona,bool bUseLensFlares){
      IVObjectComponent* pComponent = self->GetCoronaComponent();
      pComponent->SetVariable("Enabled", bUseCorona == true ? "True" : "False");
      
      pComponent = self->GetLensFlareComponent();
      pComponent->SetVariable("Enabled", bUseLensFlares == true ? "True" : "False");
    }
SWIGINTERN bool VisLightSource_cl_GetTriggered(VisLightSource_cl const *self){
    return self->GetTriggered()==TRUE;
  }
SWIGINTERN int VisLightSource_cl_GetType(VisLightSource_cl const *self){
      return (int)self->GetType();
    }
SWIGINTERN void VisLightSource_cl_SetType(VisLightSource_cl *self,int iType){
      self->SetType((VisLightSourceType_e) iType);
    }
SWIGINTERN void VisLightSource_cl_SetCoronaScaleMode(VisLightSource_cl *self,int iScaleMode){
      IVObjectComponent* pComponent = self->GetCoronaComponent();

      pComponent->SetVariable("CoronaFixedSize", (iScaleMode & VIS_CORONASCALE_DISTANCE) > 0 ? "False" : "True");
      pComponent->SetVariable("CoronaScaleWithIntensity", (iScaleMode & VIS_CORONASCALE_VISIBLEAREA) > 0 ? "True" : "False");
      pComponent->SetVariable("CoronaGlobalFadeOut", (iScaleMode & VIS_CORONASCALE_USEFADEOUT) > 0 ? "True" : "False");
      pComponent->SetVariable("CoronaRotate", (iScaleMode & VIS_CORONASCALE_ROTATING) > 0 ? "True" : "False");
    }
SWIGINTERN int VisLightSource_cl_GetCoronaScaleMode(VisLightSource_cl *self){
      IVObjectComponent* pComponent = self->GetCoronaComponent();

      int iFlags = 0;
      char szText[256] = "";
      pComponent->GetVariableValue("CoronaFixedSize", szText);
      if (strcmp(szText, "False"))
      {
        iFlags |= VIS_CORONASCALE_DISTANCE;
      }
      pComponent->GetVariableValue("CoronaScaleWithIntensity", szText);
      if (strcmp(szText, "False"))
      {
        iFlags |= VIS_CORONASCALE_VISIBLEAREA;
      }
      pComponent->GetVariableValue("CoronaGlobalFadeOut", szText);
      if (strcmp(szText, "False"))
      {
        iFlags |= VIS_CORONASCALE_USEFADEOUT;
      }
      pComponent->GetVariableValue("CoronaRotate", szText);
      if (strcmp(szText, "False"))
      {
        iFlags |= VIS_CORONASCALE_ROTATING;
      }

      return iFlags;
    }
SWIGINTERN void VisLightSource_cl_SetCoronaScale(VisLightSource_cl *self,float fScale){
      IVObjectComponent* pComponent = self->GetCoronaComponent();

	  char szText[256];
	  sprintf(szText, "%f", fScale);
	  pComponent->SetVariable("CoronaScaling", szText);
    }
SWIGINTERN float VisLightSource_cl_GetCoronaScale(VisLightSource_cl *self){
      IVObjectComponent* pComponent = self->GetCoronaComponent();

      char szText[256] = "";
      pComponent->GetVariableValue("CoronaScaling", szText);

      float fValue = 1.0f;
      if (sscanf (szText, "%f", &fValue) == 1)
      {
        return fValue;
      }
      return 1.0f;
    }
SWIGINTERN bool VisLightSource_cl_WasVisibleInLastFrame(VisLightSource_cl const *self){
      return self->WasVisibleLastFrame(NULL) == TRUE;
    }
SWIGINTERN bool VisLightSource_cl_WasVisibleInAnyLastFrame(VisLightSource_cl const *self){
      return self->WasVisibleInAnyLastFrame() == TRUE;
    }
SWIGINTERN void VisLightSource_cl_SetVisible(VisLightSource_cl *self,bool bVisible){
      self->SetVisibleBitmask(bVisible ? VIS_ENTITY_VISIBLE : VIS_ENTITY_INVISIBLE);
    }
SWIGINTERN bool VisLightSource_cl_IsVisible(VisLightSource_cl *self){
      return (self->GetVisibleBitmask() & VIS_ENTITY_VISIBLE) != FALSE;
    }
SWIGINTERN void VisLightSource_cl_SetVisibleBitmask(VisLightSource_cl *self,VBitmask *pBitmask){
    if(pBitmask) self->SetVisibleBitmask(pBitmask->Get());
  }
SWIGINTERN VBitmask VisLightSource_cl_GetVisibleBitmask(VisLightSource_cl const *self){
    return VBitmask(self->GetVisibleBitmask());
  }
SWIGINTERN void VisLightSource_cl_SetLightInfluenceBitmasks(VisLightSource_cl *self,VBitmask *pWorldMask,VBitmask *pObjectMask){
      if(pWorldMask && pObjectMask)
        self->SetLightInfluenceBitMasks(pWorldMask->Get(), pObjectMask->Get());
    }
SWIGINTERN VBitmask VisLightSource_cl_GetLightInfluenceBitmask__SWIG_0(VisLightSource_cl *self,bool bWorld=true){
      if(bWorld)
        return VBitmask(self->GetLightInfluenceBitMaskWorld());
      else
        return VBitmask(self->GetLightInfluenceBitMaskEntity());
    }
SWIGINTERN hkvAlignedBBox VisLightSource_cl_GetBoundingBox(VisLightSource_cl *self){
      hkvAlignedBBox newBox;
      self->GetBoundingBox(newBox);
      return newBox; //return by value
    }
SWIGINTERN void VisLightSource_cl_SetColorCurve__SWIG_0(VisLightSource_cl *self,char const *pszTex=NULL,float fTiming=10.,float fPhase=0.){
      if (pszTex==NULL || pszTex[0]==0)
        self->DisableColorAnimations(); // disable anim
      else
        self->ColorAnimation().SetAnimCurve(pszTex, fTiming, fPhase); // enable anim
    }

  SWIGINTERN int VisLightSource_cl_Concat(lua_State *L)
  {
    //this will move this function to the method table of the specified class
    
    bool ARGS_OK = true;
    
    const char *pszString = NULL;
    int iIndex = -1;
    
    //The concat operator allows "foo"..self and self.."bar" so that
    //we have to consider self as first and as second stack element.
    
    //handle string as first (top) element
    if(lua_isstring(L,iIndex))
    {
      pszString = lua_tostring(L,iIndex);
      iIndex--;
    }
    
    SWIG_CONVERT_POINTER(L, iIndex, VisLightSource_cl, self)
    iIndex--;
    
    //handle string as second element
    if(iIndex==-2)
    {
      pszString = lua_tostring(L,iIndex);
    }
        
    unsigned int uiLen = (unsigned int) strlen(pszString);
    char *pszBuffer = new char[uiLen+128];
   
    sprintf(pszBuffer, "[%s %s I:%1.1f M:%1.2f : %1.2f,%1.2f,%1.2f]",self->GetType()==VIS_LIGHT_POINT?"PointL":(self->GetType()==VIS_LIGHT_DIRECTED?"DirectedL":"SpotL"),(self->GetVisibleBitmask() & VIS_ENTITY_VISIBLE)!=FALSE?"V":"-",self->GetIntensity(),self->GetMultiplier(),self->GetPosition().x,self->GetPosition().y,self->GetPosition().z); //format as requested
    
    //the new buffer should have the size of the old string and the new format string
    VASSERT_MSG(128>(strlen(pszBuffer)+uiLen), "Please increase your temp buffer size!");
    
    //append or prepend old buffer buffer (depending on the position inside the lua stack)
    if(iIndex==-3) //append old string
    {
      memcpy(pszBuffer+strlen(pszBuffer),pszString,uiLen+1); //also copy the terminator at the end
    }
    else //prepend old string
    {
      memmove(pszBuffer+uiLen,pszBuffer, strlen(pszBuffer)+1); //also move the terminator at the end
      memcpy(pszBuffer,pszString,uiLen); //insert the old string
    }

    lua_pushstring(L, pszBuffer);
  
    V_SAFE_DELETE_ARRAY(pszBuffer);

    return 1;
  }


  SWIGINTERN int VisLightSource_cl_ToString(lua_State *L)
  {
    //this will move this function to the method table of the specified class
    
    SWIG_CONVERT_POINTER(L, -1, VisLightSource_cl, self)
    
    char pszBuffer[1024];
    
    sprintf(pszBuffer, "%s: '%s' [%s %s I:%1.1f M:%1.2f : %1.2f,%1.2f,%1.2f]",self->GetClassTypeId()->m_lpszClassName,self->GetObjectKey(),self->GetType()==VIS_LIGHT_POINT?"PointLight":(self->GetType()==VIS_LIGHT_DIRECTED?"DirectedLight":"SpotLight"),(self->GetVisibleBitmask() & VIS_ENTITY_VISIBLE)!=FALSE?"V":"-",self->GetIntensity(),self->GetMultiplier(),self->GetPosition().x,self->GetPosition().y,self->GetPosition().z); //format as requested
      
    lua_pushstring(L, pszBuffer);
    
    return 1;
  }

SWIGINTERN hkvAlignedBBox VisStaticMeshInstance_cl_GetBoundingBox(VisStaticMeshInstance_cl const *self){
    return hkvAlignedBBox(self->GetBoundingBox());
  }
SWIGINTERN hkvVec3 VisStaticMeshInstance_cl_GetPosition(VisStaticMeshInstance_cl *self){
      return self->GetTransform().getTranslation(); //return by value
    }
SWIGINTERN hkvMat3 VisStaticMeshInstance_cl_GetRotation(VisStaticMeshInstance_cl *self){
      return self->GetTransform().getRotationalPart(); //return by value
    }
SWIGINTERN void VisStaticMeshInstance_cl_SetVisibleBitmask(VisStaticMeshInstance_cl *self,VBitmask *pBitmask){
    if(pBitmask) self->SetVisibleBitmask(pBitmask->Get());
  }
SWIGINTERN void VisStaticMeshInstance_cl_SetCollisionBitmask(VisStaticMeshInstance_cl *self,VBitmask *pBitmask){
    if(pBitmask) self->SetCollisionBitmask(pBitmask->Get());
  }
SWIGINTERN VBitmask VisStaticMeshInstance_cl_GetCollisionBitmask(VisStaticMeshInstance_cl const *self){
    return VBitmask(self->GetCollisionBitmask());
  }

  SWIGINTERN int VisStaticMeshInstance_cl_Concat(lua_State *L)
  {
    //this will move this function to the method table of the specified class
    
    bool ARGS_OK = true;
    
    const char *pszString = NULL;
    int iIndex = -1;
    
    //The concat operator allows "foo"..self and self.."bar" so that
    //we have to consider self as first and as second stack element.
    
    //handle string as first (top) element
    if(lua_isstring(L,iIndex))
    {
      pszString = lua_tostring(L,iIndex);
      iIndex--;
    }
    
    SWIG_CONVERT_POINTER(L, iIndex, VisStaticMeshInstance_cl, self)
    iIndex--;
    
    //handle string as second element
    if(iIndex==-2)
    {
      pszString = lua_tostring(L,iIndex);
    }
        
    unsigned int uiLen = (unsigned int) strlen(pszString);
    char *pszBuffer = new char[uiLen+128];
   
    sprintf(pszBuffer, "%s",self->GetObjectKey()==NULL?self->GetClassTypeId()->m_lpszClassName:self->GetObjectKey()); //format as requested
    
    //the new buffer should have the size of the old string and the new format string
    VASSERT_MSG(128>(strlen(pszBuffer)+uiLen), "Please increase your temp buffer size!");
    
    //append or prepend old buffer buffer (depending on the position inside the lua stack)
    if(iIndex==-3) //append old string
    {
      memcpy(pszBuffer+strlen(pszBuffer),pszString,uiLen+1); //also copy the terminator at the end
    }
    else //prepend old string
    {
      memmove(pszBuffer+uiLen,pszBuffer, strlen(pszBuffer)+1); //also move the terminator at the end
      memcpy(pszBuffer,pszString,uiLen); //insert the old string
    }

    lua_pushstring(L, pszBuffer);
  
    V_SAFE_DELETE_ARRAY(pszBuffer);

    return 1;
  }


  SWIGINTERN int VisStaticMeshInstance_cl_ToString(lua_State *L)
  {
    //this will move this function to the method table of the specified class
    
    SWIG_CONVERT_POINTER(L, -1, VisStaticMeshInstance_cl, self)
    
    char pszBuffer[1024];
    
    hkvVec3 vPos = self->GetTransform().getTranslation();
    
    sprintf(pszBuffer, "%s: %s [%1.2f,%1.2f,%1.2f]",self->GetClassTypeId()->m_lpszClassName,self->GetObjectKey(),vPos.x,vPos.y,vPos.z); //format as requested
      
    lua_pushstring(L, pszBuffer);
    
    return 1;
  }

SWIGINTERN void VisSurface_cl_SetAutoShaderMode(VisSurface_cl *self,bool bUseAutoMode){
      self->SetShaderMode(bUseAutoMode?VisSurface_cl::VSM_Auto:VisSurface_cl::VSM_Manual);
    }
SWIGINTERN bool VisSurface_cl_HasAutoShaderMode(VisSurface_cl *self){
      return self->GetShaderMode() == VisSurface_cl::VSM_Auto;
    }
SWIGINTERN bool VisSurface_cl_operator_Se__Se_(VisSurface_cl *self,VisSurface_cl const &other){
      return self==&other;
    }

  SWIGINTERN int VisSurface_cl_GetTextureLocations(lua_State *L)
  {
      
    SWIG_CONVERT_POINTER(L, 1, VisSurface_cl, pSurface)
    
    lua_pushstring(L, pSurface->GetBaseTexture());
    lua_pushstring(L, pSurface->GetNormalMapTexture());
    lua_pushstring(L, pSurface->GetSpecularMapTexture());
    
    return 3; //return 3 texture locations
  }


  SWIGINTERN int VisSurface_cl_Concat(lua_State *L)
  {
    //this will move this function to the method table of the specified class
    
    bool ARGS_OK = true;
    
    const char *pszString = NULL;
    int iIndex = -1;
    
    //The concat operator allows "foo"..self and self.."bar" so that
    //we have to consider self as first and as second stack element.
    
    //handle string as first (top) element
    if(lua_isstring(L,iIndex))
    {
      pszString = lua_tostring(L,iIndex);
      iIndex--;
    }
    
    SWIG_CONVERT_POINTER(L, iIndex, VisSurface_cl, self)
    iIndex--;
    
    //handle string as second element
    if(iIndex==-2)
    {
      pszString = lua_tostring(L,iIndex);
    }
        
    unsigned int uiLen = (unsigned int) strlen(pszString);
    char *pszBuffer = new char[uiLen+128];
   
    sprintf(pszBuffer, "[%s,%s]",self->GetName(),self->GetBaseTexture()); //format as requested
    
    //the new buffer should have the size of the old string and the new format string
    VASSERT_MSG(128>(strlen(pszBuffer)+uiLen), "Please increase your temp buffer size!");
    
    //append or prepend old buffer buffer (depending on the position inside the lua stack)
    if(iIndex==-3) //append old string
    {
      memcpy(pszBuffer+strlen(pszBuffer),pszString,uiLen+1); //also copy the terminator at the end
    }
    else //prepend old string
    {
      memmove(pszBuffer+uiLen,pszBuffer, strlen(pszBuffer)+1); //also move the terminator at the end
      memcpy(pszBuffer,pszString,uiLen); //insert the old string
    }

    lua_pushstring(L, pszBuffer);
  
    V_SAFE_DELETE_ARRAY(pszBuffer);

    return 1;
  }


  SWIGINTERN int VisSurface_cl_ToString(lua_State *L)
  {
    //this will move this function to the method table of the specified class
    
    SWIG_CONVERT_POINTER(L, -1, VisSurface_cl, self)
    
    char pszBuffer[1024];
    
    sprintf(pszBuffer, "VisSurface_cl: %d [%s,%s]",self->GetIndex(),self->GetName(),self->GetBaseTexture()); //format as requested
      
    lua_pushstring(L, pszBuffer);
    
    return 1;
  }

SWIGINTERN VisPathNode_cl *VisPath_cl_AddPathNode__SWIG_1(VisPath_cl *self,hkvVec3 const *pPos,char const *szKey=NULL){
        VisPathNode_cl * pNode = new VisPathNode_cl(*pPos);
        if(szKey) pNode->SetObjectKey(szKey);
        
        self->AddPathNode(pNode);
        return pNode;
     }
SWIGINTERN VisPathNode_cl *VisPath_cl_GetPathNode__SWIG_0(VisPath_cl *self,int iIndex){
        return self->GetPathNode(iIndex, TRUE);
     }
SWIGINTERN VisPathNode_cl *VisPath_cl_GetPathNode__SWIG_1(VisPath_cl *self,char const *szKey){
        return self->FindPathNode(szKey, TRUE);
     }
SWIGINTERN void VisPath_cl_SetClosed(VisPath_cl *self,bool bValue){
    self->SetClosed(bValue);
  }
SWIGINTERN bool VisPath_cl_IsClosed(VisPath_cl const *self){
    return self->IsClosed()==TRUE;
  }

  SWIGINTERN int VisPath_cl_Concat(lua_State *L)
  {
    //this will move this function to the method table of the specified class
    
    bool ARGS_OK = true;
    
    const char *pszString = NULL;
    int iIndex = -1;
    
    //The concat operator allows "foo"..self and self.."bar" so that
    //we have to consider self as first and as second stack element.
    
    //handle string as first (top) element
    if(lua_isstring(L,iIndex))
    {
      pszString = lua_tostring(L,iIndex);
      iIndex--;
    }
    
    SWIG_CONVERT_POINTER(L, iIndex, VisPath_cl, self)
    iIndex--;
    
    //handle string as second element
    if(iIndex==-2)
    {
      pszString = lua_tostring(L,iIndex);
    }
        
    unsigned int uiLen = (unsigned int) strlen(pszString);
    char *pszBuffer = new char[uiLen+128];
   
    sprintf(pszBuffer, "[%s : %1.2f,%1.2f,%1.2f]",self->IsClosed()?"C":"-",self->GetPosition().x,self->GetPosition().y,self->GetPosition().z); //format as requested
    
    //the new buffer should have the size of the old string and the new format string
    VASSERT_MSG(128>(strlen(pszBuffer)+uiLen), "Please increase your temp buffer size!");
    
    //append or prepend old buffer buffer (depending on the position inside the lua stack)
    if(iIndex==-3) //append old string
    {
      memcpy(pszBuffer+strlen(pszBuffer),pszString,uiLen+1); //also copy the terminator at the end
    }
    else //prepend old string
    {
      memmove(pszBuffer+uiLen,pszBuffer, strlen(pszBuffer)+1); //also move the terminator at the end
      memcpy(pszBuffer,pszString,uiLen); //insert the old string
    }

    lua_pushstring(L, pszBuffer);
  
    V_SAFE_DELETE_ARRAY(pszBuffer);

    return 1;
  }


  SWIGINTERN int VisPath_cl_ToString(lua_State *L)
  {
    //this will move this function to the method table of the specified class
    
    SWIG_CONVERT_POINTER(L, -1, VisPath_cl, self)
    
    char pszBuffer[1024];
    
    sprintf(pszBuffer, "VisPath_cl '%s' [%s : %1.2f,%1.2f,%1.2f]",self->GetObjectKey(),self->IsClosed()?"C":"-",self->GetPosition().x,self->GetPosition().y,self->GetPosition().z); //format as requested
      
    lua_pushstring(L, pszBuffer);
    
    return 1;
  }


  SWIGINTERN int VisPath_cl_Evaluate(lua_State *L)
  {
    
    DECLARE_ARGS_OK;
    
    SWIG_CONVERT_POINTER(L, 1, VisPath_cl, pPath)
    
    GET_ARG(2, float, fPositionInPath); // from 0 to 1

    GET_OPT_ARG(3, bool, bSmooth, false);
   
    // for safer floats
    VALIDATE_LUA_NUMBERS( (float*)&fPositionInPath, 1);

    hkvVec3 pos, ori;
    if (ARGS_OK)
    {
      hkvVec3 pos;
      hkvVec3 ori;
      if(bSmooth)
        pPath->EvalPointSmooth(fPositionInPath, pos, &ori);
      else
        pPath->EvalPoint(fPositionInPath, pos, &ori);
      
      SWIG_Lua_NewPointerObj(L,new hkvVec3(pos),SWIGTYPE_p_hkvVec3, VLUA_MANAGE_MEM_BY_LUA);
      SWIG_Lua_NewPointerObj(L,new hkvVec3(ori),SWIGTYPE_p_hkvVec3, VLUA_MANAGE_MEM_BY_LUA);
    }
    else
    {
      lua_pushnil(L);
      lua_pushnil(L);
    }
    return 2; 
  }

SWIGINTERN hkvVec3 VisPathNode_cl_GetPosition(VisPathNode_cl const *self){
    return hkvVec3(self->GetPosition());
  }
SWIGINTERN void VisPathNode_cl_SetInTypeBezier(VisPathNode_cl *self,bool bBezier){
      self->SetTypeIn(bBezier ? VisPathNode_cl::BEZIER : VisPathNode_cl::LINEAR);
    }
SWIGINTERN void VisPathNode_cl_SetOutTypeBezier(VisPathNode_cl *self,bool bBezier){
      self->SetTypeOut(bBezier ? VisPathNode_cl::BEZIER : VisPathNode_cl::LINEAR);
    }
SWIGINTERN void VisPathNode_cl_MakeInColinearToOut(VisPathNode_cl *self){
      self->MakeControlVerticesColinear(IN_VECTOR);
    }
SWIGINTERN void VisPathNode_cl_MakeOutColinearToIn(VisPathNode_cl *self){
      self->MakeControlVerticesColinear(OUT_VECTOR);
    }

  SWIGINTERN int VisPathNode_cl_Concat(lua_State *L)
  {
    //this will move this function to the method table of the specified class
    
    bool ARGS_OK = true;
    
    const char *pszString = NULL;
    int iIndex = -1;
    
    //The concat operator allows "foo"..self and self.."bar" so that
    //we have to consider self as first and as second stack element.
    
    //handle string as first (top) element
    if(lua_isstring(L,iIndex))
    {
      pszString = lua_tostring(L,iIndex);
      iIndex--;
    }
    
    SWIG_CONVERT_POINTER(L, iIndex, VisPathNode_cl, self)
    iIndex--;
    
    //handle string as second element
    if(iIndex==-2)
    {
      pszString = lua_tostring(L,iIndex);
    }
        
    unsigned int uiLen = (unsigned int) strlen(pszString);
    char *pszBuffer = new char[uiLen+128];
   
    sprintf(pszBuffer, "[%1.2f,%1.2f,%1.2f]",self->GetPosition().x,self->GetPosition().y,self->GetPosition().z); //format as requested
    
    //the new buffer should have the size of the old string and the new format string
    VASSERT_MSG(128>(strlen(pszBuffer)+uiLen), "Please increase your temp buffer size!");
    
    //append or prepend old buffer buffer (depending on the position inside the lua stack)
    if(iIndex==-3) //append old string
    {
      memcpy(pszBuffer+strlen(pszBuffer),pszString,uiLen+1); //also copy the terminator at the end
    }
    else //prepend old string
    {
      memmove(pszBuffer+uiLen,pszBuffer, strlen(pszBuffer)+1); //also move the terminator at the end
      memcpy(pszBuffer,pszString,uiLen); //insert the old string
    }

    lua_pushstring(L, pszBuffer);
  
    V_SAFE_DELETE_ARRAY(pszBuffer);

    return 1;
  }


  SWIGINTERN int VisPathNode_cl_ToString(lua_State *L)
  {
    //this will move this function to the method table of the specified class
    
    SWIG_CONVERT_POINTER(L, -1, VisPathNode_cl, self)
    
    char pszBuffer[1024];
    
    sprintf(pszBuffer, "VisPathNode_cl '%s' [%1.2f,%1.2f,%1.2f]",self->GetObjectKey(),self->GetPosition().x,self->GetPosition().y,self->GetPosition().z); //format as requested
      
    lua_pushstring(L, pszBuffer);
    
    return 1;
  }

SWIGINTERN char const *VTextureObject_GetType(VTextureObject *self){
      switch(self->GetTextureType())
      {
        case VTextureLoader::Texture2D: return "Texture2D";
        case VTextureLoader::Texture3D: return "Texture3D";
        case VTextureLoader::Cubemap: return "Cubemap";
        case VTextureLoader::Heightmap16bpp: return "Heightmap16bpp";
        case VTextureLoader::Texture2DArray: return "Texture2DArray";
        case VTextureLoader::CubemapArray: return "CubemapArray";
        default: return "Unknown";
      }
    }
SWIGINTERN bool VTextureObject_operator_Se__Se_(VTextureObject *self,VTextureObject const &other){
      return self==&other;
    }

  SWIGINTERN int VTextureObject_Concat(lua_State *L)
  {
    //this will move this function to the method table of the specified class
    
    bool ARGS_OK = true;
    
    const char *pszString = NULL;
    int iIndex = -1;
    
    //The concat operator allows "foo"..self and self.."bar" so that
    //we have to consider self as first and as second stack element.
    
    //handle string as first (top) element
    if(lua_isstring(L,iIndex))
    {
      pszString = lua_tostring(L,iIndex);
      iIndex--;
    }
    
    SWIG_CONVERT_POINTER(L, iIndex, VTextureObject, self)
    iIndex--;
    
    //handle string as second element
    if(iIndex==-2)
    {
      pszString = lua_tostring(L,iIndex);
    }
        
    unsigned int uiLen = (unsigned int) strlen(pszString);
    char *pszBuffer = new char[uiLen+256];
   
    sprintf(pszBuffer, "[%s]",self->GetFilename()); //format as requested
    
    //the new buffer should have the size of the old string and the new format string
    VASSERT_MSG(256>(strlen(pszBuffer)+uiLen), "Please increase your temp buffer size!");
    
    //append or prepend old buffer buffer (depending on the position inside the lua stack)
    if(iIndex==-3) //append old string
    {
      memcpy(pszBuffer+strlen(pszBuffer),pszString,uiLen+1); //also copy the terminator at the end
    }
    else //prepend old string
    {
      memmove(pszBuffer+uiLen,pszBuffer, strlen(pszBuffer)+1); //also move the terminator at the end
      memcpy(pszBuffer,pszString,uiLen); //insert the old string
    }

    lua_pushstring(L, pszBuffer);
  
    V_SAFE_DELETE_ARRAY(pszBuffer);

    return 1;
  }


  SWIGINTERN int VTextureObject_ToString(lua_State *L)
  {
    //this will move this function to the method table of the specified class
    
    SWIG_CONVERT_POINTER(L, -1, VTextureObject, self)
    
    char pszBuffer[1024];
    
    sprintf(pszBuffer, "VTextureObject '%s' %dx%d",self->GetFilename(),self->GetTextureWidth(),self->GetTextureHeight()); //format as requested
      
    lua_pushstring(L, pszBuffer);
    
    return 1;
  }

SWIGINTERN hkvMat3 VisContextCamera_cl_GetWorldRotationMatrix(VisContextCamera_cl const *self){
      hkvMat3 matrix;
      HKV_DISABLE_DEPRECATION
      self->GetWorldRotationMatrix(matrix);
      HKV_ENABLE_DEPRECATION
      return hkvMat3 (matrix);
    }
SWIGINTERN hkvMat3 VisContextCamera_cl_GetCameraToWorldRotation(VisContextCamera_cl const *self){
      hkvMat3 matrix = self->GetCameraToWorldRotation();
      return hkvMat3 (matrix);
    }
SWIGINTERN hkvMat3 VisContextCamera_cl_GetWorldToCameraRotation(VisContextCamera_cl const *self){
      hkvMat3 matrix = self->GetWorldToCameraRotation();
      return hkvMat3 (matrix);
    }
SWIGINTERN void VisContextCamera_cl_LookAt(VisContextCamera_cl *self,hkvVec3 *pVector){
      if(pVector)
      {
        hkvMat3 matrix;
        hkvVec3 pos = self->GetPosition();
        matrix.setLookInDirectionMatrix (*pVector - pos);
        self->Set(matrix, pos);
      }
    }
SWIGINTERN void VisContextCamera_cl_ActivateInMainRenderContext(VisContextCamera_cl *self){
      VisRenderContext_cl::GetMainRenderContext()->SetCamera(self);
    }
SWIGINTERN void VisContextCamera_cl_AttachToEntity__SWIG_1(VisContextCamera_cl *self,VisBaseEntity_cl *pEntity){
      hkvMat3 matrix;
      hkvVec3 pos = self->GetPosition();
      
      if(pEntity)
        matrix.setLookInDirectionMatrix (pEntity->GetPosition() - pos);
        
      self->AttachToEntity(pEntity, pos, matrix.getPointer ()); //NULL for the entity is allowed
    }
SWIGINTERN void VisContextCamera_cl_AttachToEntity__SWIG_2(VisContextCamera_cl *self,VisBaseEntity_cl *pEntity,hkvVec3 const &spawnPos){
      hkvMat3 matrix;
      
      if(pEntity)
        matrix.setLookInDirectionMatrix (pEntity->GetPosition() - spawnPos);
        
      self->AttachToEntity(pEntity, spawnPos, matrix.getPointer ());
    }

  SWIGINTERN int VisContextCamera_cl_ToString(lua_State *L)
  {
    //this will move this function to the method table of the specified class
    
    SWIG_CONVERT_POINTER(L, -1, VisContextCamera_cl, self)
    
    char pszBuffer[1024];
    
    sprintf(pszBuffer, "VisContextCamera_cl: '%s' [%s : %1.2f,%1.2f,%1.2f]",self->GetObjectKey(),self->IsActive()?"active":"inactive",self->GetPosition().x,self->GetPosition().y,self->GetPosition().z); //format as requested
      
    lua_pushstring(L, pszBuffer);
    
    return 1;
  }

SWIGINTERN hkvVec3 IVTimeOfDay_GetSunDirection(IVTimeOfDay *self){
      hkvVec3 vDirection;
      self->GetSunDirection(vDirection);
      
      return vDirection;
    }
SWIGINTERN void TriggerBoxEntity_cl_SetObserverFlags(TriggerBoxEntity_cl *self,VBitmask *pBitmask){
    if(pBitmask) self->SetObserverFlags(pBitmask->Get());
  }
SWIGINTERN VBitmask TriggerBoxEntity_cl_GetObserverFlags(TriggerBoxEntity_cl const *self){
    return VBitmask(self->GetObserverFlags());
  }
SWIGINTERN void TriggerBoxEntity_cl_SetEnabled(TriggerBoxEntity_cl *self,bool bValue){
    self->SetEnabled(bValue);
  }
SWIGINTERN VBitmask TriggerBoxEntity_cl_IsEnabled(TriggerBoxEntity_cl const *self){
    return VBitmask(self->IsEnabled());
  }
SWIGINTERN bool TriggerBoxEntity_cl_TestInside__SWIG_0(TriggerBoxEntity_cl const *self,hkvAlignedBBox const &bbox){
      return self->TestInside(bbox)==TRUE;
    }
SWIGINTERN bool TriggerBoxEntity_cl_TestInside__SWIG_1(TriggerBoxEntity_cl const *self,hkvVec3 const &pos){
      return self->TestInside(pos)==TRUE;
    }

  SWIGINTERN int TriggerBoxEntity_cl_Concat(lua_State *L)
  {
    //this will move this function to the method table of the specified class
    
    bool ARGS_OK = true;
    
    const char *pszString = NULL;
    int iIndex = -1;
    
    //The concat operator allows "foo"..self and self.."bar" so that
    //we have to consider self as first and as second stack element.
    
    //handle string as first (top) element
    if(lua_isstring(L,iIndex))
    {
      pszString = lua_tostring(L,iIndex);
      iIndex--;
    }
    
    SWIG_CONVERT_POINTER(L, iIndex, TriggerBoxEntity_cl, self)
    iIndex--;
    
    //handle string as second element
    if(iIndex==-2)
    {
      pszString = lua_tostring(L,iIndex);
    }
        
    unsigned int uiLen = (unsigned int) strlen(pszString);
    char *pszBuffer = new char[uiLen+128];
   
    sprintf(pszBuffer, "[0x%2x : %1.2f,%1.2f,%1.2f]",self->GetObserverFlags(),self->GetPosition().x,self->GetPosition().y,self->GetPosition().z); //format as requested
    
    //the new buffer should have the size of the old string and the new format string
    VASSERT_MSG(128>(strlen(pszBuffer)+uiLen), "Please increase your temp buffer size!");
    
    //append or prepend old buffer buffer (depending on the position inside the lua stack)
    if(iIndex==-3) //append old string
    {
      memcpy(pszBuffer+strlen(pszBuffer),pszString,uiLen+1); //also copy the terminator at the end
    }
    else //prepend old string
    {
      memmove(pszBuffer+uiLen,pszBuffer, strlen(pszBuffer)+1); //also move the terminator at the end
      memcpy(pszBuffer,pszString,uiLen); //insert the old string
    }

    lua_pushstring(L, pszBuffer);
  
    V_SAFE_DELETE_ARRAY(pszBuffer);

    return 1;
  }


  SWIGINTERN int TriggerBoxEntity_cl_ToString(lua_State *L)
  {
    //this will move this function to the method table of the specified class
    
    SWIG_CONVERT_POINTER(L, -1, TriggerBoxEntity_cl, self)
    
    char pszBuffer[1024];
    
    sprintf(pszBuffer, "TriggerBoxEntity_cl [0x%2x : %1.2f,%1.2f,%1.2f] Min[%1.2f,%1.2f,%1.2f] - Max[%1.2f,%1.2f,%1.2f]",self->GetObserverFlags(),self->GetPosition().x,self->GetPosition().y,self->GetPosition().z,self->m_LocalBoundingBox.m_vMin.x,self->m_LocalBoundingBox.m_vMin.y,self->m_LocalBoundingBox.m_vMin.z,self->m_LocalBoundingBox.m_vMax.x,self->m_LocalBoundingBox.m_vMax.y,self->m_LocalBoundingBox.m_vMax.z); //format as requested
      
    lua_pushstring(L, pszBuffer);
    
    return 1;
  }

SWIGINTERN void VisScreenMask_cl_SetBlending(VisScreenMask_cl *self,int iTranspMode){
      self->SetTransparency((VIS_TransparencyType)iTranspMode);
    }
SWIGINTERN int VisScreenMask_cl_GetBlending(VisScreenMask_cl *self){
      return (int) self->GetTransparencyType();
    }
SWIGINTERN void VisScreenMask_cl_SetWrapping(VisScreenMask_cl *self,bool bWrapU,bool bWrapV){
      self->SetWrapping(bWrapU, bWrapV);
    }
SWIGINTERN void VisScreenMask_cl_SetVisible(VisScreenMask_cl *self,bool bVisible){
      self->SetVisibleBitmask(bVisible ? 0xffffffff:0);
    }
SWIGINTERN bool VisScreenMask_cl_IsVisible(VisScreenMask_cl *self){
      return self->GetVisibleBitmask()!=0;
    }
SWIGINTERN bool VisScreenMask_cl_GetFiltering(VisScreenMask_cl const *self){
    return self->GetFiltering()==TRUE;
  }
SWIGINTERN void VisScreenMask_cl_SetFiltering(VisScreenMask_cl *self,bool bValue){
    self->SetFiltering(bValue);
  }
SWIGINTERN bool VisScreenMask_cl_GetDepthWrite(VisScreenMask_cl const *self){
    return self->GetDepthWrite()==TRUE;
  }
SWIGINTERN void VisScreenMask_cl_SetDepthWrite(VisScreenMask_cl *self,bool bValue){
    self->SetDepthWrite(bValue);
  }
SWIGINTERN void VisScreenMask_cl_SetVisibleBitmask(VisScreenMask_cl *self,VBitmask *pBitmask){
    if(pBitmask) self->SetVisibleBitmask(pBitmask->Get());
  }
SWIGINTERN VBitmask VisScreenMask_cl_GetVisibleBitmask(VisScreenMask_cl const *self){
    return VBitmask(self->GetVisibleBitmask());
  }

  SWIGINTERN int VisScreenMask_cl_Concat(lua_State *L)
  {
    //this will move this function to the method table of the specified class
    
    bool ARGS_OK = true;
    
    const char *pszString = NULL;
    int iIndex = -1;
    
    //The concat operator allows "foo"..self and self.."bar" so that
    //we have to consider self as first and as second stack element.
    
    //handle string as first (top) element
    if(lua_isstring(L,iIndex))
    {
      pszString = lua_tostring(L,iIndex);
      iIndex--;
    }
    
    SWIG_CONVERT_POINTER(L, iIndex, VisScreenMask_cl, self)
    iIndex--;
    
    //handle string as second element
    if(iIndex==-2)
    {
      pszString = lua_tostring(L,iIndex);
    }
        
    unsigned int uiLen = (unsigned int) strlen(pszString);
    char *pszBuffer = new char[uiLen+64];
   
    sprintf(pszBuffer, "[%s]",self->GetTextureObject()==NULL?"empty":self->GetTextureObject()->GetFilename()); //format as requested
    
    //the new buffer should have the size of the old string and the new format string
    VASSERT_MSG(64>(strlen(pszBuffer)+uiLen), "Please increase your temp buffer size!");
    
    //append or prepend old buffer buffer (depending on the position inside the lua stack)
    if(iIndex==-3) //append old string
    {
      memcpy(pszBuffer+strlen(pszBuffer),pszString,uiLen+1); //also copy the terminator at the end
    }
    else //prepend old string
    {
      memmove(pszBuffer+uiLen,pszBuffer, strlen(pszBuffer)+1); //also move the terminator at the end
      memcpy(pszBuffer,pszString,uiLen); //insert the old string
    }

    lua_pushstring(L, pszBuffer);
  
    V_SAFE_DELETE_ARRAY(pszBuffer);

    return 1;
  }


  SWIGINTERN int VisScreenMask_cl_ToString(lua_State *L)
  {
    //this will move this function to the method table of the specified class
    
    SWIG_CONVERT_POINTER(L, -1, VisScreenMask_cl, pSelf)
    
    char pszBuffer[512];
    
    float x,y,w,h;
    pSelf->GetPos(x,y);
    pSelf->GetTargetSize(w,h);
    
    sprintf(pszBuffer, "VisScreenMask_cl x:%0.0f y:%0.0f (%0.0fx%0.0f) '%s'", x, y, w, h, pSelf->GetTextureObject()==NULL ? "empty" : pSelf->GetTextureObject()->GetFilename()); //format as requested
      
    lua_pushstring(L, pszBuffer);
    
    return 1;
  }


  SWIGINTERN int VisScreenMask_cl_GetTextureSize(lua_State *L)
  {
    
    SWIG_CONVERT_POINTER(L, 1, VisScreenMask_cl, pSelf)
    
    int x,y;
    pSelf->GetTextureSize(x,y);
    
    lua_pushnumber(L, (lua_Number)x);
    lua_pushnumber(L, (lua_Number)y);
    
    return 2; //we leave two values on the stack
  }


  SWIGINTERN int VisScreenMask_cl_GetPos(lua_State *L)
  {
    
    SWIG_CONVERT_POINTER(L, 1, VisScreenMask_cl, pSelf)
    
    float x,y;
    pSelf->GetPos(x,y);
    
    lua_pushnumber(L, (lua_Number)x);
    lua_pushnumber(L, (lua_Number)y);
    
    return 2; //we leave two values on the stack
  }

SWIGINTERN bool IVRendererNode_RemovePostProcessor(IVRendererNode *self,VPostProcessingBaseComponent *pPostProcessor){
	    if(pPostProcessor==0)
		    return false;
			
      return self->RemoveComponent(pPostProcessor)==TRUE;
    }
SWIGINTERN VPostProcessingBaseComponent *IVRendererNode_AddPostProcessor__SWIG_0(IVRendererNode *self,char const *className,char const *szOptionalComponentName=NULL){
      return VScriptRenderer_wrapper::AddPostProcessor(self, className, szOptionalComponentName);
    }
SWIGINTERN int IVRendererNode_GetMultisampleMode(IVRendererNode *self){
      if( self->IsOfType(V_RUNTIME_CLASS(VRendererNodeCommon)) )
        return ((VRendererNodeCommon *)self)->GetMultisampleMode();
      
      return -1;
    }
SWIGINTERN bool IVRendererNode_SetGammaCorrection(IVRendererNode *self,int enable){
      if( self->IsOfType(V_RUNTIME_CLASS(VRendererNodeCommon)) )
      {
        ((VRendererNodeCommon *)self)->SetGammaCorrection(enable==0?VGC_None:(enable>0?VGC_PostTransform:VGC_PreTransform));
        return true;
      }
      
      return false;
    }
SWIGINTERN int IVRendererNode_GetGammaCorrection(IVRendererNode *self){
      if( self->IsOfType(V_RUNTIME_CLASS(VRendererNodeCommon)) )
      {
        VGammaCorrection_e correction = ((VRendererNodeCommon *)self)->GetGammaCorrection();
        return correction==VGC_None?0:(correction==VGC_PostTransform?1:-1);
      }

      return -1;
    }
SWIGINTERN bool IVRendererNode_SetUseHDR(IVRendererNode *self,bool bHDR){
      if( self->IsOfType(V_RUNTIME_CLASS(VRendererNodeCommon)) )
      {
        ((VRendererNodeCommon *)self)->SetUseHDR(bHDR);
        return true;
      }
      
      return false;
    }
SWIGINTERN bool IVRendererNode_GetUseHDR(IVRendererNode *self){
      if( self->IsOfType(V_RUNTIME_CLASS(VRendererNodeCommon)) )
        return ((VRendererNodeCommon *)self)->GetUseHDR();
      
      return false;
    }
SWIGINTERN bool IVRendererNode_IsInternalPostProcessor(IVRendererNode *self,VPostProcessingBaseComponent *pPostprocessor){
      if( self->IsOfType(V_RUNTIME_CLASS(VRendererNodeCommon)) )
        return ((VRendererNodeCommon *)self)->IsInternalPostProcessor(pPostprocessor);
      
      return false;
    }
SWIGINTERN bool IVRendererNode_RemovePostProcessors(IVRendererNode *self){
      if( self->IsOfType(V_RUNTIME_CLASS(VRendererNodeCommon)) )
      {
        ((VRendererNodeCommon *)self)->RemovePostprocessors();
        return true;
      }
      
      return false;
    }

  SWIGINTERN int IVRendererNode_Concat(lua_State *L)
  {
    //this will move this function to the method table of the specified class
    
    bool ARGS_OK = true;
    
    const char *pszString = NULL;
    int iIndex = -1;
    
    //The concat operator allows "foo"..self and self.."bar" so that
    //we have to consider self as first and as second stack element.
    
    //handle string as first (top) element
    if(lua_isstring(L,iIndex))
    {
      pszString = lua_tostring(L,iIndex);
      iIndex--;
    }
    
    SWIG_CONVERT_POINTER(L, iIndex, IVRendererNode, self)
    iIndex--;
    
    //handle string as second element
    if(iIndex==-2)
    {
      pszString = lua_tostring(L,iIndex);
    }
        
    unsigned int uiLen = (unsigned int) strlen(pszString);
    char *pszBuffer = new char[uiLen+128];
   
    sprintf(pszBuffer, "%s [%p]",self->GetTypeId()->m_lpszClassName,self); //format as requested
    
    //the new buffer should have the size of the old string and the new format string
    VASSERT_MSG(128>(strlen(pszBuffer)+uiLen), "Please increase your temp buffer size!");
    
    //append or prepend old buffer buffer (depending on the position inside the lua stack)
    if(iIndex==-3) //append old string
    {
      memcpy(pszBuffer+strlen(pszBuffer),pszString,uiLen+1); //also copy the terminator at the end
    }
    else //prepend old string
    {
      memmove(pszBuffer+uiLen,pszBuffer, strlen(pszBuffer)+1); //also move the terminator at the end
      memcpy(pszBuffer,pszString,uiLen); //insert the old string
    }

    lua_pushstring(L, pszBuffer);
  
    V_SAFE_DELETE_ARRAY(pszBuffer);

    return 1;
  }


  SWIGINTERN int IVRendererNode_ToString(lua_State *L)
  {
    //this will move this function to the method table of the specified class
    
    SWIG_CONVERT_POINTER(L, -1, IVRendererNode, self)
    
    char pszBuffer[1024];
    
    sprintf(pszBuffer, "%s [%p, PostProcessors: %d]",self->GetTypeId()->m_lpszClassName,self,self->Components().Count()); //format as requested
      
    lua_pushstring(L, pszBuffer);
    
    return 1;
  }


  SWIGINTERN int IVRendererNode_GetPostProcessor(lua_State *L)
  {

    SWIG_CONVERT_POINTER(L, 1, IVRendererNode, pSelf)

    //param #2: type name of the component
    if(!SWIG_lua_isnilstring(L,2)) luaL_error(L, "Expected a string value as parameter 2 for VisTypedEngineObject_AddComponentOfType");
    const char * szComponentType = lua_tostring(L, 2);       
    
    //param #3: optional name of the component
    const char * szComponentName = NULL;
    if(lua_isstring(L, 3))  szComponentName = lua_tostring(L, 3);
    
    IVObjectComponent *pComponent = NULL;
    
    if(szComponentName)
      pComponent = pSelf->Components().GetComponentOfTypeAndName(szComponentType, szComponentName);
    else
      pComponent = pSelf->Components().GetComponentOfType(szComponentType);
        
    //clean stack (remove all call params including self)
    lua_settop(L, 0);                                //stack: TOP

    if(pComponent!=NULL && pComponent->IsOfType(V_RUNTIME_CLASS(VPostProcessingBaseComponent)))
      LUA_PushObjectProxy(L, pComponent);            //stack: result, TOP
    else
      lua_pushnil(L);                                //stack: nil, TOP

    return 1; //one element on the stack
  }


  SWIGINTERN int VPostProcessingBaseComponent_Concat(lua_State *L)
  {
    //this will move this function to the method table of the specified class
    
    bool ARGS_OK = true;
    
    const char *pszString = NULL;
    int iIndex = -1;
    
    //The concat operator allows "foo"..self and self.."bar" so that
    //we have to consider self as first and as second stack element.
    
    //handle string as first (top) element
    if(lua_isstring(L,iIndex))
    {
      pszString = lua_tostring(L,iIndex);
      iIndex--;
    }
    
    SWIG_CONVERT_POINTER(L, iIndex, VPostProcessingBaseComponent, self)
    iIndex--;
    
    //handle string as second element
    if(iIndex==-2)
    {
      pszString = lua_tostring(L,iIndex);
    }
        
    unsigned int uiLen = (unsigned int) strlen(pszString);
    char *pszBuffer = new char[uiLen+128];
   
    sprintf(pszBuffer, "%s: %p",self->GetComponentName()==NULL?self->GetTypeId()->m_lpszClassName:self->GetComponentName(),self); //format as requested
    
    //the new buffer should have the size of the old string and the new format string
    VASSERT_MSG(128>(strlen(pszBuffer)+uiLen), "Please increase your temp buffer size!");
    
    //append or prepend old buffer buffer (depending on the position inside the lua stack)
    if(iIndex==-3) //append old string
    {
      memcpy(pszBuffer+strlen(pszBuffer),pszString,uiLen+1); //also copy the terminator at the end
    }
    else //prepend old string
    {
      memmove(pszBuffer+uiLen,pszBuffer, strlen(pszBuffer)+1); //also move the terminator at the end
      memcpy(pszBuffer,pszString,uiLen); //insert the old string
    }

    lua_pushstring(L, pszBuffer);
  
    V_SAFE_DELETE_ARRAY(pszBuffer);

    return 1;
  }


  SWIGINTERN int VPostProcessingBaseComponent_ToString(lua_State *L)
  {
    //this will move this function to the method table of the specified class
    
    SWIG_CONVERT_POINTER(L, -1, VPostProcessingBaseComponent, self)
    
    char pszBuffer[1024];
    
    sprintf(pszBuffer, "%s (%s)",self->GetTypeId()->m_lpszClassName,self->IsActive() ? "Active" : "Inactive"); //format as requested
      
    lua_pushstring(L, pszBuffer);
    
    return 1;
  }

SWIGINTERN void CubeMapHandle_cl_SetRenderFilterMask(CubeMapHandle_cl *self,VBitmask *pBitmask){
    if(pBitmask) self->SetRenderFilterMask(pBitmask->Get());
  }
SWIGINTERN VBitmask CubeMapHandle_cl_GetRenderFilterMask(CubeMapHandle_cl const *self){
    return VBitmask(self->GetRenderFilterMask());
  }

  SWIGINTERN int CubeMapHandle_cl_Concat(lua_State *L)
  {
    //this will move this function to the method table of the specified class
    
    bool ARGS_OK = true;
    
    const char *pszString = NULL;
    int iIndex = -1;
    
    //The concat operator allows "foo"..self and self.."bar" so that
    //we have to consider self as first and as second stack element.
    
    //handle string as first (top) element
    if(lua_isstring(L,iIndex))
    {
      pszString = lua_tostring(L,iIndex);
      iIndex--;
    }
    
    SWIG_CONVERT_POINTER(L, iIndex, CubeMapHandle_cl, self)
    iIndex--;
    
    //handle string as second element
    if(iIndex==-2)
    {
      pszString = lua_tostring(L,iIndex);
    }
        
    unsigned int uiLen = (unsigned int) strlen(pszString);
    char *pszBuffer = new char[uiLen+128];
   
    sprintf(pszBuffer, "[%s : %1.2f,%1.2f,%1.2f]",self->GetObjectKey(),self->GetPosition().x,self->GetPosition().y,self->GetPosition().z); //format as requested
    
    //the new buffer should have the size of the old string and the new format string
    VASSERT_MSG(128>(strlen(pszBuffer)+uiLen), "Please increase your temp buffer size!");
    
    //append or prepend old buffer buffer (depending on the position inside the lua stack)
    if(iIndex==-3) //append old string
    {
      memcpy(pszBuffer+strlen(pszBuffer),pszString,uiLen+1); //also copy the terminator at the end
    }
    else //prepend old string
    {
      memmove(pszBuffer+uiLen,pszBuffer, strlen(pszBuffer)+1); //also move the terminator at the end
      memcpy(pszBuffer,pszString,uiLen); //insert the old string
    }

    lua_pushstring(L, pszBuffer);
  
    V_SAFE_DELETE_ARRAY(pszBuffer);

    return 1;
  }


  SWIGINTERN int CubeMapHandle_cl_ToString(lua_State *L)
  {
    //this will move this function to the method table of the specified class
    
    SWIG_CONVERT_POINTER(L, -1, CubeMapHandle_cl, self)
    
    char pszBuffer[1024];
    
    sprintf(pszBuffer, "CubeMapHandle_cl [%s : %1.2f,%1.2f,%1.2f - %dpx]",self->GetObjectKey(),self->GetPosition().x,self->GetPosition().y,self->GetPosition().z,self->GetSize()); //format as requested
      
    lua_pushstring(L, pszBuffer);
    
    return 1;
  }


  SWIGINTERN int CubeMapHandle_cl_GetClipPlanes(lua_State *L)
  {
        
    SWIG_CONVERT_POINTER(L, 1, CubeMapHandle_cl, pCubemap)
    lua_pop(L, 1); //clean the stack (self is not needed any more)
    
    float fNear, fFar;
    pCubemap->GetClipPlanes(fNear, fFar);
        
    lua_pushnumber(L, (lua_Number)fNear);
    lua_pushnumber(L, (lua_Number)fFar);
    
    return 2; //in every case we leave two values at the stack
  }


  SWIGINTERN int CubeMapHandle_cl_GetUpdateParams(lua_State *L)
  {
        
    SWIG_CONVERT_POINTER(L, 1, CubeMapHandle_cl, pCubemap)
    lua_pop(L, 1); //clean the stack (self is not needed any more)
    
    float fInterval;
    int iCount;
    pCubemap->GetUpdateParams(fInterval, iCount);
        
    lua_pushnumber(L, (lua_Number)fInterval);
    lua_pushnumber(L, (lua_Number)iCount);
    
    return 2; //in every case we leave two values at the stack
  }

SWIGINTERN void IVisTriggerBaseComponent_cl_SetDisplayName(IVisTriggerBaseComponent_cl *self,char const *displayName){
      self->m_sVForgeDisplayName = displayName;
    }
SWIGINTERN void IVisTriggerBaseComponent_cl_SetIconFilename(IVisTriggerBaseComponent_cl *self,char const *iconFilename){
      self->m_sVForgeIconFilename = iconFilename;
    }

  SWIGINTERN int IVisTriggerBaseComponent_cl_ToString(lua_State *L)
  {
    //this will move this function to the method table of the specified class
    
    SWIG_CONVERT_POINTER(L, -1, IVisTriggerBaseComponent_cl, self)
    
    char pszBuffer[1024];
    
    sprintf(pszBuffer, "%s: %s [%s]",self->GetClassTypeId()->m_lpszClassName,self->GetComponentName(),self->m_sVForgeDisplayName.IsEmpty()?"no display name":self->m_sVForgeDisplayName.AsChar()); //format as requested
      
    lua_pushstring(L, pszBuffer);
    
    return 1;
  }

SWIGINTERN int VisTriggerSourceComponent_cl_LinkToTarget__SWIG_0(VisTriggerSourceComponent_cl *self,VisTriggerTargetComponent_cl *pTarget){
      if(!pTarget) return -1;
      
      IVisTriggerBaseComponent_cl::OnLink(self, pTarget);
      return 1;
    }
SWIGINTERN int VisTriggerSourceComponent_cl_LinkToTarget__SWIG_1(VisTriggerSourceComponent_cl *self,char const *szTargetName,VisTypedEngineObject_cl *pOptional=NULL){
      return self->LinkTo(szTargetName, pOptional);
    }
SWIGINTERN int VisTriggerSourceComponent_cl_UnlinkFromTarget__SWIG_0(VisTriggerSourceComponent_cl *self,VisTriggerTargetComponent_cl *pTarget){
      if(!pTarget) return -1;
      
      IVisTriggerBaseComponent_cl::OnUnlink(self, pTarget);
      return 1;
    }
SWIGINTERN int VisTriggerSourceComponent_cl_UnlinkFromTarget__SWIG_1(VisTriggerSourceComponent_cl *self,char const *szTargetName,VisTypedEngineObject_cl *pOptional=NULL){
      return self->UnlinkFrom(szTargetName, pOptional);
    }
SWIGINTERN VisTriggerSourceComponent_cl *VisTriggerSourceComponent_cl_Cast(VTypedObject *pObject){
    if(pObject && pObject->IsOfType(VisTriggerSourceComponent_cl::GetClassTypeId()))
      return (VisTriggerSourceComponent_cl *) pObject;
    Vision::Error.Warning("[Lua] Cannot cast to %s!","VisTriggerSourceComponent_cl");
    return NULL;
  }
SWIGINTERN int VisTriggerTargetComponent_cl_LinkToSource__SWIG_0(VisTriggerTargetComponent_cl *self,VisTriggerSourceComponent_cl *pSource){
      if(!pSource) return -1;
      
      IVisTriggerBaseComponent_cl::OnLink(pSource, self);
      return 1;
    }
SWIGINTERN int VisTriggerTargetComponent_cl_LinkToSource__SWIG_1(VisTriggerTargetComponent_cl *self,char const *szSourceName,VisTypedEngineObject_cl *pOptional=NULL){
      return self->LinkTo(szSourceName, pOptional);
    }
SWIGINTERN int VisTriggerTargetComponent_cl_UnlinkFromSource__SWIG_0(VisTriggerTargetComponent_cl *self,VisTriggerSourceComponent_cl *pSource){
      if(!pSource) return -1;
      
      IVisTriggerBaseComponent_cl::OnUnlink(pSource, self);
      return 1;
    }
SWIGINTERN int VisTriggerTargetComponent_cl_UnlinkFromSource__SWIG_1(VisTriggerTargetComponent_cl *self,char const *szSourceName,VisTypedEngineObject_cl *pOptional=NULL){
      return self->UnlinkFrom(szSourceName, pOptional);
    }
SWIGINTERN VisTriggerTargetComponent_cl *VisTriggerTargetComponent_cl_Cast(VTypedObject *pObject){
    if(pObject && pObject->IsOfType(VisTriggerTargetComponent_cl::GetClassTypeId()))
      return (VisTriggerTargetComponent_cl *) pObject;
    Vision::Error.Warning("[Lua] Cannot cast to %s!","VisTriggerTargetComponent_cl");
    return NULL;
  }
SWIGINTERN void VTransitionStateMachine_SetEnabled(VTransitionStateMachine *self,bool bValue){
    self->SetEnabled(bValue);
  }
SWIGINTERN bool VTransitionStateMachine_LoadFromFile(VTransitionStateMachine *self,char const *szTransitionFile,char const *szInitialAnimation){
      VisBaseEntity_cl *pOwner = (VisBaseEntity_cl *)self->GetOwner(); //we know that the owner has to be an entity
      VDynamicMesh * pMesh = (pOwner != NULL) ? pOwner->GetMesh() : NULL;
      if(!pMesh) return false;
      
      VTransitionTable *pTable = new VTransitionTable(&VTransitionManager::GlobalManager(), pMesh);
      if(!pTable->LoadFromFile(szTransitionFile)) return false;
      
      //prevent double initialization
      self->DeInit();
      self->SetInitialAnimation(szInitialAnimation);
      self->Init(pTable, true);
      
      //get the scripting component...
      VScriptComponent *pComponent = (VScriptComponent *)pOwner->Components().GetComponentOfBaseType(V_RUNTIME_CLASS(VScriptComponent));
      
      if(!pComponent) return false;

      //always receive events...      
      self->AddEventListener(pComponent);
      
      return true;
    }
SWIGINTERN char const *VTransitionStateMachine_GetActiveState(VTransitionStateMachine *self){
      if(self->GetActiveState())
        return self->GetActiveState()->GetName();
        
      return NULL;
    }
SWIGINTERN char const *VTransitionStateMachine_GetInactiveState(VTransitionStateMachine *self){
      if(self->GetInactiveState())
        return self->GetInactiveState()->GetName();
        
      return NULL;
    }
SWIGINTERN char const *VTransitionStateMachine_GetInitialAnimation(VTransitionStateMachine *self){
      return self->GetInitialAnimation().AsChar();
    }
SWIGINTERN VTransitionStateMachine *VTransitionStateMachine_Cast(VTypedObject *pObject){
    if(pObject && pObject->IsOfType(VTransitionStateMachine::GetClassTypeId()))
      return (VTransitionStateMachine *) pObject;
    Vision::Error.Warning("[Lua] Cannot cast to %s!","VTransitionStateMachine");
    return NULL;
  }

  SWIGINTERN int VTransitionStateMachine_Concat(lua_State *L)
  {
    //this will move this function to the method table of the specified class
    
    bool ARGS_OK = true;
    
    const char *pszString = NULL;
    int iIndex = -1;
    
    //The concat operator allows "foo"..self and self.."bar" so that
    //we have to consider self as first and as second stack element.
    
    //handle string as first (top) element
    if(lua_isstring(L,iIndex))
    {
      pszString = lua_tostring(L,iIndex);
      iIndex--;
    }
    
    SWIG_CONVERT_POINTER(L, iIndex, VTransitionStateMachine, self)
    iIndex--;
    
    //handle string as second element
    if(iIndex==-2)
    {
      pszString = lua_tostring(L,iIndex);
    }
        
    unsigned int uiLen = (unsigned int) strlen(pszString);
    char *pszBuffer = new char[uiLen+256];
   
    sprintf(pszBuffer, "%s [%s]",self->GetComponentName()==NULL?self->GetClassTypeId()->m_lpszClassName:self->GetComponentName(),self->GetActiveState()?self->GetActiveState()->GetName():"no active state"); //format as requested
    
    //the new buffer should have the size of the old string and the new format string
    VASSERT_MSG(256>(strlen(pszBuffer)+uiLen), "Please increase your temp buffer size!");
    
    //append or prepend old buffer buffer (depending on the position inside the lua stack)
    if(iIndex==-3) //append old string
    {
      memcpy(pszBuffer+strlen(pszBuffer),pszString,uiLen+1); //also copy the terminator at the end
    }
    else //prepend old string
    {
      memmove(pszBuffer+uiLen,pszBuffer, strlen(pszBuffer)+1); //also move the terminator at the end
      memcpy(pszBuffer,pszString,uiLen); //insert the old string
    }

    lua_pushstring(L, pszBuffer);
  
    V_SAFE_DELETE_ARRAY(pszBuffer);

    return 1;
  }


  SWIGINTERN int VTransitionStateMachine_ToString(lua_State *L)
  {
    //this will move this function to the method table of the specified class
    
    SWIG_CONVERT_POINTER(L, -1, VTransitionStateMachine, self)
    
    char pszBuffer[1024];
    
    sprintf(pszBuffer, "VTransitionStateMachine: %s [%s]",self->GetComponentName(),self->GetActiveState()?self->GetActiveState()->GetName():"no active state"); //format as requested
      
    lua_pushstring(L, pszBuffer);
    
    return 1;
  }

SWIGINTERN VAnimationComponent *VAnimationComponent_Cast(VTypedObject *pObject){
    if(pObject && pObject->IsOfType(VAnimationComponent::GetClassTypeId()))
      return (VAnimationComponent *) pObject;
    Vision::Error.Warning("[Lua] Cannot cast to %s!","VAnimationComponent");
    return NULL;
  }

  SWIGINTERN int VAnimationComponent_Concat(lua_State *L)
  {
    //this will move this function to the method table of the specified class
    
    bool ARGS_OK = true;
    
    const char *pszString = NULL;
    int iIndex = -1;
    
    //The concat operator allows "foo"..self and self.."bar" so that
    //we have to consider self as first and as second stack element.
    
    //handle string as first (top) element
    if(lua_isstring(L,iIndex))
    {
      pszString = lua_tostring(L,iIndex);
      iIndex--;
    }
    
    SWIG_CONVERT_POINTER(L, iIndex, VAnimationComponent, self)
    iIndex--;
    
    //handle string as second element
    if(iIndex==-2)
    {
      pszString = lua_tostring(L,iIndex);
    }
        
    unsigned int uiLen = (unsigned int) strlen(pszString);
    char *pszBuffer = new char[uiLen+256];
   
    sprintf(pszBuffer, "%s [%s]",self->GetComponentName()==NULL?self->GetClassTypeId()->m_lpszClassName:self->GetComponentName(),self->GetCurrentAnimation()); //format as requested
    
    //the new buffer should have the size of the old string and the new format string
    VASSERT_MSG(256>(strlen(pszBuffer)+uiLen), "Please increase your temp buffer size!");
    
    //append or prepend old buffer buffer (depending on the position inside the lua stack)
    if(iIndex==-3) //append old string
    {
      memcpy(pszBuffer+strlen(pszBuffer),pszString,uiLen+1); //also copy the terminator at the end
    }
    else //prepend old string
    {
      memmove(pszBuffer+uiLen,pszBuffer, strlen(pszBuffer)+1); //also move the terminator at the end
      memcpy(pszBuffer,pszString,uiLen); //insert the old string
    }

    lua_pushstring(L, pszBuffer);
  
    V_SAFE_DELETE_ARRAY(pszBuffer);

    return 1;
  }


  SWIGINTERN int VAnimationComponent_ToString(lua_State *L)
  {
    //this will move this function to the method table of the specified class
    
    SWIG_CONVERT_POINTER(L, -1, VAnimationComponent, self)
    
    char pszBuffer[1024];
    
    sprintf(pszBuffer, "%s: %s [%s]",self->GetClassTypeId()->m_lpszClassName,self->GetComponentName(),self->GetCurrentAnimation()); //format as requested
      
    lua_pushstring(L, pszBuffer);
    
    return 1;
  }


  SWIGINTERN int VAnimationComponent_GetSequences(lua_State *L)
  {
    
    SWIG_CONVERT_POINTER(L, 1, IVObjectComponent, pSelf)

    lua_newtable(L); //create an empty table (or an array if you would like to see it this way)
    
    VDynamicMesh * pMesh = ((VisBaseEntity_cl *)pSelf->m_pOwner)->GetMesh(); //we know that it is at least a base entity...

    if(pMesh)
    {
      VisAnimSequenceSetCollection_cl * pSequences = pMesh->GetSequenceSetCollection();

      int iOverallCount = 1;

      for(int iSet=0;iSet<pSequences->Count();++iSet)
      {
        VisAnimSequenceSet_cl * pSet = pSequences->GetSequenceSet(iSet);

        for(int j=0;j<pSet->GetSequenceCount();++j)
        {
          const char* szName = pSet->GetSequence(j)->GetName();

          if(szName)
          {
            float fLength = pSet->GetSequence(j)->GetLength();
            
            lua_newtable(L);                    // create a new sub table             stack: table, table, TOP
            
            lua_pushstring(L, "Name");          //push the key                        stack: table, table, key, TOP
            lua_pushstring(L, szName);          //push the value                      stack: table, table, key, value, TOP
            lua_settable(L, -3);                //set key and value as entry          stack: table, table, TOP
            
            lua_pushstring(L, "Length");         //push the key                       stack: table, table, key, TOP
            lua_pushnumber(L, (lua_Number)fLength);     //push the value              stack: table, table, key, value, TOP
            lua_settable(L, -3);                //set key and value as entry          stack: table, table, TOP
            
            lua_rawseti(L, -2, iOverallCount);  //add to overall table                stack: table, TOP
            
            iOverallCount++;
          }
        }
      }
    }
    
    return 1; //the table is always on the stack (even if empty)
  }

SWIGINTERN VTimedValueComponent *VTimedValueComponent_Cast(VTypedObject *pObject){
    if(pObject && pObject->IsOfType(VTimedValueComponent::GetClassTypeId()))
      return (VTimedValueComponent *) pObject;
    Vision::Error.Warning("[Lua] Cannot cast to %s!","VTimedValueComponent");
    return NULL;
  }

  SWIGINTERN int VTimedValueComponent_Concat(lua_State *L)
  {
    //this will move this function to the method table of the specified class
    
    bool ARGS_OK = true;
    
    const char *pszString = NULL;
    int iIndex = -1;
    
    //The concat operator allows "foo"..self and self.."bar" so that
    //we have to consider self as first and as second stack element.
    
    //handle string as first (top) element
    if(lua_isstring(L,iIndex))
    {
      pszString = lua_tostring(L,iIndex);
      iIndex--;
    }
    
    SWIG_CONVERT_POINTER(L, iIndex, VTimedValueComponent, self)
    iIndex--;
    
    //handle string as second element
    if(iIndex==-2)
    {
      pszString = lua_tostring(L,iIndex);
    }
        
    unsigned int uiLen = (unsigned int) strlen(pszString);
    char *pszBuffer = new char[uiLen+256];
   
    sprintf(pszBuffer, "%s [%f - %f: %f sec %s]",self->GetComponentName()==NULL?self->GetClassTypeId()->m_lpszClassName:self->GetComponentName(),self->GetFromValue(),self->GetToValue(),self->GetDuration(),self->IsPaused()?"paused":"running"); //format as requested
    
    //the new buffer should have the size of the old string and the new format string
    VASSERT_MSG(256>(strlen(pszBuffer)+uiLen), "Please increase your temp buffer size!");
    
    //append or prepend old buffer buffer (depending on the position inside the lua stack)
    if(iIndex==-3) //append old string
    {
      memcpy(pszBuffer+strlen(pszBuffer),pszString,uiLen+1); //also copy the terminator at the end
    }
    else //prepend old string
    {
      memmove(pszBuffer+uiLen,pszBuffer, strlen(pszBuffer)+1); //also move the terminator at the end
      memcpy(pszBuffer,pszString,uiLen); //insert the old string
    }

    lua_pushstring(L, pszBuffer);
  
    V_SAFE_DELETE_ARRAY(pszBuffer);

    return 1;
  }


  SWIGINTERN int VTimedValueComponent_ToString(lua_State *L)
  {
    //this will move this function to the method table of the specified class
    
    SWIG_CONVERT_POINTER(L, -1, VTimedValueComponent, self)
    
    char pszBuffer[1024];
    
    sprintf(pszBuffer, "%s: %s [%f - %f: %f sec %s]",self->GetClassTypeId()->m_lpszClassName,self->GetComponentName(),self->GetFromValue(),self->GetToValue(),self->GetDuration(),self->IsPaused()?"paused":"running"); //format as requested
      
    lua_pushstring(L, pszBuffer);
    
    return 1;
  }

SWIGINTERN VDialog *VGUIManager_ShowDialog__SWIG_0(VGUIManager *self,char const *szXmlFile){
      if(szXmlFile==NULL)
        return NULL;
        
      
  IVGUIContext *pContext = self->Contexts().Count()>0 ? self->Contexts().GetAt(0) : new VGUIMainContext(self);
  VASSERT_MSG(pContext!=NULL, "Could not find or create GUI context!");
  pContext->SetActivate(true);
;
      return pContext->ShowDialog(szXmlFile);
    }
SWIGINTERN bool VGUIManager_ShowDialog__SWIG_1(VGUIManager *self,VDialog *pDialog){
      if(pDialog==NULL)
        return false;
      
      VASSERT_MSG(pDialog->GetContext()!=NULL, "No dialog context present!")
      
      pDialog->GetContext()->ShowDialog(pDialog);
      return true;
    }
SWIGINTERN bool VGUIManager_CloseDialog(VGUIManager *self,VDialog *pDialog){
      if(pDialog==NULL)
        return false;
      
      VASSERT_MSG(pDialog->GetContext()!=NULL, "No dialog context present!")
      
      pDialog->GetContext()->CloseDialog(pDialog);
      return true;
    }
SWIGINTERN int VGUIManager_ShowModalDialog__SWIG_0(VGUIManager *self,char const *szXmlFile,float x=0,float y=0){
      if(szXmlFile==NULL)
        return false;
        
      
  IVGUIContext *pContext = self->Contexts().Count()>0 ? self->Contexts().GetAt(0) : new VGUIMainContext(self);
  VASSERT_MSG(pContext!=NULL, "Could not find or create GUI context!");
  pContext->SetActivate(true);
;
      return pContext->ShowDialogModal(NULL, szXmlFile, hkvVec2(x,y));
    }
SWIGINTERN int VGUIManager_ShowModalDialog__SWIG_3(VGUIManager *self,VDialog *pDialog){
      if(pDialog==NULL)
        return false;
      VASSERT_MSG(pDialog->GetContext()!=NULL, "No dialog context present!")
      return pDialog->GetContext()->ShowDialogModal(pDialog);
    }
SWIGINTERN void VGUIManager_SetCursorVisible(VGUIManager *self,bool bVisible){
      
  IVGUIContext *pContext = self->Contexts().Count()>0 ? self->Contexts().GetAt(0) : new VGUIMainContext(self);
  VASSERT_MSG(pContext!=NULL, "Could not find or create GUI context!");
  pContext->SetActivate(true);
;
      pContext->SetShowCursor(bVisible);
    }
SWIGINTERN bool VGUIManager_IsCursorVisible(VGUIManager *self){
      
  IVGUIContext *pContext = self->Contexts().Count()>0 ? self->Contexts().GetAt(0) : new VGUIMainContext(self);
  VASSERT_MSG(pContext!=NULL, "Could not find or create GUI context!");
  pContext->SetActivate(true);
;   
      return pContext->GetShowCursor();
    }
SWIGINTERN VBitmask VWindowBase_GetStatusBitmask(VWindowBase const *self){
      return VBitmask((unsigned int)self->m_iStatus);
    }
SWIGINTERN void VWindowBase_SetStatusBitmask(VWindowBase *self,VBitmask *pBitmask){
      if(pBitmask)
        self->m_iStatus = pBitmask->Get();
    }
SWIGINTERN void VWindowBase_SetTooltip(VWindowBase *self,char const *szText){
      self->SetTooltipText(szText);
    }
SWIGINTERN void VWindowBase_SetText(VWindowBase *self,char const *szText){
      self->SetText(szText);
    }

  SWIGINTERN int VWindowBase_Concat(lua_State *L)
  {
    //this will move this function to the method table of the specified class
    
    bool ARGS_OK = true;
    
    const char *pszString = NULL;
    int iIndex = -1;
    
    //The concat operator allows "foo"..self and self.."bar" so that
    //we have to consider self as first and as second stack element.
    
    //handle string as first (top) element
    if(lua_isstring(L,iIndex))
    {
      pszString = lua_tostring(L,iIndex);
      iIndex--;
    }
    
    SWIG_CONVERT_POINTER(L, iIndex, VWindowBase, self)
    iIndex--;
    
    //handle string as second element
    if(iIndex==-2)
    {
      pszString = lua_tostring(L,iIndex);
    }
        
    unsigned int uiLen = (unsigned int) strlen(pszString);
    char *pszBuffer = new char[uiLen+128];
   
    sprintf(pszBuffer, "[%d:'%s']",self->GetID(),VGUIManager::GlobalManager().GetIDName(self->GetID())); //format as requested
    
    //the new buffer should have the size of the old string and the new format string
    VASSERT_MSG(128>(strlen(pszBuffer)+uiLen), "Please increase your temp buffer size!");
    
    //append or prepend old buffer buffer (depending on the position inside the lua stack)
    if(iIndex==-3) //append old string
    {
      memcpy(pszBuffer+strlen(pszBuffer),pszString,uiLen+1); //also copy the terminator at the end
    }
    else //prepend old string
    {
      memmove(pszBuffer+uiLen,pszBuffer, strlen(pszBuffer)+1); //also move the terminator at the end
      memcpy(pszBuffer,pszString,uiLen); //insert the old string
    }

    lua_pushstring(L, pszBuffer);
  
    V_SAFE_DELETE_ARRAY(pszBuffer);

    return 1;
  }


  SWIGINTERN int VWindowBase_ToString(lua_State *L)
  {
    //this will move this function to the method table of the specified class
    
    SWIG_CONVERT_POINTER(L, -1, VWindowBase, self)
    
    char pszBuffer[1024];
    
    sprintf(pszBuffer, "VWindowBase: Id: %d '%s'",self->GetID(),VGUIManager::GlobalManager().GetIDName(self->GetID())); //format as requested
      
    lua_pushstring(L, pszBuffer);
    
    return 1;
  }


  SWIGINTERN int VWindowBase_GetPosition(lua_State *L)
  {
  
    SWIG_CONVERT_POINTER(L, 1, VWindowBase, pWindow);
    
    lua_settop(L,0);
    
    hkvVec2 pos = pWindow->GetPosition();
    
    lua_pushnumber(L, (lua_Number)pos.x);
    lua_pushnumber(L, (lua_Number)pos.y);

    return 2; //in every case we leave two values at the stack
  }


  SWIGINTERN int VWindowBase_GetAbsPosition(lua_State *L)
  {
  
    SWIG_CONVERT_POINTER(L, 1, VWindowBase, pWindow);
    
    lua_settop(L,0);
    
    hkvVec2 pos = pWindow->GetAbsPosition();
    
    lua_pushnumber(L, (lua_Number)pos.x);
    lua_pushnumber(L, (lua_Number)pos.y);

    return 2; //in every case we leave two values at the stack
  }


  SWIGINTERN int VWindowBase_GetSize(lua_State *L)
  {
  
    SWIG_CONVERT_POINTER(L, 1, VWindowBase, pWindow);
    
    lua_settop(L,0);
    
    hkvVec2 pos = pWindow->GetSize();
    
    lua_pushnumber(L, (lua_Number)pos.x);
    lua_pushnumber(L, (lua_Number)pos.y);

    return 2; //in every case we leave two values at the stack
  }


  SWIGINTERN int VDialog_ToString(lua_State *L)
  {
    //this will move this function to the method table of the specified class
    
    SWIG_CONVERT_POINTER(L, -1, VDialog, self)
    
    char pszBuffer[1024];
    
    sprintf(pszBuffer, "VDialog: Id: %d '%s'",self->GetID(),VGUIManager::GlobalManager().GetIDName(self->GetID())); //format as requested
      
    lua_pushstring(L, pszBuffer);
    
    return 1;
  }


  SWIGINTERN int VDialog_GetStartPosition(lua_State *L)
  {
  
    SWIG_CONVERT_POINTER(L, 1, VDialog, pDialog);
    
    lua_settop(L,0);
    
    hkvVec2 pos = pDialog->GetStartPosition();
    
    lua_pushnumber(L, (lua_Number)pos.x);
    lua_pushnumber(L, (lua_Number)pos.y);

    return 2;
  }


  SWIGINTERN int VStringInputMap_Concat(lua_State *L)
  {
    //this will move this function to the method table of the specified class
    
    bool ARGS_OK = true;
    
    const char *pszString = NULL;
    int iIndex = -1;
    
    //The concat operator allows "foo"..self and self.."bar" so that
    //we have to consider self as first and as second stack element.
    
    //handle string as first (top) element
    if(lua_isstring(L,iIndex))
    {
      pszString = lua_tostring(L,iIndex);
      iIndex--;
    }
    
    SWIG_CONVERT_POINTER(L, iIndex, VStringInputMap, self)
    iIndex--;
    
    //handle string as second element
    if(iIndex==-2)
    {
      pszString = lua_tostring(L,iIndex);
    }
        
    unsigned int uiLen = (unsigned int) strlen(pszString);
    char *pszBuffer = new char[uiLen+128];
   
    sprintf(pszBuffer, "%s",self->GetObjectKey()); //format as requested
    
    //the new buffer should have the size of the old string and the new format string
    VASSERT_MSG(128>(strlen(pszBuffer)+uiLen), "Please increase your temp buffer size!");
    
    //append or prepend old buffer buffer (depending on the position inside the lua stack)
    if(iIndex==-3) //append old string
    {
      memcpy(pszBuffer+strlen(pszBuffer),pszString,uiLen+1); //also copy the terminator at the end
    }
    else //prepend old string
    {
      memmove(pszBuffer+uiLen,pszBuffer, strlen(pszBuffer)+1); //also move the terminator at the end
      memcpy(pszBuffer,pszString,uiLen); //insert the old string
    }

    lua_pushstring(L, pszBuffer);
  
    V_SAFE_DELETE_ARRAY(pszBuffer);

    return 1;
  }


  SWIGINTERN int VStringInputMap_ToString(lua_State *L)
  {
    //this will move this function to the method table of the specified class
    
    SWIG_CONVERT_POINTER(L, -1, VStringInputMap, self)
    
    char pszBuffer[1024];
    
    sprintf(pszBuffer, "%s: [%d triggers %d alternatives]",self->GetObjectKey(),self->GetNumOfTriggers(),self->GetNumOfAlternatives()); //format as requested
      
    lua_pushstring(L, pszBuffer);
    
    return 1;
  }


  SWIGINTERN int VStringInputMap_MapTrigger(lua_State *L)
  {

    if(Vision::Editor.IsInEditor() && Vision::Editor.GetMode()<(int)VisEditorManager_cl::EDITORMODE_PLAYING_IN_GAME)
    {
      Vision::Error.Warning("MapTrigger will only work when using the 'Play the Game' mode!");
      lua_pushnumber(L, (lua_Number)-1);     //error
      return 1;
    }
    
    SWIG_CONVERT_POINTER(L, 1, VStringInputMap, pSelf)

    //param #2: name of the trigger
    if(!lua_isstring(L,2)) luaL_error(L, "Expected a string value as parameter 2 for VStringInputMap_MapTrigger");
    const char * szTriggerName = lua_tostring(L, 2); 

    //the name of the device, e.g. "PAD1", "MOUSE", etc..
    VString sDeviceType;
    bool bNewTouchArea = false;
    float pAreaAndPriority[] = { 0,0,0,0, -1000};

    //The third parameter can be a string to specify the device or a table for touch devices.
    //In case of touch devices the table defines the touch area
    if(lua_isstring(L,3))
    {
      sDeviceType = lua_tostring(L, 3); 
    }
    else if(lua_istable(L,3))
    {
      //for touch areas...

      VLuaTableIterator tableIter(L, 3);

      int iCounter = 0;

      sDeviceType = "TOUCH"; //default device

      while(tableIter.HasNext())
      {
        VString sTableElem;
        VScriptMember * pVar = tableIter.Next();

        if( strcmp(pVar->GetType(), "string")==0 )
        {
          bool bNew = strcmp(pVar->GetValue(), "new")==0;
          
          //boolean toggle to use of a new touch area
          if(bNew)
          {
            bNewTouchArea = bNew;
          }        
          else
          {
            //if another string is specified we will use it as the device name, e.g. "TOUCH1", "BACK", etc...
            sDeviceType = pVar->GetValue();
          }
        }
        else
        {
          //parse the specified float value: x1, y1, x2, y2, priority
          if(sscanf(pVar->GetValue(), "%f", &pAreaAndPriority[iCounter])!=1)
          {
            Vision::Error.Warning("[Lua] MapTrigger: Could not interpret number: %s", pVar->GetValue());
          }
            
          iCounter++;
                  
          //max allowed is 4 coordinates + 1x priority
          if(iCounter>5)
          {
            Vision::Error.Warning("[Lua] MapTrigger: Ignoring additional parameters in touch area table!");
            break;
          }
        }
      }

      //we need 4 coordinates for the touch area
      if(iCounter<4)
      {
        luaL_error(L, "[Lua] MapTrigger: Cannot create touch area with only %d values!", iCounter);
      }

    }
    else
    {
      luaL_error(L, "Expected an input device number or a table for touch areas as parameter 3 in VStringInputMap_MapTrigger");
    }

    //the control to map
    if(!lua_isstring(L,4)) luaL_error(L, "Expected a string value as parameter 4 for VStringInputMap_MapTrigger");
    int iControl = VInputManagerBase::GetUniqueControlIdentifier(lua_tostring(L, 4)); 
    if(iControl==-1) luaL_error(L, "Your specified control in parameter 4 does not exist");

    int iCurrentIndex = 5;

    int iPositiveControl = -1;
    //the second control to map (in case of an axis)
    if(lua_isstring(L,iCurrentIndex))
    {
      iPositiveControl = VInputManagerBase::GetUniqueControlIdentifier(lua_tostring(L, iCurrentIndex));
      if(iPositiveControl==-1) luaL_error(L, "Your specified control in parameter 5 does not exist");
      iCurrentIndex++;
    }

    VInputOptions options;
    int iOptTriggerIndex = -1;
    //optional table containing the input options
    if(lua_istable(L,iCurrentIndex))
    {
      VLuaTableIterator tableIter(L, iCurrentIndex);

      while(tableIter.HasNext())
      {
        VString sTableElem;
        VScriptMember * pVar = tableIter.Next();
        VString sName = pVar->GetName();
        sName.ToLower();
        VString sValue = pVar->GetValue();
        sValue.ToLower();

        if(sName=="deadzone")
        {
          float fValue;
          if(sscanf(pVar->GetValue(), "%f", &fValue)==1)
            options.m_fDeadZone = fValue;
          else
            Vision::Error.Warning("[Lua] MapTrigger: Could not interpret number: %s", pVar->GetValue());
        }
        else if(sName=="timescaled")
        {
          options.m_bTimeScaled = (sValue == "true");
        }
        else if(sName=="once")
        {
          options.m_bOnce = (sValue == "true");
        }
        else if(sName=="onceperframe")
        {
          options.m_bOncePerFrame = (sValue == "true");
          if(options.m_bOncePerFrame)
            options.m_bOnce = true;
        }
        else if(sName=="onpress")
        {
          bool bSet = (sValue == "true");

          if(bSet)
            options.m_eOnceMode = (VOnceMode)((int)options.m_eOnceMode | (int)ONCE_ON_PRESS);
          else
            options.m_eOnceMode = (VOnceMode)((int)options.m_eOnceMode & ~(int)ONCE_ON_PRESS);
        }
        else if(sName=="onrelease")
        {
          bool bSet = (sValue == "true");

          if(bSet)
            options.m_eOnceMode = (VOnceMode)((int)options.m_eOnceMode | (int)ONCE_ON_RELEASE);
          else
            options.m_eOnceMode = (VOnceMode)((int)options.m_eOnceMode & ~(int)ONCE_ON_RELEASE);
        }
        else if(sName=="holdtime")
        {
          float fValue;
          if(sscanf(pVar->GetValue(), "%f", &fValue)==1)
            options.m_fHoldTime = fValue;
          else
            Vision::Error.Warning("[Lua] MapTrigger: Could not interpret number: %s", pVar->GetValue());
        }
        else if(sName=="sensitivity")
        {
          float fValue;
          if(sscanf(pVar->GetValue(), "%f", &fValue)==1)
            options.m_fSensitivity = fValue;
          else
            Vision::Error.Warning("[Lua] MapTrigger: Could not interpret number: %s", pVar->GetValue());
        }
        else if(sName=="alternative")
        {
          int iValue;
          if(sscanf(pVar->GetValue(), "%d", &iValue)==1)
            options.m_iAlternative = iValue;
          else
            Vision::Error.Warning("[Lua] MapTrigger: Could not interpret number: %s", pVar->GetValue());
        }
        else if(sName=="usetriggerindex")
        {
          int iValue;
          if(sscanf(pVar->GetValue(), "%d", &iValue)==1)
            iOptTriggerIndex = iValue;
          else
            Vision::Error.Warning("[Lua] MapTrigger: Could not interpret number: %s", pVar->GetValue());
        }      
      }
      iCurrentIndex++;
    }

    int iResult = VScriptInput_wrapper::MapTrigger(
        pSelf,
        szTriggerName,
        sDeviceType,
        iControl, //negative axis control
        options,
        iOptTriggerIndex,
        VRectanglef(pAreaAndPriority[0],pAreaAndPriority[1],pAreaAndPriority[2],pAreaAndPriority[3]),
        pAreaAndPriority[4],
        bNewTouchArea,
        iPositiveControl);
        
    //clean up the stack
    lua_pop(L, iCurrentIndex-1);

    lua_pushnumber(L, (lua_Number)iResult);     //the mapping result needs to be on the stack as return value

    return 1; //one item on the stack
  }


  SWIGINTERN int VStringInputMap_MapTriggerAxis(lua_State *L)
  {
  
    return VStringInputMap_MapTrigger(L);
  }

SWIGINTERN VisLightSource_cl *VisGame_cl_CreateLight__SWIG_0(VisGame_cl *self,hkvVec3 const *pPos,int iType=LIGHT_POINT,float fRadius=100,char const *szKey=NULL){
      if(pPos!=NULL)
      {
        VisLightSource_cl *pLight = Vision::Game.CreateLight(*pPos, (VisLightSourceType_e) iType, fRadius);
        if(szKey!=NULL)
          pLight->SetObjectKey(szKey);
        return pLight;
      } 
      return NULL;
    }
SWIGINTERN VisPath_cl *VisGame_cl_CreatePath__SWIG_0(VisGame_cl *self,int iNodes=-1,bool bClosed=false,char const *szKey=NULL){
      if(iNodes==-1)
        return new VisPath_cl();
      return new VisPath_cl(iNodes, bClosed, szKey);
    }
SWIGINTERN VisPathNode_cl *VisGame_cl_CreatePathNode__SWIG_0(VisGame_cl *self,hkvVec3 const *pPos,char const *szKey=NULL){
      if(pPos!=NULL)
      {
        VisPathNode_cl * pNode = new VisPathNode_cl(*pPos);
        if(szKey!=NULL)
          pNode->SetObjectKey(szKey);
        return pNode;
      }
      return NULL;
    }
SWIGINTERN VisParticleEffect_cl *VisGame_cl_CreateEffect__SWIG_0(VisGame_cl *self,hkvVec3 const *pPos,char const *szEffectFile,char const *szKey=NULL){
      if(pPos!=NULL && szEffectFile!=NULL)
      {
        VisParticleEffectFile_cl *pResource = VisParticleGroupManager_cl::GlobalManager().LoadFromFile(szEffectFile);
        if(pResource==NULL)
          return NULL;
        
        VisParticleEffect_cl *pEffect = pResource->CreateParticleEffectInstance(*pPos, hkvVec3::ZeroVector());
        if(szKey!=NULL)
          pEffect->SetObjectKey(szKey);
        return pEffect;
      }
      return NULL;
    }
SWIGINTERN VisStaticMeshInstance_cl *VisGame_cl_CreateStaticMeshInstance__SWIG_0(VisGame_cl *self,hkvVec3 const *pPos,char const *szMeshFile,bool bNotifyPhysics=true,char const *szKey=NULL){
      if(pPos!=NULL && szMeshFile!=NULL)
      {
        // load the resource (will return existing resource if loaded already)
        VisStaticMesh_cl *pRes = VisStaticMesh_cl::GetResourceManager().LoadStaticMeshFile(szMeshFile);
        if(pRes==NULL)
          return NULL;
        
        // create an instance
        hkvMat4 transform;
        transform.setTranslation(*pPos);
        VisStaticMeshInstance_cl *pMeshInst = pRes->CreateInstance(transform, NULL, bNotifyPhysics);
        
        if(pMeshInst!=NULL && szKey!=NULL)
          pMeshInst->SetObjectKey(szKey);
        
        return pMeshInst;
      }
      return NULL;
    }
SWIGINTERN VDynamicMesh *VisGame_cl_CreateDynamicMesh__SWIG_0(VisGame_cl *self,char const *szDynamicMeshFile,bool bForceLoad,bool bLoadAnim=true){
      if(szDynamicMeshFile!=NULL)
      {
        return Vision::Game.LoadDynamicMesh(szDynamicMeshFile, bForceLoad, bLoadAnim);
      }
      return NULL;
    }
SWIGINTERN VDynamicMesh *VisGame_cl_MergeMeshes(VisGame_cl *self,VDynamicMesh **ppMeshesToMerge,int iCount){
      if(ppMeshesToMerge==NULL)
      {
        Vision::Error.Warning("[Lua] MergeDynamicMesh: No model meshes specified!");
        return NULL;
      }
      
      if(iCount<2||iCount>32)
      {
        Vision::Error.Warning("[Lua] MergeDynamicMesh: Cannot not merge %u mesh files. Range must be between 2 and 32!", iCount);
        return NULL;
      }

      MeshMergeInfo_t info[32];
      unsigned int uiBitmask = 0;
      
      for(int i=0;i<iCount;++i)
      {
        info[i].m_pMesh = ppMeshesToMerge[i];
        uiBitmask <<= info[i].m_pMesh==NULL ? 0 : 1;
      }
      
      VMeshManager &modelManager(VDynamicMesh::GetResourceManager());
      VString sName(32);
      sName.Format("LuaMergedModel%1.2f[%p]", Vision::GetTimer()->GetTime(), ppMeshesToMerge);
      VDynamicMesh *pMergedModel = modelManager.MergeDynamicMeshes(sName.AsChar(), info, uiBitmask);
      
      if(pMergedModel==NULL)
      {
        Vision::Error.Warning("[Lua] MergeDynamicMesh: Failed not merge %u mesh files!", iCount);
        return NULL;
      }
      
      return pMergedModel;
    }
SWIGINTERN VDynamicMesh *VisGame_cl_MergeMeshesByString(VisGame_cl *self,char const **pszMeshesToMerge,int iCount){
      if(pszMeshesToMerge==NULL)
      {
        Vision::Error.Warning("[Lua] MergeDynamicMesh: No model mesh strings specified!");
        return NULL;
      }
      
      if(iCount<2||iCount>32)
      {
        Vision::Error.Warning("[Lua] MergeDynamicMesh: Cannot not merge %u mesh files. Range must be between 2 and 32!", iCount);
        return NULL;
      }

      MeshMergeInfo_t info[32];
      unsigned int uiBitmask = 0;
      
      for(int i=0;i<iCount;++i)
      {
        info[i].m_pMesh = Vision::Game.LoadDynamicMesh(pszMeshesToMerge[i], true);
        uiBitmask <<= info[i].m_pMesh==NULL ? 0 : 1;
      }
      
      VMeshManager &modelManager(VDynamicMesh::GetResourceManager());
      VString sName(32);
      sName.Format("LuaMergedModel%1.2f[%p]", Vision::GetTimer()->GetTime(), pszMeshesToMerge);
      VDynamicMesh *pMergedModel = modelManager.MergeDynamicMeshes(sName.AsChar(), info, uiBitmask);
      
      if(pMergedModel==NULL)
      {
        Vision::Error.Warning("[Lua] MergeDynamicMesh: Failed not merge %u mesh files!", iCount);
        return NULL;
      }
      
      return pMergedModel;
    }
SWIGINTERN VTextureObject *VisGame_cl_CreateTexture__SWIG_0(VisGame_cl *self,char const *szTextureFile,bool b3DTexture=false){
      if(szTextureFile!=NULL)
      {
        if(b3DTexture) return Vision::TextureManager.Load3DTexture(szTextureFile);
        else           return Vision::TextureManager.Load2DTexture(szTextureFile);
      }
      return NULL;
    }
SWIGINTERN VisContextCamera_cl *VisGame_cl_CreateCamera__SWIG_0(VisGame_cl *self,bool bReplaceMainRenderContextCamera=true,char const *szKey=NULL){
      VisContextCamera_cl *pCamera = new VisContextCamera_cl();
      if(bReplaceMainRenderContextCamera)
        VisRenderContext_cl::GetMainRenderContext()->SetCamera(pCamera);
        
      if(szKey!=NULL)
        pCamera->SetObjectKey(szKey);
        
      return pCamera;
    }
SWIGINTERN VisScreenMask_cl *VisGame_cl_CreateScreenMask__SWIG_0(VisGame_cl *self,float x,float y,char const *szTexturePath,char const *szKey=NULL){
      if(szTexturePath==NULL)
        return NULL;
        
      VisScreenMask_cl *pMask = new VisScreenMask_cl(szTexturePath);
      
      pMask->SetPos(x,y);
        
      if(szKey!=NULL)
        pMask->SetKey(szKey);
        
      return pMask;
    }
SWIGINTERN VisLightSource_cl *VisGame_cl_GetLight(VisGame_cl *self,char const *szKey){
      if(szKey==NULL)
        return NULL;
      return VisLightSource_cl::FindByKey(szKey, NULL);
    }
SWIGINTERN VisPath_cl *VisGame_cl_GetPath(VisGame_cl *self,char const *szKey){
      if(szKey==NULL)
        return NULL;
      return VisPath_cl::FindByKey(szKey,NULL);
    }
SWIGINTERN VisParticleEffect_cl *VisGame_cl_GetEffect(VisGame_cl *self,char const *szKey){
      if(szKey==NULL)
        return NULL;
      return VisParticleGroupManager_cl::GlobalManager().Instances().FindByKey(szKey,NULL);
    }
SWIGINTERN VisStaticMeshInstance_cl *VisGame_cl_GetStaticMeshInstance(VisGame_cl *self,char const *szKey){
      if(szKey==NULL)
        return NULL;
      return VisStaticMeshInstance_cl::FindByKey(szKey,NULL);
    }
SWIGINTERN VDynamicMesh *VisGame_cl_GetDynamicMesh(VisGame_cl *self,char const *szDynamicMeshFile){
      if(szDynamicMeshFile==NULL)
        return NULL;
      return VDynamicMesh::FindDynamicMesh(szDynamicMeshFile);
    }
SWIGINTERN VisContextCamera_cl *VisGame_cl_GetCamera__SWIG_0(VisGame_cl *self,char const *szKey=NULL){
      if(szKey==NULL)
        return VisRenderContext_cl::GetMainRenderContext()->GetCamera();
      return VisContextCamera_cl::FindByKey(szKey, NULL);
    }
SWIGINTERN VisScreenMask_cl *VisGame_cl_GetScreenMask(VisGame_cl *self,char const *szKey){
      if(szKey==NULL)
        return NULL;
      return VisScreenMask_cl::FindByKey(szKey,NULL);
    }
SWIGINTERN CubeMapHandle_cl *VisGame_cl_GetCubeMap(VisGame_cl *self,char const *szKey){
      if(szKey==NULL)
        return NULL;

      return vdynamic_cast<CubeMapHandle_cl*>(CubeMapHandle_cl::FindByKey(szKey,NULL));
    }
SWIGINTERN void VisGame_cl_DeleteAllUnrefScreenMasks(VisGame_cl *self){
      VisScreenMask_cl::ElementManagerDeleteAllUnRef();
    }
SWIGINTERN void VisGame_cl_DeleteAllUnrefLights(VisGame_cl *self){
      VisLightSource_cl::ElementManagerDeleteAllUnRef();
    }
SWIGINTERN void VisGame_cl_DeleteAllUnrefPaths(VisGame_cl *self){
      VisPath_cl::ElementManagerDeleteAllUnRef();
    }
SWIGINTERN void VisGame_cl_DeleteAllUnrefStaticMeshInstances(VisGame_cl *self){
      VisStaticMeshInstance_cl::ElementManagerDeleteAllUnRef();
    }
SWIGINTERN void VisGame_cl_DeleteAllUnrefCameras(VisGame_cl *self){
      VisContextCamera_cl::ElementManagerDeleteAllUnRef();
    }
SWIGINTERN bool VisGame_cl_ExecuteAction(VisGame_cl *self,char const *szAction){
      VActionManager *pManager = Vision::GetActionManager();
      return pManager->Execute(szAction, FALSE) == TRUE;
    }

  SWIGINTERN int VisGame_cl_CreateEntity(lua_State *L)
  {

    //param #1: we do not need the first parameter at all ;)

    //param #2: the position where to spawn the entity
    SWIG_CONVERT_POINTER(L, 2, hkvVec3, pPos)    
    
    //param #3: optional class name
    const char * szClassName = lua_isstring(L, 3) ? lua_tostring(L, 3) : "VisBaseEntity_cl";
    
    //param #4: optional model file name
    const char * szModelFile = lua_isstring(L, 4) ? lua_tostring(L, 4) : NULL;
    
    //param #5: optional entity key
    const char * szKey = lua_isstring(L, 5) ? lua_tostring(L, 5) : NULL;
    
    //param #6: optional var string
    const char * szVarString = lua_isstring(L, 6) ? lua_tostring(L, 6) : NULL;

    //clean stack (remove all call params including self)
    lua_settop(L, 0);                              //stack: TOP
    
    VisBaseEntity_cl *pEntity = NULL;
    if(pPos)
    {
      pEntity = Vision::Game.CreateEntity(szClassName, *pPos, szModelFile, szVarString);
      if(pEntity!=NULL && szKey) pEntity->SetObjectKey(szKey);
    }
    
    //will handle NULL as well
    LUA_PushObjectProxy(L, pEntity);              //stack: result, TOP
    
    return 1;
  }


  SWIGINTERN int VisGame_cl_CreateComponent(lua_State *L)
  {

    //param #1: we do not need the first parameter at all ;)
    
    //param #2: type name of the component
    if(!SWIG_lua_isnilstring(L,2))
    {
      luaL_error(L, "Expected a string value as parameter 2 for VisGame_cl_CreateComponent");
      lua_pushnil(L);                                     //stack: ..., nil
      return 1;                                           //return 1 stack item (nil)
    }
    
    const char * szComponentType = lua_tostring(L, 2);       
    
    //param #3: optional name of the component
    const char * szComponentName = NULL;
    if(lua_isstring(L, 3))  szComponentName = lua_tostring(L, 3);
          
    lua_settop(L, 0); //remove all items from the stack
        
    // Search for a component type with the specified name
    VType *pType = Vision::GetTypeManager()->GetType(szComponentType);
    if (pType==NULL)
    {
      Vision::Error.Warning("[Lua] CreateComponent: did not find component of the specified type: %s", szComponentType);
      lua_pushnil(L);
      return 1;
    }

    // Create an instance of that component type
    IVObjectComponent *pComponent = (IVObjectComponent *)pType->CreateInstance();
    if (pComponent==NULL)
    {
      Vision::Error.Warning("[Lua] CreateComponent: Failed construction an instance of the specified component type: %s", szComponentType);
      lua_pushnil(L);
      return 1;
    }

    if(szComponentName) pComponent->SetComponentName(szComponentName);
    
    //will handle NULL as well
    LUA_PushObjectProxy(L, pComponent); //stack: cmpnt, TOP

    //we return the component...
    return 1;
  }


  SWIGINTERN int VisGame_cl_WaitSeconds(lua_State *L)
  {

    DECLARE_ARGS_OK;

    //we can ignore arg1 because it is a static function

    GET_ARG(2, float, fSec);
    
    if(ARGS_OK)
    {
      //Find out which script instance we are calling this from
      VScriptInstance*  pScript = VScriptResourceManager::GetScriptInstanceForState(L);
      VASSERT(pScript);
      
      pScript->WaitSeconds(L, fSec);
    }
    
    return lua_yield(L, 0);
  }


  SWIGINTERN int VisGame_cl_GetEntity(lua_State *L)
  {

    if(!lua_isstring(L,2))
    {
      luaL_error(L, "Expected a string value as parameter 2 for VisGame_cl_GetEntity");
      lua_pushnil(L);                                     //stack: ..., nil
      return 1;                                           //return 1 stack item (nil)
    }
    
    const char * pszKey = lua_tostring(L, 2);       
    
    VisBaseEntity_cl * pObj = Vision::Game.SearchEntity(pszKey);
      
    LUA_PushObjectProxy(L, pObj); //will handle NULL as well

    return 1;
  }


  SWIGINTERN int VisGame_cl_GetObject(lua_State *L)
  {

    if(!lua_isstring(L,2))
    {
      luaL_error(L, "Expected a string value as parameter 2 for VisGame_cl_GetObject");
      lua_pushnil(L);                                     //stack: ..., nil
      return 1;                                           //return 1 stack item (nil)
    }
    
    const char * pszKey = lua_tostring(L, 2);       
    
    VisTypedEngineObject_cl * pObj;
    pObj = Vision::Game.SearchEntity(pszKey);
    if (!pObj) pObj = Vision::Game.SearchLightSource(pszKey);
    if (!pObj) pObj = VisParticleGroupManager_cl::GlobalManager().Instances().FindByKey(pszKey);
    if (!pObj) pObj = Vision::Game.SearchPath(pszKey);
    if (!pObj) pObj = VisContextCamera_cl::FindByKey(pszKey);
    if (!pObj) pObj = VisStaticMeshInstance_cl::FindByKey(pszKey);
    if (!pObj) pObj = VCustomVolumeManager::GlobalManager().SearchInstance(pszKey);
    if (!pObj)
    {
      //since VisScreenMask_cl is not a typed engine object we cannot use LUA_PushObjectProxy
      VisScreenMask_cl * pMask = VisScreenMask_cl::FindByKey(pszKey);
      if(pMask)
      {
        VSWIG_Lua_NewPointerObj(L, pMask, SWIGTYPE_p_VisScreenMask_cl, VLUA_MANAGE_MEM_MANUAL);
      }
      else
      {
        lua_pushnil(L);
      }
      return 1;
    }
      
    LUA_PushObjectProxy(L, pObj); //will handle NULL as well

    return 1;
  }


  SWIGINTERN int VisGame_cl_InstantiatePrefab(lua_State *L)
  {
  
    //param #1: we do not need the first parameter at all ;)

    //param #2: the position where to spawn the prefab
    SWIG_CONVERT_POINTER(L, 2, hkvVec3, pPos)    
    
    //param #3: the prefab file
    const char * szFilename = lua_isstring(L, 3) ? lua_tostring(L, 3) : NULL;
    
    //param #4: the optional parent entity
    VisObject3D_cl *pParent = NULL;
    if(!lua_isnil(L,4) && SWIG_isptrtype(L, 4))
    {
      if( !SWIG_IsOK(SWIG_ConvertPtr(L, 4,(void**)&pParent, SWIGTYPE_p_VisObject3D_cl,0)) )
      {
        luaL_error(L, "Unable to convert parent paremter 4 to VisObject3D_cl");
        lua_pushnil(L);                                     //stack: ..., nil
        return 1;                                           //return 1 stack item (nil)
      }
    }
  
    VPrefab* pPrefab = VPrefabManager::GlobalManager().LoadPrefab( szFilename );
    if(pPrefab==NULL)
    {
      Vision::Error.Warning("[Lua] Failed to load prefab '%s' in VisGame_cl_InstantiatePrefab", szFilename);
      lua_pushnil(L);                                       //stack: ..., nil
      return 1;                                             //return 1 stack item (nil)
    }
    
    // information to instantiate
    VPrefabInstanceInfo info;
    info.m_vInstancePos = *pPos;
    info.m_vInstanceEuler = hkvVec3(0.0f,0.0f,0.0f);
    info.m_pParentObject = pParent;
    info.m_bOutputInstances = true;
    
    if(pPrefab->Instantiate(info)==FALSE)
    {
      lua_pushnil(L);                                       //stack: ..., nil
      return 1;                                             //return 1 stack item (nil)
    }
    
    //everything looks alright
    lua_newtable(L);                                        //stack: ..., table

    //push the objects on the stack
    for(unsigned int i = 0; i < info.m_Instances.GetValidSize(); ++i )
    {
      if( info.m_Instances[i]->IsOfType(V_RUNTIME_CLASS(VTypedObject)) )
      {
        LUA_PushObjectProxy(L, (VTypedObject *)info.m_Instances[i]);
                                                            //stack: ..., table, object
        lua_rawseti(L, -2, i+1);                            //stack: ..., table
      }
    }
    
    return 1;                                               //return 1 stack item (table)
  }

SWIGINTERN float IVTimer_GetTimeDiff(IVTimer *self){     
      VScriptResourceManager* pMan = (VScriptResourceManager*) Vision::GetScriptManager();
      VASSERT(pMan);

      // script thinking delta or simulation tick delta
      float fTimeDiff = pMan->GetThinkInterval();
      
      if(fTimeDiff<=0) return Vision::GetTimer()->GetTimeDifference();
      return fTimeDiff;
    }
SWIGINTERN void IVTimer_SetScriptThinkInterval__SWIG_0(IVTimer *self,float fTimeInSec=0.1){
      VScriptResourceManager* pMan = (VScriptResourceManager*) Vision::GetScriptManager();
      VASSERT(pMan);
      
      pMan->SetThinkInterval(fTimeInSec);
    }
SWIGINTERN float IVTimer_GetScriptThinkInterval(IVTimer *self){
      VScriptResourceManager* pMan = (VScriptResourceManager*) Vision::GetScriptManager();
      VASSERT(pMan);
      
      return pMan->GetThinkInterval();
    }
SWIGINTERN float IVTimer_GetThinkInterval(IVTimer *self){     
      return Vision::GetTimer()->GetTimeDifference();
    }
SWIGINTERN void IVTimer_EnableSlowMotion(IVTimer *self,bool bEnable){
      self->SetSlowMotion(bEnable ? VIS_ENABLED : VIS_DISABLED);
    }
SWIGINTERN bool IVTimer_IsSlowMotionEnabled(IVTimer *self){
      return self->GetSlowMotion() == VIS_ENABLED;
    }
SWIGINTERN void IVTimer_SetFrozen(IVTimer *self,bool bEnable){
      self->SetFrozen(bEnable ? VIS_ENABLED : VIS_DISABLED);
    }
SWIGINTERN bool IVTimer_IsFrozen(IVTimer *self){
      return self->GetFrozen() == VIS_ENABLED;
    }

  SWIGINTERN int VScriptInput_wrapper_GetMousePosition(lua_State *L)
  {
        
    #if defined(WIN32) && defined(SUPPORTS_MOUSE)
      int x, y, w, h;
      Vision::Contexts.GetMainRenderContext()->GetViewport(x, y, w, h);
      int iMouseX = VInputManager::GetMouse().GetRawControlValue(CT_MOUSE_RAW_CURSOR_X);
      int iMouseY = VInputManager::GetMouse().GetRawControlValue(CT_MOUSE_RAW_CURSOR_Y);
      
      if(iMouseX<0)
        lua_pushnumber(L, (lua_Number)0);
      else if(iMouseX>w)
        lua_pushnumber(L, (lua_Number)w);
      else
        lua_pushnumber(L, (lua_Number)iMouseX);
      
      if(iMouseY<0)
        lua_pushnumber(L, (lua_Number)0);
      else if(iMouseY>h)
        lua_pushnumber(L, (lua_Number)h);
      else
        lua_pushnumber(L, (lua_Number)iMouseY);
    #else
      lua_pushnumber(L, (lua_Number)0);
      lua_pushnumber(L, (lua_Number)0);
    #endif
    
    return 2; //in every case we leave two values at the stack
  }


  SWIGINTERN int VScriptInput_wrapper_GetMouseDelta(lua_State *L)
  {
    
    #ifdef SUPPORTS_MOUSE
      DECLARE_ARGS_OK
    
      GET_OPT_ARG(2, bool, bApllyTimeDiff, true)
    
      if(ARGS_OK && bApllyTimeDiff)
      {
        VScriptResourceManager* pMan = (VScriptResourceManager*) Vision::GetScriptManager();
        VASSERT(pMan);

        // script thinking delta or simulation tick delta
        float fTimeDiff = pMan->GetThinkInterval();
        if(fTimeDiff<=0) fTimeDiff = Vision::GetTimer()->GetTimeDifference();

        lua_pushnumber(L, (lua_Number)(Vision::Mouse.GetDeltaX()*fTimeDiff));
        lua_pushnumber(L, (lua_Number)(Vision::Mouse.GetDeltaY()*fTimeDiff));
      }
      else
      {
        lua_pushnumber(L, (lua_Number)Vision::Mouse.GetDeltaX());
        lua_pushnumber(L, (lua_Number)Vision::Mouse.GetDeltaY());
      }
    #else
      lua_pushnumber(L, (lua_Number)0);
      lua_pushnumber(L, (lua_Number)0);
    #endif
    
    return 2; //in every case we leave two values at the stack
  }

SWIGINTERN IVTimeOfDay *VScriptRenderer_wrapper_GetTimeOfDayHandler(VScriptRenderer_wrapper *self){
      return Vision::Renderer.GetTimeOfDayHandler();
    }
SWIGINTERN IVRendererNode *VScriptRenderer_wrapper_GetRendererNode__SWIG_0(VScriptRenderer_wrapper *self,int iIndex=1){
      return (iIndex>0 && iIndex <= Vision::Renderer.GetRendererNodeCount()) ? Vision::Renderer.GetRendererNode(iIndex-1) : 0;
    }
SWIGINTERN void VScriptRenderer_wrapper_SetGlobalAmbientColor(VScriptRenderer_wrapper *self,VColorRef ambientColor){
      Vision::Renderer.SetGlobalAmbientColor(hkvVec4((float)ambientColor.r/255.f, (float)ambientColor.g/255.f, (float)ambientColor.b/255.f, (float)ambientColor.a/255.f));
    }
SWIGINTERN void VScriptRenderer_wrapper_SetWireframeMode(VScriptRenderer_wrapper *self,bool bStatus){
      Vision::Renderer.SetWireframeMode(bStatus);
    }
SWIGINTERN bool VScriptRenderer_wrapper_GetWireframeMode(VScriptRenderer_wrapper *self){
      return Vision::Renderer.GetWireframeMode();
    }
SWIGINTERN char const *VScriptRenderer_wrapper_GetVertexShaderVersion(VScriptRenderer_wrapper *self){
      VShaderModel_e version = Vision::Renderer.GetVertexShaderVersion();

      switch(version)
      {
        case VSM_BEST: return "BEST";
        case VSM_SM11: return "SM11";
        case VSM_SM20: return "SM20";///< vs and ps
        case VSM_SM2a: return "SM2A";///< vs and ps
        case VSM_SM2b: return "SM2B";///< vs and ps
        case VSM_SM30: return "SM30";///< vs and ps
        case VSM_SM40: return "SM40";///< vs, ps and gs (DX10, DX11)
        case VSM_SM41: return "SM41";///< vs, ps and gs (DX10, DX11)
        case VSM_SM40_LEVEL_91: return "SM4L91";///< vs and ps (DX11 Level 9)
        case VSM_SM40_LEVEL_93: return "SM4L93";///< vs and ps (DX11 Level 9)
        case VSM_SM50: return "SM5";///< vs, ps, and gs (DX11)
        default: return "INVALID";
      }
    }

  SWIGINTERN int VScriptScreen_wrapper_Project2D(lua_State *L)
  {

    SWIG_CONVERT_POINTER(L, 2, hkvVec3, pVec)

    float x,y;
    if(Vision::IsInitialized() && Vision::Contexts.GetCurrentContext()->Project2D(*pVec,x,y))
    {
      lua_pushnumber(L, (lua_Number)x);
      lua_pushnumber(L, (lua_Number)y);
    }
    else
    {
      lua_pushnil(L);
      lua_pushnil(L);
    }

    return 2; 
  }


  SWIGINTERN int VScriptScreen_wrapper_GetViewportSize(lua_State *L)
  {

    lua_settop(L,0);

    if(Vision::IsInitialized() && Vision::Contexts.GetMainRenderContext())
    {
      int x, y, w, h;
      Vision::Contexts.GetMainRenderContext()->GetViewport(x, y, w, h);
      lua_pushnumber(L, (lua_Number)w);
      lua_pushnumber(L, (lua_Number)h);
    }
    else
    {
      lua_pushnil(L);
      lua_pushnil(L);
    }

    return 2; 
  }


  SWIGINTERN int VScriptFileSystem_wrapper_GetAbsDir(lua_State *L)
  {

    DECLARE_ARGS_OK;

    //we can ignore arg1 because it is a static function

    GET_ARG(2, const char *, szFileName);
    
    bool bSuccess = false;
    
    if (ARGS_OK)
    {
      char pBuffer[1024]; //create a buffer on the stack
      Vision::File.GetAbsoluteDirectory(pBuffer, szFileName);
      lua_pushstring(L, pBuffer);
    }
    else
    {
      lua_pushnil(L);
    }
    
    return 1;
  }


  SWIGINTERN int VScriptFileSystem_wrapper_GetDataDirs(lua_State *L)
  {

    lua_newtable(L);                                        //stack: ..., table
    
    int iCount = Vision::File.GetMaxDataDirectoryCount();

    for(int i=0;i<iCount;++i)
    {
      lua_pushstring(L, Vision::File.GetDataDirectory(i));  //stack: ..., table, string
      lua_rawseti(L, -2, i+1);                         //stack: ..., table
    } 
    
    return 1; //return the table as stack param
  }


  SWIGINTERN int VScriptApp_wrapper_LoadScript(lua_State *L)
  {

    DECLARE_ARGS_OK;

    //we can ignore arg1 because it is a static function

    GET_ARG(2, const char *, szFileName);
    
    bool bSuccess = false;
    
    if (ARGS_OK)
    {
      bSuccess = VScriptApp_wrapper::LoadScript(L, szFileName);
    }
    
    lua_pushboolean(L, bSuccess ? TRUE : FALSE);
    return 1;
  }


  int Vision_Assert(lua_State *L)
  {
    #ifdef _DEBUG
      DECLARE_ARGS_OK;
      
      GET_ARG(1, bool, bCondition);
      GET_OPT_ARG(2, const char *, szMessage, "Lua script assertion failed!");

      if (ARGS_OK)
      {
        VASSERT_MSG(bCondition, szMessage);
      }
      else
      {
        VASSERT_MSG(bCondition, "Invalid Assertion, use: Vision.Assert(condition, message)");
      }
    #endif
    return 0;
  }

#ifdef __cplusplus
extern "C" {
#endif
static int _wrap_LIGHT_POINT_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("LIGHT_POINT",0,0)
  result = (int)(int)LIGHT_POINT;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_LIGHT_DIRECTED_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("LIGHT_DIRECTED",0,0)
  result = (int)(int)LIGHT_DIRECTED;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_LIGHT_SPOT_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("LIGHT_SPOT",0,0)
  result = (int)(int)LIGHT_SPOT;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_CORONA_NO_SCALE_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("CORONA_NO_SCALE",0,0)
  result = (int)(int)CORONA_NO_SCALE;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_CORONA_DISTANCE_SCALE_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("CORONA_DISTANCE_SCALE",0,0)
  result = (int)(int)CORONA_DISTANCE_SCALE;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_CORONA_AREA_SCALE_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("CORONA_AREA_SCALE",0,0)
  result = (int)(int)CORONA_AREA_SCALE;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_CORONA_FADEOUT_SCALE_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("CORONA_FADEOUT_SCALE",0,0)
  result = (int)(int)CORONA_FADEOUT_SCALE;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_CORONA_ROTATING_SCALE_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("CORONA_ROTATING_SCALE",0,0)
  result = (int)(int)CORONA_ROTATING_SCALE;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GUI_STATE_DISABLED_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("GUI_STATE_DISABLED",0,0)
  result = (int)(int)GUI_STATE_DISABLED;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GUI_STATE_NORMAL_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("GUI_STATE_NORMAL",0,0)
  result = (int)(int)GUI_STATE_NORMAL;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GUI_STATE_MOUSEOVER_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("GUI_STATE_MOUSEOVER",0,0)
  result = (int)(int)GUI_STATE_MOUSEOVER;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GUI_STATE_SELECTED_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("GUI_STATE_SELECTED",0,0)
  result = (int)(int)GUI_STATE_SELECTED;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GUI_ALIGN_ABSOLUTE_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("GUI_ALIGN_ABSOLUTE",0,0)
  result = (int)(int)GUI_ALIGN_ABSOLUTE;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GUI_ALIGN_CENTER_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("GUI_ALIGN_CENTER",0,0)
  result = (int)(int)GUI_ALIGN_CENTER;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GUI_ALIGN_PARENT_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("GUI_ALIGN_PARENT",0,0)
  result = (int)(int)GUI_ALIGN_PARENT;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GUI_ALIGN_PARENT_CENTER_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("GUI_ALIGN_PARENT_CENTER",0,0)
  result = (int)(int)GUI_ALIGN_PARENT_CENTER;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TRACE_IGNORE_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("TRACE_IGNORE",0,0)
  result = (int)(int)TRACE_IGNORE;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TRACE_AABOX_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("TRACE_AABOX",0,0)
  result = (int)(int)TRACE_AABOX;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TRACE_OBOX_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("TRACE_OBOX",0,0)
  result = (int)(int)TRACE_OBOX;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TRACE_SPHERE_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("TRACE_SPHERE",0,0)
  result = (int)(int)TRACE_SPHERE;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TRACE_POLYGON_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("TRACE_POLYGON",0,0)
  result = (int)(int)TRACE_POLYGON;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_EDITOR_NONE_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("EDITOR_NONE",0,0)
  result = (int)(int)EDITOR_NONE;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_EDITOR_ANIMATING_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("EDITOR_ANIMATING",0,0)
  result = (int)(int)EDITOR_ANIMATING;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_EDITOR_RUN_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("EDITOR_RUN",0,0)
  result = (int)(int)EDITOR_RUN;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_EDITOR_PLAY_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("EDITOR_PLAY",0,0)
  result = (int)(int)EDITOR_PLAY;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VRAND_MAX_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("VRAND_MAX",0,0)
  result = (int)(int)VRAND_MAX;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VRAND_MAX_INV_get(lua_State* L) {
  int SWIG_arg = 0;
  float result;
  
  SWIG_check_num_args("VRAND_MAX_INV",0,0)
  result = (float)(float)VRAND_MAX_INV;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VRAND_MAX_2_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("VRAND_MAX_2",0,0)
  result = (int)(int)VRAND_MAX_2;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TEXTURE_TYPE_DIFFUSE_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("TEXTURE_TYPE_DIFFUSE",0,0)
  result = (int)(int)TEXTURE_TYPE_DIFFUSE;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TEXTURE_TYPE_NORMAL_MAP_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("TEXTURE_TYPE_NORMAL_MAP",0,0)
  result = (int)(int)TEXTURE_TYPE_NORMAL_MAP;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TEXTURE_TYPE_SPEC_MAP_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("TEXTURE_TYPE_SPEC_MAP",0,0)
  result = (int)(int)TEXTURE_TYPE_SPEC_MAP;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BLEND_OPAQUE_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("BLEND_OPAQUE",0,0)
  result = (int)(int)BLEND_OPAQUE;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BLEND_MULTIPLY_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("BLEND_MULTIPLY",0,0)
  result = (int)(int)BLEND_MULTIPLY;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BLEND_ADDITIVE_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("BLEND_ADDITIVE",0,0)
  result = (int)(int)BLEND_ADDITIVE;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BLEND_ADDITIVE_NOALPHA_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("BLEND_ADDITIVE_NOALPHA",0,0)
  result = (int)(int)BLEND_ADDITIVE_NOALPHA;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BLEND_ALPHA_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("BLEND_ALPHA",0,0)
  result = (int)(int)BLEND_ALPHA;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BLEND_ALPHA_TEST_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("BLEND_ALPHA_TEST",0,0)
  result = (int)(int)BLEND_ALPHA_TEST;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BLEND_ADD_MODULATE_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("BLEND_ADD_MODULATE",0,0)
  result = (int)(int)BLEND_ADD_MODULATE;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MATH_SMALL_EPSILON_get(lua_State* L) {
  int SWIG_arg = 0;
  float result;
  
  SWIG_check_num_args("MATH_SMALL_EPSILON",0,0)
  result = (float)(float)MATH_SMALL_EPSILON;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MATH_DEFAULT_EPSILON_get(lua_State* L) {
  int SWIG_arg = 0;
  float result;
  
  SWIG_check_num_args("MATH_DEFAULT_EPSILON",0,0)
  result = (float)(float)MATH_DEFAULT_EPSILON;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MATH_LARGE_EPSILON_get(lua_State* L) {
  int SWIG_arg = 0;
  float result;
  
  SWIG_check_num_args("MATH_LARGE_EPSILON",0,0)
  result = (float)(float)MATH_LARGE_EPSILON;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MATH_HUGE_EPSILON_get(lua_State* L) {
  int SWIG_arg = 0;
  float result;
  
  SWIG_check_num_args("MATH_HUGE_EPSILON",0,0)
  result = (float)(float)MATH_HUGE_EPSILON;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MATH_GIGANTIC_EPSILON_get(lua_State* L) {
  int SWIG_arg = 0;
  float result;
  
  SWIG_check_num_args("MATH_GIGANTIC_EPSILON",0,0)
  result = (float)(float)MATH_GIGANTIC_EPSILON;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_hkvVec3__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  hkvVec3 *arg1 = 0 ;
  hkvVec3 *result = 0 ;
  
  SWIG_check_num_args("hkvVec3",1,1)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("hkvVec3",1,"hkvVec3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("new_hkvVec3",1,SWIGTYPE_p_hkvVec3);
  }
  
  result = (hkvVec3 *)new hkvVec3((hkvVec3 const &)*arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_hkvVec3,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_hkvVec3__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  float arg1 ;
  hkvVec3 *result = 0 ;
  
  SWIG_check_num_args("hkvVec3",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("hkvVec3",1,"float");
  arg1 = (float)lua_tonumber(L, 1);
  result = (hkvVec3 *)new hkvVec3(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_hkvVec3,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_hkvVec3__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  float arg1 ;
  float arg2 ;
  float arg3 ;
  hkvVec3 *result = 0 ;
  
  SWIG_check_num_args("hkvVec3",3,3)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("hkvVec3",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("hkvVec3",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("hkvVec3",3,"float");
  arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  result = (hkvVec3 *)new hkvVec3(arg1,arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_hkvVec3,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvVec3_setZero(lua_State* L) {
  int SWIG_arg = 0;
  hkvVec3 *arg1 = (hkvVec3 *) 0 ;
  
  SWIG_check_num_args("setZero",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("setZero",1,"hkvVec3 *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("hkvVec3_setZero",1,SWIGTYPE_p_hkvVec3);
  }
  
  (arg1)->setZero();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvVec3_set__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  hkvVec3 *arg1 = (hkvVec3 *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("set",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("set",1,"hkvVec3 *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("set",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("hkvVec3_set",1,SWIGTYPE_p_hkvVec3);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->set(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvVec3_set__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  hkvVec3 *arg1 = (hkvVec3 *) 0 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  
  SWIG_check_num_args("set",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("set",1,"hkvVec3 *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("set",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("set",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("set",4,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("hkvVec3_set",1,SWIGTYPE_p_hkvVec3);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4);
  (arg1)->set(arg2,arg3,arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvVec3_set(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_hkvVec3, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_hkvVec3_set__SWIG_0(L);
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_hkvVec3, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_hkvVec3_set__SWIG_1(L);
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'hkvVec3_set'\n"
    "  Possible C/C++ prototypes are:\n"
    "    set(hkvVec3 *,float)\n"
    "    set(hkvVec3 *,float,float,float)\n");
  lua_error(L);return 0;
}


static int _wrap_hkvVec3_isZero__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  hkvVec3 *arg1 = (hkvVec3 *) 0 ;
  bool result;
  
  SWIG_check_num_args("isZero",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("isZero",1,"hkvVec3 const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("hkvVec3_isZero",1,SWIGTYPE_p_hkvVec3);
  }
  
  result = (bool)((hkvVec3 const *)arg1)->isZero();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvVec3_isZero__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  hkvVec3 *arg1 = (hkvVec3 *) 0 ;
  float arg2 ;
  bool result;
  
  SWIG_check_num_args("isZero",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("isZero",1,"hkvVec3 const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("isZero",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("hkvVec3_isZero",1,SWIGTYPE_p_hkvVec3);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  result = (bool)((hkvVec3 const *)arg1)->isZero(arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvVec3_isZero(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_hkvVec3, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_hkvVec3_isZero__SWIG_0(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_hkvVec3, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_hkvVec3_isZero__SWIG_1(L);
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'hkvVec3_isZero'\n"
    "  Possible C/C++ prototypes are:\n"
    "    isZero(hkvVec3 const *)\n"
    "    isZero(hkvVec3 const *,float)\n");
  lua_error(L);return 0;
}


static int _wrap_hkvVec3_isIdentical(lua_State* L) {
  int SWIG_arg = 0;
  hkvVec3 *arg1 = (hkvVec3 *) 0 ;
  hkvVec3 *arg2 = 0 ;
  bool result;
  
  SWIG_check_num_args("isIdentical",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("isIdentical",1,"hkvVec3 const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("isIdentical",2,"hkvVec3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("hkvVec3_isIdentical",1,SWIGTYPE_p_hkvVec3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("hkvVec3_isIdentical",2,SWIGTYPE_p_hkvVec3);
  }
  
  result = (bool)((hkvVec3 const *)arg1)->isIdentical((hkvVec3 const &)*arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvVec3_isEqual(lua_State* L) {
  int SWIG_arg = 0;
  hkvVec3 *arg1 = (hkvVec3 *) 0 ;
  hkvVec3 *arg2 = 0 ;
  float arg3 ;
  bool result;
  
  SWIG_check_num_args("isEqual",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("isEqual",1,"hkvVec3 const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("isEqual",2,"hkvVec3 const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("isEqual",3,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("hkvVec3_isEqual",1,SWIGTYPE_p_hkvVec3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("hkvVec3_isEqual",2,SWIGTYPE_p_hkvVec3);
  }
  
  arg3 = (float)lua_tonumber(L, 3);
  result = (bool)((hkvVec3 const *)arg1)->isEqual((hkvVec3 const &)*arg2,arg3);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvVec3_isValid(lua_State* L) {
  int SWIG_arg = 0;
  hkvVec3 *arg1 = (hkvVec3 *) 0 ;
  bool result;
  
  SWIG_check_num_args("isValid",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("isValid",1,"hkvVec3 const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("hkvVec3_isValid",1,SWIGTYPE_p_hkvVec3);
  }
  
  result = (bool)((hkvVec3 const *)arg1)->isValid();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvVec3_isNormalized__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  hkvVec3 *arg1 = (hkvVec3 *) 0 ;
  float arg2 ;
  bool result;
  
  SWIG_check_num_args("isNormalized",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("isNormalized",1,"hkvVec3 const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("isNormalized",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("hkvVec3_isNormalized",1,SWIGTYPE_p_hkvVec3);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  result = (bool)((hkvVec3 const *)arg1)->isNormalized(arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvVec3_isNormalized__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  hkvVec3 *arg1 = (hkvVec3 *) 0 ;
  bool result;
  
  SWIG_check_num_args("isNormalized",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("isNormalized",1,"hkvVec3 const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("hkvVec3_isNormalized",1,SWIGTYPE_p_hkvVec3);
  }
  
  result = (bool)((hkvVec3 const *)arg1)->isNormalized();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvVec3_isNormalized(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_hkvVec3, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_hkvVec3_isNormalized__SWIG_1(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_hkvVec3, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_hkvVec3_isNormalized__SWIG_0(L);
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'hkvVec3_isNormalized'\n"
    "  Possible C/C++ prototypes are:\n"
    "    isNormalized(hkvVec3 const *,float)\n"
    "    isNormalized(hkvVec3 const *)\n");
  lua_error(L);return 0;
}


static int _wrap_hkvVec3_dot(lua_State* L) {
  int SWIG_arg = 0;
  hkvVec3 *arg1 = (hkvVec3 *) 0 ;
  hkvVec3 *arg2 = 0 ;
  float result;
  
  SWIG_check_num_args("dot",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("dot",1,"hkvVec3 const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("dot",2,"hkvVec3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("hkvVec3_dot",1,SWIGTYPE_p_hkvVec3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("hkvVec3_dot",2,SWIGTYPE_p_hkvVec3);
  }
  
  result = (float)((hkvVec3 const *)arg1)->dot((hkvVec3 const &)*arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvVec3_getLength(lua_State* L) {
  int SWIG_arg = 0;
  hkvVec3 *arg1 = (hkvVec3 *) 0 ;
  float result;
  
  SWIG_check_num_args("getLength",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("getLength",1,"hkvVec3 const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("hkvVec3_getLength",1,SWIGTYPE_p_hkvVec3);
  }
  
  result = (float)((hkvVec3 const *)arg1)->getLength();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvVec3_getLengthSquared(lua_State* L) {
  int SWIG_arg = 0;
  hkvVec3 *arg1 = (hkvVec3 *) 0 ;
  float result;
  
  SWIG_check_num_args("getLengthSquared",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("getLengthSquared",1,"hkvVec3 const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("hkvVec3_getLengthSquared",1,SWIGTYPE_p_hkvVec3);
  }
  
  result = (float)((hkvVec3 const *)arg1)->getLengthSquared();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvVec3_getLengthInverse(lua_State* L) {
  int SWIG_arg = 0;
  hkvVec3 *arg1 = (hkvVec3 *) 0 ;
  float result;
  
  SWIG_check_num_args("getLengthInverse",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("getLengthInverse",1,"hkvVec3 const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("hkvVec3_getLengthInverse",1,SWIGTYPE_p_hkvVec3);
  }
  
  result = (float)((hkvVec3 const *)arg1)->getLengthInverse();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvVec3_normalize(lua_State* L) {
  int SWIG_arg = 0;
  hkvVec3 *arg1 = (hkvVec3 *) 0 ;
  
  SWIG_check_num_args("normalize",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("normalize",1,"hkvVec3 *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("hkvVec3_normalize",1,SWIGTYPE_p_hkvVec3);
  }
  
  (arg1)->normalize();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvVec3_getNormalized(lua_State* L) {
  int SWIG_arg = 0;
  hkvVec3 *arg1 = (hkvVec3 *) 0 ;
  SwigValueWrapper< hkvVec3 > result;
  
  SWIG_check_num_args("getNormalized",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("getNormalized",1,"hkvVec3 const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("hkvVec3_getNormalized",1,SWIGTYPE_p_hkvVec3);
  }
  
  result = ((hkvVec3 const *)arg1)->getNormalized();
  {
    hkvVec3 * resultptr = new hkvVec3((const hkvVec3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_hkvVec3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvVec3_normalizeIfNotZero(lua_State* L) {
  int SWIG_arg = 0;
  hkvVec3 *arg1 = (hkvVec3 *) 0 ;
  bool result;
  
  SWIG_check_num_args("normalizeIfNotZero",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("normalizeIfNotZero",1,"hkvVec3 *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("hkvVec3_normalizeIfNotZero",1,SWIGTYPE_p_hkvVec3);
  }
  
  result = (bool)hkvVec3_normalizeIfNotZero(arg1);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvVec3_normalizedEnsureUnitLength(lua_State* L) {
  int SWIG_arg = 0;
  hkvVec3 *arg1 = (hkvVec3 *) 0 ;
  float result;
  
  SWIG_check_num_args("normalizedEnsureUnitLength",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("normalizedEnsureUnitLength",1,"hkvVec3 *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("hkvVec3_normalizedEnsureUnitLength",1,SWIGTYPE_p_hkvVec3);
  }
  
  result = (float)(arg1)->normalizedEnsureUnitLength();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvVec3_getDistanceTo(lua_State* L) {
  int SWIG_arg = 0;
  hkvVec3 *arg1 = (hkvVec3 *) 0 ;
  hkvVec3 *arg2 = 0 ;
  float result;
  
  SWIG_check_num_args("getDistanceTo",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("getDistanceTo",1,"hkvVec3 const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("getDistanceTo",2,"hkvVec3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("hkvVec3_getDistanceTo",1,SWIGTYPE_p_hkvVec3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("hkvVec3_getDistanceTo",2,SWIGTYPE_p_hkvVec3);
  }
  
  result = (float)((hkvVec3 const *)arg1)->getDistanceTo((hkvVec3 const &)*arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvVec3_getDistanceToSquared(lua_State* L) {
  int SWIG_arg = 0;
  hkvVec3 *arg1 = (hkvVec3 *) 0 ;
  hkvVec3 *arg2 = 0 ;
  float result;
  
  SWIG_check_num_args("getDistanceToSquared",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("getDistanceToSquared",1,"hkvVec3 const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("getDistanceToSquared",2,"hkvVec3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("hkvVec3_getDistanceToSquared",1,SWIGTYPE_p_hkvVec3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("hkvVec3_getDistanceToSquared",2,SWIGTYPE_p_hkvVec3);
  }
  
  result = (float)((hkvVec3 const *)arg1)->getDistanceToSquared((hkvVec3 const &)*arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvVec3_setLength(lua_State* L) {
  int SWIG_arg = 0;
  hkvVec3 *arg1 = (hkvVec3 *) 0 ;
  float arg2 ;
  bool result;
  
  SWIG_check_num_args("setLength",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("setLength",1,"hkvVec3 *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("setLength",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("hkvVec3_setLength",1,SWIGTYPE_p_hkvVec3);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  result = (bool)hkvVec3_setLength(arg1,arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvVec3_negate(lua_State* L) {
  int SWIG_arg = 0;
  hkvVec3 *arg1 = (hkvVec3 *) 0 ;
  
  SWIG_check_num_args("negate",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("negate",1,"hkvVec3 *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("hkvVec3_negate",1,SWIGTYPE_p_hkvVec3);
  }
  
  (arg1)->negate();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvVec3_compMul__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  hkvVec3 *arg1 = (hkvVec3 *) 0 ;
  hkvVec3 *arg2 = 0 ;
  SwigValueWrapper< hkvVec3 > result;
  
  SWIG_check_num_args("compMul",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("compMul",1,"hkvVec3 const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("compMul",2,"hkvVec3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("hkvVec3_compMul",1,SWIGTYPE_p_hkvVec3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("hkvVec3_compMul",2,SWIGTYPE_p_hkvVec3);
  }
  
  result = ((hkvVec3 const *)arg1)->compMul((hkvVec3 const &)*arg2);
  {
    hkvVec3 * resultptr = new hkvVec3((const hkvVec3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_hkvVec3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvVec3_compDiv__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  hkvVec3 *arg1 = (hkvVec3 *) 0 ;
  hkvVec3 *arg2 = 0 ;
  SwigValueWrapper< hkvVec3 > result;
  
  SWIG_check_num_args("compDiv",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("compDiv",1,"hkvVec3 const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("compDiv",2,"hkvVec3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("hkvVec3_compDiv",1,SWIGTYPE_p_hkvVec3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("hkvVec3_compDiv",2,SWIGTYPE_p_hkvVec3);
  }
  
  result = ((hkvVec3 const *)arg1)->compDiv((hkvVec3 const &)*arg2);
  {
    hkvVec3 * resultptr = new hkvVec3((const hkvVec3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_hkvVec3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvVec3_setMin(lua_State* L) {
  int SWIG_arg = 0;
  hkvVec3 *arg1 = (hkvVec3 *) 0 ;
  hkvVec3 *arg2 = 0 ;
  
  SWIG_check_num_args("setMin",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("setMin",1,"hkvVec3 *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("setMin",2,"hkvVec3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("hkvVec3_setMin",1,SWIGTYPE_p_hkvVec3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("hkvVec3_setMin",2,SWIGTYPE_p_hkvVec3);
  }
  
  (arg1)->setMin((hkvVec3 const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvVec3_setMax(lua_State* L) {
  int SWIG_arg = 0;
  hkvVec3 *arg1 = (hkvVec3 *) 0 ;
  hkvVec3 *arg2 = 0 ;
  
  SWIG_check_num_args("setMax",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("setMax",1,"hkvVec3 *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("setMax",2,"hkvVec3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("hkvVec3_setMax",1,SWIGTYPE_p_hkvVec3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("hkvVec3_setMax",2,SWIGTYPE_p_hkvVec3);
  }
  
  (arg1)->setMax((hkvVec3 const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvVec3_clampTo(lua_State* L) {
  int SWIG_arg = 0;
  hkvVec3 *arg1 = (hkvVec3 *) 0 ;
  hkvVec3 *arg2 = 0 ;
  hkvVec3 *arg3 = 0 ;
  
  SWIG_check_num_args("clampTo",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("clampTo",1,"hkvVec3 *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("clampTo",2,"hkvVec3 const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("clampTo",3,"hkvVec3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("hkvVec3_clampTo",1,SWIGTYPE_p_hkvVec3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("hkvVec3_clampTo",2,SWIGTYPE_p_hkvVec3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("hkvVec3_clampTo",3,SWIGTYPE_p_hkvVec3);
  }
  
  (arg1)->clampTo((hkvVec3 const &)*arg2,(hkvVec3 const &)*arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvVec3_setAbs(lua_State* L) {
  int SWIG_arg = 0;
  hkvVec3 *arg1 = (hkvVec3 *) 0 ;
  hkvVec3 *arg2 = 0 ;
  
  SWIG_check_num_args("setAbs",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("setAbs",1,"hkvVec3 *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("setAbs",2,"hkvVec3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("hkvVec3_setAbs",1,SWIGTYPE_p_hkvVec3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("hkvVec3_setAbs",2,SWIGTYPE_p_hkvVec3);
  }
  
  (arg1)->setAbs((hkvVec3 const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvVec3___unm(lua_State* L) {
  int SWIG_arg = 0;
  hkvVec3 *arg1 = (hkvVec3 *) 0 ;
  SwigValueWrapper< hkvVec3 > result;
  
  SWIG_check_num_args("operator -",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("operator -",1,"hkvVec3 const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("hkvVec3___unm",1,SWIGTYPE_p_hkvVec3);
  }
  
  result = ((hkvVec3 const *)arg1)->operator -();
  {
    hkvVec3 * resultptr = new hkvVec3((const hkvVec3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_hkvVec3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvVec3_cross(lua_State* L) {
  int SWIG_arg = 0;
  hkvVec3 *arg1 = (hkvVec3 *) 0 ;
  hkvVec3 *arg2 = 0 ;
  SwigValueWrapper< hkvVec3 > result;
  
  SWIG_check_num_args("cross",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("cross",1,"hkvVec3 const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("cross",2,"hkvVec3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("hkvVec3_cross",1,SWIGTYPE_p_hkvVec3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("hkvVec3_cross",2,SWIGTYPE_p_hkvVec3);
  }
  
  result = ((hkvVec3 const *)arg1)->cross((hkvVec3 const &)*arg2);
  {
    hkvVec3 * resultptr = new hkvVec3((const hkvVec3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_hkvVec3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvVec3_setInterpolate(lua_State* L) {
  int SWIG_arg = 0;
  hkvVec3 *arg1 = (hkvVec3 *) 0 ;
  hkvVec3 *arg2 = 0 ;
  hkvVec3 *arg3 = 0 ;
  float arg4 ;
  
  SWIG_check_num_args("setInterpolate",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("setInterpolate",1,"hkvVec3 *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("setInterpolate",2,"hkvVec3 const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("setInterpolate",3,"hkvVec3 const &");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("setInterpolate",4,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("hkvVec3_setInterpolate",1,SWIGTYPE_p_hkvVec3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("hkvVec3_setInterpolate",2,SWIGTYPE_p_hkvVec3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("hkvVec3_setInterpolate",3,SWIGTYPE_p_hkvVec3);
  }
  
  arg4 = (float)lua_tonumber(L, 4);
  (arg1)->setInterpolate((hkvVec3 const &)*arg2,(hkvVec3 const &)*arg3,arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvVec3_getOrthogonalVector(lua_State* L) {
  int SWIG_arg = 0;
  hkvVec3 *arg1 = (hkvVec3 *) 0 ;
  SwigValueWrapper< hkvVec3 > result;
  
  SWIG_check_num_args("getOrthogonalVector",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("getOrthogonalVector",1,"hkvVec3 const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("hkvVec3_getOrthogonalVector",1,SWIGTYPE_p_hkvVec3);
  }
  
  result = ((hkvVec3 const *)arg1)->getOrthogonalVector();
  {
    hkvVec3 * resultptr = new hkvVec3((const hkvVec3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_hkvVec3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvVec3_reflect(lua_State* L) {
  int SWIG_arg = 0;
  hkvVec3 *arg1 = (hkvVec3 *) 0 ;
  hkvVec3 *arg2 = 0 ;
  
  SWIG_check_num_args("reflect",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("reflect",1,"hkvVec3 *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("reflect",2,"hkvVec3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("hkvVec3_reflect",1,SWIGTYPE_p_hkvVec3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("hkvVec3_reflect",2,SWIGTYPE_p_hkvVec3);
  }
  
  (arg1)->reflect((hkvVec3 const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvVec3_getReflected(lua_State* L) {
  int SWIG_arg = 0;
  hkvVec3 *arg1 = (hkvVec3 *) 0 ;
  hkvVec3 *arg2 = 0 ;
  SwigValueWrapper< hkvVec3 > result;
  
  SWIG_check_num_args("getReflected",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("getReflected",1,"hkvVec3 const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("getReflected",2,"hkvVec3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("hkvVec3_getReflected",1,SWIGTYPE_p_hkvVec3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("hkvVec3_getReflected",2,SWIGTYPE_p_hkvVec3);
  }
  
  result = ((hkvVec3 const *)arg1)->getReflected((hkvVec3 const &)*arg2);
  {
    hkvVec3 * resultptr = new hkvVec3((const hkvVec3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_hkvVec3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvVec3_x_set(lua_State* L) {
  int SWIG_arg = 0;
  hkvVec3 *arg1 = (hkvVec3 *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("x",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("x",1,"hkvVec3 *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("x",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("hkvVec3_x_set",1,SWIGTYPE_p_hkvVec3);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->x = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvVec3_x_get(lua_State* L) {
  int SWIG_arg = 0;
  hkvVec3 *arg1 = (hkvVec3 *) 0 ;
  float result;
  
  SWIG_check_num_args("x",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("x",1,"hkvVec3 *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("hkvVec3_x_get",1,SWIGTYPE_p_hkvVec3);
  }
  
  result = (float) ((arg1)->x);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvVec3_y_set(lua_State* L) {
  int SWIG_arg = 0;
  hkvVec3 *arg1 = (hkvVec3 *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("y",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("y",1,"hkvVec3 *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("y",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("hkvVec3_y_set",1,SWIGTYPE_p_hkvVec3);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->y = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvVec3_y_get(lua_State* L) {
  int SWIG_arg = 0;
  hkvVec3 *arg1 = (hkvVec3 *) 0 ;
  float result;
  
  SWIG_check_num_args("y",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("y",1,"hkvVec3 *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("hkvVec3_y_get",1,SWIGTYPE_p_hkvVec3);
  }
  
  result = (float) ((arg1)->y);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvVec3_z_set(lua_State* L) {
  int SWIG_arg = 0;
  hkvVec3 *arg1 = (hkvVec3 *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("z",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("z",1,"hkvVec3 *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("z",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("hkvVec3_z_set",1,SWIGTYPE_p_hkvVec3);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->z = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvVec3_z_get(lua_State* L) {
  int SWIG_arg = 0;
  hkvVec3 *arg1 = (hkvVec3 *) 0 ;
  float result;
  
  SWIG_check_num_args("z",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("z",1,"hkvVec3 *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("hkvVec3_z_get",1,SWIGTYPE_p_hkvVec3);
  }
  
  result = (float) ((arg1)->z);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_hkvVec3__SWIG_3(lua_State* L) {
  int SWIG_arg = 0;
  bool arg1 ;
  hkvVec3 *result = 0 ;
  
  SWIG_check_num_args("hkvVec3",1,1)
  if(!lua_isboolean(L,1)) SWIG_fail_arg("hkvVec3",1,"bool");
  arg1 = (lua_toboolean(L, 1)!=0);
  result = (hkvVec3 *)new_hkvVec3__SWIG_3(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_hkvVec3,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_hkvVec3__SWIG_4(lua_State* L) {
  int SWIG_arg = 0;
  hkvVec3 *result = 0 ;
  
  SWIG_check_num_args("hkvVec3",0,0)
  result = (hkvVec3 *)new_hkvVec3__SWIG_3();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_hkvVec3,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_hkvVec3(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 0) {
    return _wrap_new_hkvVec3__SWIG_4(L);
  }
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_hkvVec3, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_new_hkvVec3__SWIG_0(L);
    }
  }
  if (argc == 1) {
    int _v;
    {
      _v = lua_isboolean(L,argv[0]);
    }
    if (_v) {
      return _wrap_new_hkvVec3__SWIG_3(L);
    }
  }
  if (argc == 1) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      return _wrap_new_hkvVec3__SWIG_1(L);
    }
  }
  if (argc == 3) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          return _wrap_new_hkvVec3__SWIG_2(L);
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'new_hkvVec3'\n"
    "  Possible C/C++ prototypes are:\n"
    "    hkvVec3(hkvVec3 const &)\n"
    "    hkvVec3(float)\n"
    "    hkvVec3(float,float,float)\n"
    "    hkvVec3(bool)\n"
    "    hkvVec3()\n");
  lua_error(L);return 0;
}


static int _wrap_hkvVec3_makeOrthogonalTo(lua_State* L) {
  int SWIG_arg = 0;
  hkvVec3 *arg1 = (hkvVec3 *) 0 ;
  hkvVec3 *arg2 = 0 ;
  
  SWIG_check_num_args("makeOrthogonalTo",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("makeOrthogonalTo",1,"hkvVec3 *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("makeOrthogonalTo",2,"hkvVec3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("hkvVec3_makeOrthogonalTo",1,SWIGTYPE_p_hkvVec3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("hkvVec3_makeOrthogonalTo",2,SWIGTYPE_p_hkvVec3);
  }
  
  hkvVec3_makeOrthogonalTo(arg1,(hkvVec3 const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvVec3_clone(lua_State* L) {
  int SWIG_arg = 0;
  hkvVec3 *arg1 = (hkvVec3 *) 0 ;
  SwigValueWrapper< hkvVec3 > result;
  
  SWIG_check_num_args("clone",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("clone",1,"hkvVec3 const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("hkvVec3_clone",1,SWIGTYPE_p_hkvVec3);
  }
  
  result = hkvVec3_clone((hkvVec3 const *)arg1);
  {
    hkvVec3 * resultptr = new hkvVec3((const hkvVec3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_hkvVec3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvVec3_compMul__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  hkvVec3 *arg1 = (hkvVec3 *) 0 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  SwigValueWrapper< hkvVec3 > result;
  
  SWIG_check_num_args("compMul",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("compMul",1,"hkvVec3 *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("compMul",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("compMul",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("compMul",4,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("hkvVec3_compMul",1,SWIGTYPE_p_hkvVec3);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4);
  result = hkvVec3_compMul__SWIG_1(arg1,arg2,arg3,arg4);
  {
    hkvVec3 * resultptr = new hkvVec3((const hkvVec3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_hkvVec3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvVec3_compMul(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_hkvVec3, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_hkvVec3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_hkvVec3_compMul__SWIG_0(L);
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_hkvVec3, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_hkvVec3_compMul__SWIG_1(L);
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'hkvVec3_compMul'\n"
    "  Possible C/C++ prototypes are:\n"
    "    compMul(hkvVec3 const *,hkvVec3 const &)\n"
    "    compMul(hkvVec3 *,float,float,float)\n");
  lua_error(L);return 0;
}


static int _wrap_hkvVec3_compDiv__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  hkvVec3 *arg1 = (hkvVec3 *) 0 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  SwigValueWrapper< hkvVec3 > result;
  
  SWIG_check_num_args("compDiv",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("compDiv",1,"hkvVec3 *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("compDiv",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("compDiv",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("compDiv",4,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("hkvVec3_compDiv",1,SWIGTYPE_p_hkvVec3);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4);
  result = hkvVec3_compDiv__SWIG_1(arg1,arg2,arg3,arg4);
  {
    hkvVec3 * resultptr = new hkvVec3((const hkvVec3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_hkvVec3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvVec3_compDiv(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_hkvVec3, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_hkvVec3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_hkvVec3_compDiv__SWIG_0(L);
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_hkvVec3, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_hkvVec3_compDiv__SWIG_1(L);
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'hkvVec3_compDiv'\n"
    "  Possible C/C++ prototypes are:\n"
    "    compDiv(hkvVec3 const *,hkvVec3 const &)\n"
    "    compDiv(hkvVec3 *,float,float,float)\n");
  lua_error(L);return 0;
}


static int _wrap_hkvVec3___len(lua_State* L) {
  int SWIG_arg = 0;
  hkvVec3 *arg1 = (hkvVec3 *) 0 ;
  hkvVec3 *arg2 = (hkvVec3 *) 0 ;
  float result;
  
  SWIG_check_num_args("__len",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("__len",1,"hkvVec3 const *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("__len",2,"hkvVec3 const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("hkvVec3___len",1,SWIGTYPE_p_hkvVec3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("hkvVec3___len",2,SWIGTYPE_p_hkvVec3);
  }
  
  result = (float)hkvVec3___len((hkvVec3 const *)arg1,(hkvVec3 const *)arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvVec3___eq(lua_State* L) {
  int SWIG_arg = 0;
  hkvVec3 *arg1 = (hkvVec3 *) 0 ;
  hkvVec3 *arg2 = (hkvVec3 *) 0 ;
  bool result;
  
  SWIG_check_num_args("__eq",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("__eq",1,"hkvVec3 const *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("__eq",2,"hkvVec3 const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("hkvVec3___eq",1,SWIGTYPE_p_hkvVec3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("hkvVec3___eq",2,SWIGTYPE_p_hkvVec3);
  }
  
  result = (bool)hkvVec3___eq((hkvVec3 const *)arg1,(hkvVec3 const *)arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvVec3___add(lua_State* L) {
  int SWIG_arg = 0;
  hkvVec3 *arg1 = (hkvVec3 *) 0 ;
  hkvVec3 *arg2 = (hkvVec3 *) 0 ;
  SwigValueWrapper< hkvVec3 > result;
  
  SWIG_check_num_args("__add",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("__add",1,"hkvVec3 *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("__add",2,"hkvVec3 const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("hkvVec3___add",1,SWIGTYPE_p_hkvVec3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("hkvVec3___add",2,SWIGTYPE_p_hkvVec3);
  }
  
  result = hkvVec3___add(arg1,(hkvVec3 const *)arg2);
  {
    hkvVec3 * resultptr = new hkvVec3((const hkvVec3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_hkvVec3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvVec3___sub(lua_State* L) {
  int SWIG_arg = 0;
  hkvVec3 *arg1 = (hkvVec3 *) 0 ;
  hkvVec3 *arg2 = (hkvVec3 *) 0 ;
  SwigValueWrapper< hkvVec3 > result;
  
  SWIG_check_num_args("__sub",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("__sub",1,"hkvVec3 *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("__sub",2,"hkvVec3 const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("hkvVec3___sub",1,SWIGTYPE_p_hkvVec3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("hkvVec3___sub",2,SWIGTYPE_p_hkvVec3);
  }
  
  result = hkvVec3___sub(arg1,(hkvVec3 const *)arg2);
  {
    hkvVec3 * resultptr = new hkvVec3((const hkvVec3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_hkvVec3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvVec3___mul(lua_State* L) {
  int SWIG_arg = 0;
  hkvVec3 *arg1 = (hkvVec3 *) 0 ;
  float arg2 ;
  SwigValueWrapper< hkvVec3 > result;
  
  SWIG_check_num_args("__mul",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("__mul",1,"hkvVec3 *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("__mul",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("hkvVec3___mul",1,SWIGTYPE_p_hkvVec3);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  result = hkvVec3___mul(arg1,arg2);
  {
    hkvVec3 * resultptr = new hkvVec3((const hkvVec3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_hkvVec3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvVec3___div(lua_State* L) {
  int SWIG_arg = 0;
  hkvVec3 *arg1 = (hkvVec3 *) 0 ;
  float arg2 ;
  SwigValueWrapper< hkvVec3 > result;
  
  SWIG_check_num_args("__div",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("__div",1,"hkvVec3 *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("__div",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("hkvVec3___div",1,SWIGTYPE_p_hkvVec3);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  result = hkvVec3___div(arg1,arg2);
  {
    hkvVec3 * resultptr = new hkvVec3((const hkvVec3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_hkvVec3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvVec3___getitem(lua_State* L) {
  int SWIG_arg = 0;
  hkvVec3 *arg1 = (hkvVec3 *) 0 ;
  int arg2 ;
  float result;
  
  SWIG_check_num_args("__getitem__",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("__getitem__",1,"hkvVec3 *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("__getitem__",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("hkvVec3___getitem",1,SWIGTYPE_p_hkvVec3);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  result = (float)hkvVec3___getitem__(arg1,arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvVec3___setitem(lua_State* L) {
  int SWIG_arg = 0;
  hkvVec3 *arg1 = (hkvVec3 *) 0 ;
  int arg2 ;
  float arg3 ;
  
  SWIG_check_num_args("__setitem__",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("__setitem__",1,"hkvVec3 *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("__setitem__",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("__setitem__",3,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("hkvVec3___setitem",1,SWIGTYPE_p_hkvVec3);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  hkvVec3___setitem__(arg1,arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_hkvVec3(void *obj) {
hkvVec3 *arg1 = (hkvVec3 *) obj;
delete arg1;
}
static swig_lua_method swig_hkvVec3_methods[] = {
    { "__tostring",hkvVec3_ToString},
    { "__concat",hkvVec3_Concat},
    {"setZero", _wrap_hkvVec3_setZero}, 
    {"set", _wrap_hkvVec3_set}, 
    {"isZero", _wrap_hkvVec3_isZero}, 
    {"isIdentical", _wrap_hkvVec3_isIdentical}, 
    {"isEqual", _wrap_hkvVec3_isEqual}, 
    {"isValid", _wrap_hkvVec3_isValid}, 
    {"isNormalized", _wrap_hkvVec3_isNormalized}, 
    {"dot", _wrap_hkvVec3_dot}, 
    {"getLength", _wrap_hkvVec3_getLength}, 
    {"getLengthSquared", _wrap_hkvVec3_getLengthSquared}, 
    {"getLengthInverse", _wrap_hkvVec3_getLengthInverse}, 
    {"normalize", _wrap_hkvVec3_normalize}, 
    {"getNormalized", _wrap_hkvVec3_getNormalized}, 
    {"normalizeIfNotZero", _wrap_hkvVec3_normalizeIfNotZero}, 
    {"normalizedEnsureUnitLength", _wrap_hkvVec3_normalizedEnsureUnitLength}, 
    {"getDistanceTo", _wrap_hkvVec3_getDistanceTo}, 
    {"getDistanceToSquared", _wrap_hkvVec3_getDistanceToSquared}, 
    {"setLength", _wrap_hkvVec3_setLength}, 
    {"negate", _wrap_hkvVec3_negate}, 
    {"setMin", _wrap_hkvVec3_setMin}, 
    {"setMax", _wrap_hkvVec3_setMax}, 
    {"clampTo", _wrap_hkvVec3_clampTo}, 
    {"setAbs", _wrap_hkvVec3_setAbs}, 
    {"__unm", _wrap_hkvVec3___unm}, 
    {"cross", _wrap_hkvVec3_cross}, 
    {"setInterpolate", _wrap_hkvVec3_setInterpolate}, 
    {"getOrthogonalVector", _wrap_hkvVec3_getOrthogonalVector}, 
    {"reflect", _wrap_hkvVec3_reflect}, 
    {"getReflected", _wrap_hkvVec3_getReflected}, 
    {"makeOrthogonalTo", _wrap_hkvVec3_makeOrthogonalTo}, 
    {"clone", _wrap_hkvVec3_clone}, 
    {"compMul", _wrap_hkvVec3_compMul}, 
    {"compDiv", _wrap_hkvVec3_compDiv}, 
    {"__len", _wrap_hkvVec3___len}, 
    {"__eq", _wrap_hkvVec3___eq}, 
    {"__add", _wrap_hkvVec3___add}, 
    {"__sub", _wrap_hkvVec3___sub}, 
    {"__mul", _wrap_hkvVec3___mul}, 
    {"__div", _wrap_hkvVec3___div}, 
    {"__getitem", _wrap_hkvVec3___getitem}, 
    {"__setitem", _wrap_hkvVec3___setitem}, 
    {0,0}
};
static swig_lua_attribute swig_hkvVec3_attributes[] = {
    { "x", _wrap_hkvVec3_x_get, _wrap_hkvVec3_x_set},
    { "y", _wrap_hkvVec3_y_get, _wrap_hkvVec3_y_set},
    { "z", _wrap_hkvVec3_z_get, _wrap_hkvVec3_z_set},
    {0,0,0}
};
static swig_lua_class *swig_hkvVec3_bases[] = {0};
static const char *swig_hkvVec3_base_names[] = {0};
static swig_lua_class _wrap_class_hkvVec3 = { "hkvVec3", &SWIGTYPE_p_hkvVec3,_wrap_new_hkvVec3, swig_delete_hkvVec3, swig_hkvVec3_methods, swig_hkvVec3_attributes, swig_hkvVec3_bases, swig_hkvVec3_base_names };

static int _wrap_hkvMat3_setIdentity(lua_State* L) {
  int SWIG_arg = 0;
  hkvMat3 *arg1 = (hkvMat3 *) 0 ;
  
  SWIG_check_num_args("setIdentity",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("setIdentity",1,"hkvMat3 *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvMat3,0))){
    SWIG_fail_ptr("hkvMat3_setIdentity",1,SWIGTYPE_p_hkvMat3);
  }
  
  (arg1)->setIdentity();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvMat3_setZero(lua_State* L) {
  int SWIG_arg = 0;
  hkvMat3 *arg1 = (hkvMat3 *) 0 ;
  
  SWIG_check_num_args("setZero",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("setZero",1,"hkvMat3 *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvMat3,0))){
    SWIG_fail_ptr("hkvMat3_setZero",1,SWIGTYPE_p_hkvMat3);
  }
  
  (arg1)->setZero();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvMat3_isZero__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  hkvMat3 *arg1 = (hkvMat3 *) 0 ;
  bool result;
  
  SWIG_check_num_args("isZero",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("isZero",1,"hkvMat3 const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvMat3,0))){
    SWIG_fail_ptr("hkvMat3_isZero",1,SWIGTYPE_p_hkvMat3);
  }
  
  result = (bool)((hkvMat3 const *)arg1)->isZero();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvMat3_isZero__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  hkvMat3 *arg1 = (hkvMat3 *) 0 ;
  float arg2 ;
  bool result;
  
  SWIG_check_num_args("isZero",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("isZero",1,"hkvMat3 const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("isZero",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvMat3,0))){
    SWIG_fail_ptr("hkvMat3_isZero",1,SWIGTYPE_p_hkvMat3);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  result = (bool)((hkvMat3 const *)arg1)->isZero(arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvMat3_isZero(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_hkvMat3, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_hkvMat3_isZero__SWIG_0(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_hkvMat3, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_hkvMat3_isZero__SWIG_1(L);
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'hkvMat3_isZero'\n"
    "  Possible C/C++ prototypes are:\n"
    "    isZero(hkvMat3 const *)\n"
    "    isZero(hkvMat3 const *,float)\n");
  lua_error(L);return 0;
}


static int _wrap_hkvMat3_isIdentity__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  hkvMat3 *arg1 = (hkvMat3 *) 0 ;
  bool result;
  
  SWIG_check_num_args("isIdentity",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("isIdentity",1,"hkvMat3 const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvMat3,0))){
    SWIG_fail_ptr("hkvMat3_isIdentity",1,SWIGTYPE_p_hkvMat3);
  }
  
  result = (bool)((hkvMat3 const *)arg1)->isIdentity();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvMat3_isIdentity__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  hkvMat3 *arg1 = (hkvMat3 *) 0 ;
  float arg2 ;
  bool result;
  
  SWIG_check_num_args("isIdentity",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("isIdentity",1,"hkvMat3 const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("isIdentity",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvMat3,0))){
    SWIG_fail_ptr("hkvMat3_isIdentity",1,SWIGTYPE_p_hkvMat3);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  result = (bool)((hkvMat3 const *)arg1)->isIdentity(arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvMat3_isIdentity(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_hkvMat3, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_hkvMat3_isIdentity__SWIG_0(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_hkvMat3, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_hkvMat3_isIdentity__SWIG_1(L);
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'hkvMat3_isIdentity'\n"
    "  Possible C/C++ prototypes are:\n"
    "    isIdentity(hkvMat3 const *)\n"
    "    isIdentity(hkvMat3 const *,float)\n");
  lua_error(L);return 0;
}


static int _wrap_hkvMat3_setRow__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  hkvMat3 *arg1 = (hkvMat3 *) 0 ;
  unsigned int arg2 ;
  SwigValueWrapper< hkvVec3 > arg3 ;
  hkvVec3 *argp3 ;
  
  SWIG_check_num_args("setRow",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("setRow",1,"hkvMat3 *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("setRow",2,"unsigned int");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("setRow",3,"hkvVec3");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvMat3,0))){
    SWIG_fail_ptr("hkvMat3_setRow",1,SWIGTYPE_p_hkvMat3);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&argp3,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("hkvMat3_setRow",3,SWIGTYPE_p_hkvVec3);
  }
  arg3 = *argp3;
  
  (arg1)->setRow(arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvMat3_setColumn__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  hkvMat3 *arg1 = (hkvMat3 *) 0 ;
  unsigned int arg2 ;
  SwigValueWrapper< hkvVec3 > arg3 ;
  hkvVec3 *argp3 ;
  
  SWIG_check_num_args("setColumn",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("setColumn",1,"hkvMat3 *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("setColumn",2,"unsigned int");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("setColumn",3,"hkvVec3");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvMat3,0))){
    SWIG_fail_ptr("hkvMat3_setColumn",1,SWIGTYPE_p_hkvMat3);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&argp3,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("hkvMat3_setColumn",3,SWIGTYPE_p_hkvVec3);
  }
  arg3 = *argp3;
  
  (arg1)->setColumn(arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvMat3_getRow(lua_State* L) {
  int SWIG_arg = 0;
  hkvMat3 *arg1 = (hkvMat3 *) 0 ;
  unsigned int arg2 ;
  SwigValueWrapper< hkvVec3 > result;
  
  SWIG_check_num_args("getRow",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("getRow",1,"hkvMat3 const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("getRow",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvMat3,0))){
    SWIG_fail_ptr("hkvMat3_getRow",1,SWIGTYPE_p_hkvMat3);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  result = ((hkvMat3 const *)arg1)->getRow(arg2);
  {
    hkvVec3 * resultptr = new hkvVec3((const hkvVec3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_hkvVec3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvMat3_getColumn(lua_State* L) {
  int SWIG_arg = 0;
  hkvMat3 *arg1 = (hkvMat3 *) 0 ;
  unsigned int arg2 ;
  SwigValueWrapper< hkvVec3 > result;
  
  SWIG_check_num_args("getColumn",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("getColumn",1,"hkvMat3 const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("getColumn",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvMat3,0))){
    SWIG_fail_ptr("hkvMat3_getColumn",1,SWIGTYPE_p_hkvMat3);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  result = ((hkvMat3 const *)arg1)->getColumn(arg2);
  {
    hkvVec3 * resultptr = new hkvVec3((const hkvVec3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_hkvVec3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvMat3_getScalingFactors(lua_State* L) {
  int SWIG_arg = 0;
  hkvMat3 *arg1 = (hkvMat3 *) 0 ;
  SwigValueWrapper< hkvVec3 > result;
  
  SWIG_check_num_args("getScalingFactors",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("getScalingFactors",1,"hkvMat3 const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvMat3,0))){
    SWIG_fail_ptr("hkvMat3_getScalingFactors",1,SWIGTYPE_p_hkvMat3);
  }
  
  result = ((hkvMat3 const *)arg1)->getScalingFactors();
  {
    hkvVec3 * resultptr = new hkvVec3((const hkvVec3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_hkvVec3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvMat3_setScalingFactors__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  hkvMat3 *arg1 = (hkvMat3 *) 0 ;
  hkvVec3 *arg2 = 0 ;
  
  SWIG_check_num_args("setScalingFactors",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("setScalingFactors",1,"hkvMat3 *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("setScalingFactors",2,"hkvVec3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvMat3,0))){
    SWIG_fail_ptr("hkvMat3_setScalingFactors",1,SWIGTYPE_p_hkvMat3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("hkvMat3_setScalingFactors",2,SWIGTYPE_p_hkvVec3);
  }
  
  (arg1)->setScalingFactors((hkvVec3 const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvMat3_transpose(lua_State* L) {
  int SWIG_arg = 0;
  hkvMat3 *arg1 = (hkvMat3 *) 0 ;
  
  SWIG_check_num_args("transpose",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("transpose",1,"hkvMat3 *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvMat3,0))){
    SWIG_fail_ptr("hkvMat3_transpose",1,SWIGTYPE_p_hkvMat3);
  }
  
  (arg1)->transpose();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvMat3_getTransposed(lua_State* L) {
  int SWIG_arg = 0;
  hkvMat3 *arg1 = (hkvMat3 *) 0 ;
  SwigValueWrapper< hkvMat3 > result;
  
  SWIG_check_num_args("getTransposed",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("getTransposed",1,"hkvMat3 const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvMat3,0))){
    SWIG_fail_ptr("hkvMat3_getTransposed",1,SWIGTYPE_p_hkvMat3);
  }
  
  result = ((hkvMat3 const *)arg1)->getTransposed();
  {
    hkvMat3 * resultptr = new hkvMat3((const hkvMat3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_hkvMat3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvMat3_invert(lua_State* L) {
  int SWIG_arg = 0;
  hkvMat3 *arg1 = (hkvMat3 *) 0 ;
  bool result;
  
  SWIG_check_num_args("invert",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("invert",1,"hkvMat3 *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvMat3,0))){
    SWIG_fail_ptr("hkvMat3_invert",1,SWIGTYPE_p_hkvMat3);
  }
  
  result = (bool)hkvMat3_invert(arg1);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvMat3_setScalingFactors__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  hkvMat3 *arg1 = (hkvMat3 *) 0 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  
  SWIG_check_num_args("setScalingFactors",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("setScalingFactors",1,"hkvMat3 *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("setScalingFactors",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("setScalingFactors",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("setScalingFactors",4,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvMat3,0))){
    SWIG_fail_ptr("hkvMat3_setScalingFactors",1,SWIGTYPE_p_hkvMat3);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4);
  hkvMat3_setScalingFactors__SWIG_1(arg1,arg2,arg3,arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvMat3_setScalingFactors(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_hkvMat3, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_hkvVec3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_hkvMat3_setScalingFactors__SWIG_0(L);
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_hkvMat3, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_hkvMat3_setScalingFactors__SWIG_1(L);
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'hkvMat3_setScalingFactors'\n"
    "  Possible C/C++ prototypes are:\n"
    "    setScalingFactors(hkvMat3 *,hkvVec3 const &)\n"
    "    setScalingFactors(hkvMat3 *,float,float,float)\n");
  lua_error(L);return 0;
}


static int _wrap_hkvMat3_getElement__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  hkvMat3 *arg1 = (hkvMat3 *) 0 ;
  unsigned int arg2 ;
  bool arg3 ;
  float result;
  
  SWIG_check_num_args("getElement",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("getElement",1,"hkvMat3 *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("getElement",2,"unsigned int");
  if(!lua_isboolean(L,3)) SWIG_fail_arg("getElement",3,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvMat3,0))){
    SWIG_fail_ptr("hkvMat3_getElement",1,SWIGTYPE_p_hkvMat3);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  arg3 = (lua_toboolean(L, 3)!=0);
  result = (float)hkvMat3_getElement__SWIG_0(arg1,arg2,arg3);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvMat3_getElement__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  hkvMat3 *arg1 = (hkvMat3 *) 0 ;
  unsigned int arg2 ;
  float result;
  
  SWIG_check_num_args("getElement",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("getElement",1,"hkvMat3 *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("getElement",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvMat3,0))){
    SWIG_fail_ptr("hkvMat3_getElement",1,SWIGTYPE_p_hkvMat3);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  result = (float)hkvMat3_getElement__SWIG_0(arg1,arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvMat3_getElement(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_hkvMat3, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_hkvMat3_getElement__SWIG_1(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_hkvMat3, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isboolean(L,argv[2]);
        }
        if (_v) {
          return _wrap_hkvMat3_getElement__SWIG_0(L);
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'hkvMat3_getElement'\n"
    "  Possible C/C++ prototypes are:\n"
    "    getElement(hkvMat3 *,unsigned int,bool)\n"
    "    getElement(hkvMat3 *,unsigned int)\n");
  lua_error(L);return 0;
}


static int _wrap_hkvMat3_setElement__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  hkvMat3 *arg1 = (hkvMat3 *) 0 ;
  unsigned int arg2 ;
  float arg3 ;
  bool arg4 ;
  
  SWIG_check_num_args("setElement",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("setElement",1,"hkvMat3 *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("setElement",2,"unsigned int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("setElement",3,"float");
  if(!lua_isboolean(L,4)) SWIG_fail_arg("setElement",4,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvMat3,0))){
    SWIG_fail_ptr("hkvMat3_setElement",1,SWIGTYPE_p_hkvMat3);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (lua_toboolean(L, 4)!=0);
  hkvMat3_setElement__SWIG_0(arg1,arg2,arg3,arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvMat3_setElement__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  hkvMat3 *arg1 = (hkvMat3 *) 0 ;
  unsigned int arg2 ;
  float arg3 ;
  
  SWIG_check_num_args("setElement",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("setElement",1,"hkvMat3 *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("setElement",2,"unsigned int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("setElement",3,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvMat3,0))){
    SWIG_fail_ptr("hkvMat3_setElement",1,SWIGTYPE_p_hkvMat3);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  hkvMat3_setElement__SWIG_0(arg1,arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvMat3_setElement(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_hkvMat3, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          return _wrap_hkvMat3_setElement__SWIG_1(L);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_hkvMat3, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isboolean(L,argv[3]);
          }
          if (_v) {
            return _wrap_hkvMat3_setElement__SWIG_0(L);
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'hkvMat3_setElement'\n"
    "  Possible C/C++ prototypes are:\n"
    "    setElement(hkvMat3 *,unsigned int,float,bool)\n"
    "    setElement(hkvMat3 *,unsigned int,float)\n");
  lua_error(L);return 0;
}


static int _wrap_hkvMat3_setRow__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  hkvMat3 *arg1 = (hkvMat3 *) 0 ;
  unsigned int arg2 ;
  float arg3 ;
  float arg4 ;
  float arg5 ;
  
  SWIG_check_num_args("setRow",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("setRow",1,"hkvMat3 *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("setRow",2,"unsigned int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("setRow",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("setRow",4,"float");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("setRow",5,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvMat3,0))){
    SWIG_fail_ptr("hkvMat3_setRow",1,SWIGTYPE_p_hkvMat3);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4);
  arg5 = (float)lua_tonumber(L, 5);
  hkvMat3_setRow__SWIG_1(arg1,arg2,arg3,arg4,arg5);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvMat3_setRow(lua_State* L) {
  int argc;
  int argv[6]={
    1,2,3,4,5,6
  };
  
  argc = lua_gettop(L);
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_hkvMat3, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_hkvVec3, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          return _wrap_hkvMat3_setRow__SWIG_0(L);
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_hkvMat3, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isnumber(L,argv[4]);
            }
            if (_v) {
              return _wrap_hkvMat3_setRow__SWIG_1(L);
            }
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'hkvMat3_setRow'\n"
    "  Possible C/C++ prototypes are:\n"
    "    setRow(hkvMat3 *,unsigned int,hkvVec3)\n"
    "    setRow(hkvMat3 *,unsigned int,float,float,float)\n");
  lua_error(L);return 0;
}


static int _wrap_hkvMat3_setColumn__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  hkvMat3 *arg1 = (hkvMat3 *) 0 ;
  unsigned int arg2 ;
  float arg3 ;
  float arg4 ;
  float arg5 ;
  
  SWIG_check_num_args("setColumn",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("setColumn",1,"hkvMat3 *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("setColumn",2,"unsigned int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("setColumn",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("setColumn",4,"float");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("setColumn",5,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvMat3,0))){
    SWIG_fail_ptr("hkvMat3_setColumn",1,SWIGTYPE_p_hkvMat3);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4);
  arg5 = (float)lua_tonumber(L, 5);
  hkvMat3_setColumn__SWIG_1(arg1,arg2,arg3,arg4,arg5);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvMat3_setColumn(lua_State* L) {
  int argc;
  int argv[6]={
    1,2,3,4,5,6
  };
  
  argc = lua_gettop(L);
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_hkvMat3, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_hkvVec3, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          return _wrap_hkvMat3_setColumn__SWIG_0(L);
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_hkvMat3, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isnumber(L,argv[4]);
            }
            if (_v) {
              return _wrap_hkvMat3_setColumn__SWIG_1(L);
            }
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'hkvMat3_setColumn'\n"
    "  Possible C/C++ prototypes are:\n"
    "    setColumn(hkvMat3 *,unsigned int,hkvVec3)\n"
    "    setColumn(hkvMat3 *,unsigned int,float,float,float)\n");
  lua_error(L);return 0;
}


static int _wrap_hkvMat3_setAxis__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  hkvMat3 *arg1 = (hkvMat3 *) 0 ;
  unsigned int arg2 ;
  float arg3 ;
  float arg4 ;
  float arg5 ;
  
  SWIG_check_num_args("setAxis",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("setAxis",1,"hkvMat3 *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("setAxis",2,"unsigned int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("setAxis",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("setAxis",4,"float");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("setAxis",5,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvMat3,0))){
    SWIG_fail_ptr("hkvMat3_setAxis",1,SWIGTYPE_p_hkvMat3);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4);
  arg5 = (float)lua_tonumber(L, 5);
  hkvMat3_setAxis__SWIG_0(arg1,arg2,arg3,arg4,arg5);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvMat3_setScalingMatrix__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  hkvMat3 *arg1 = (hkvMat3 *) 0 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  
  SWIG_check_num_args("setScalingMatrix",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("setScalingMatrix",1,"hkvMat3 *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("setScalingMatrix",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("setScalingMatrix",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("setScalingMatrix",4,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvMat3,0))){
    SWIG_fail_ptr("hkvMat3_setScalingMatrix",1,SWIGTYPE_p_hkvMat3);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4);
  hkvMat3_setScalingMatrix__SWIG_0(arg1,arg2,arg3,arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvMat3_setRotationMatrix(lua_State* L) {
  int SWIG_arg = 0;
  hkvMat3 *arg1 = (hkvMat3 *) 0 ;
  hkvVec3 *arg2 = (hkvVec3 *) 0 ;
  float arg3 ;
  
  SWIG_check_num_args("setRotationMatrix",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("setRotationMatrix",1,"hkvMat3 *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("setRotationMatrix",2,"hkvVec3 const *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("setRotationMatrix",3,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvMat3,0))){
    SWIG_fail_ptr("hkvMat3_setRotationMatrix",1,SWIGTYPE_p_hkvMat3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("hkvMat3_setRotationMatrix",2,SWIGTYPE_p_hkvVec3);
  }
  
  arg3 = (float)lua_tonumber(L, 3);
  hkvMat3_setRotationMatrix(arg1,(hkvVec3 const *)arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvMat3_setLookInDirectionMatrix__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  hkvMat3 *arg1 = (hkvMat3 *) 0 ;
  SwigValueWrapper< hkvVec3 > arg2 ;
  SwigValueWrapper< hkvVec3 > arg3 ;
  hkvVec3 *argp2 ;
  hkvVec3 *argp3 ;
  
  SWIG_check_num_args("setLookInDirectionMatrix",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("setLookInDirectionMatrix",1,"hkvMat3 *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("setLookInDirectionMatrix",2,"hkvVec3");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("setLookInDirectionMatrix",3,"hkvVec3");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvMat3,0))){
    SWIG_fail_ptr("hkvMat3_setLookInDirectionMatrix",1,SWIGTYPE_p_hkvMat3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("hkvMat3_setLookInDirectionMatrix",2,SWIGTYPE_p_hkvVec3);
  }
  arg2 = *argp2;
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&argp3,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("hkvMat3_setLookInDirectionMatrix",3,SWIGTYPE_p_hkvVec3);
  }
  arg3 = *argp3;
  
  (arg1)->setLookInDirectionMatrix(arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvMat3_setLookInDirectionMatrix__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  hkvMat3 *arg1 = (hkvMat3 *) 0 ;
  SwigValueWrapper< hkvVec3 > arg2 ;
  hkvVec3 *argp2 ;
  
  SWIG_check_num_args("setLookInDirectionMatrix",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("setLookInDirectionMatrix",1,"hkvMat3 *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("setLookInDirectionMatrix",2,"hkvVec3");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvMat3,0))){
    SWIG_fail_ptr("hkvMat3_setLookInDirectionMatrix",1,SWIGTYPE_p_hkvMat3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("hkvMat3_setLookInDirectionMatrix",2,SWIGTYPE_p_hkvVec3);
  }
  arg2 = *argp2;
  
  (arg1)->setLookInDirectionMatrix(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvMat3_setLookInDirectionMatrix(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_hkvMat3, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_hkvVec3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_hkvMat3_setLookInDirectionMatrix__SWIG_1(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_hkvMat3, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_hkvVec3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_hkvVec3, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          return _wrap_hkvMat3_setLookInDirectionMatrix__SWIG_0(L);
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'hkvMat3_setLookInDirectionMatrix'\n"
    "  Possible C/C++ prototypes are:\n"
    "    setLookInDirectionMatrix(hkvMat3 *,hkvVec3,hkvVec3)\n"
    "    setLookInDirectionMatrix(hkvMat3 *,hkvVec3)\n");
  lua_error(L);return 0;
}


static int _wrap_hkvMat3_getAxis(lua_State* L) {
  int SWIG_arg = 0;
  hkvMat3 *arg1 = (hkvMat3 *) 0 ;
  unsigned int arg2 ;
  SwigValueWrapper< hkvVec3 > result;
  
  SWIG_check_num_args("getAxis",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("getAxis",1,"hkvMat3 const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("getAxis",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvMat3,0))){
    SWIG_fail_ptr("hkvMat3_getAxis",1,SWIGTYPE_p_hkvMat3);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  result = ((hkvMat3 const *)arg1)->getAxis(arg2);
  {
    hkvVec3 * resultptr = new hkvVec3((const hkvVec3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_hkvVec3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvMat3_setAxis__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  hkvMat3 *arg1 = (hkvMat3 *) 0 ;
  unsigned int arg2 ;
  hkvVec3 *arg3 = 0 ;
  
  SWIG_check_num_args("setAxis",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("setAxis",1,"hkvMat3 *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("setAxis",2,"unsigned int");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("setAxis",3,"hkvVec3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvMat3,0))){
    SWIG_fail_ptr("hkvMat3_setAxis",1,SWIGTYPE_p_hkvMat3);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("hkvMat3_setAxis",3,SWIGTYPE_p_hkvVec3);
  }
  
  (arg1)->setAxis(arg2,(hkvVec3 const &)*arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvMat3_setAxis(lua_State* L) {
  int argc;
  int argv[6]={
    1,2,3,4,5,6
  };
  
  argc = lua_gettop(L);
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_hkvMat3, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_hkvVec3, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          return _wrap_hkvMat3_setAxis__SWIG_1(L);
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_hkvMat3, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isnumber(L,argv[4]);
            }
            if (_v) {
              return _wrap_hkvMat3_setAxis__SWIG_0(L);
            }
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'hkvMat3_setAxis'\n"
    "  Possible C/C++ prototypes are:\n"
    "    setAxis(hkvMat3 *,unsigned int,float,float,float)\n"
    "    setAxis(hkvMat3 *,unsigned int,hkvVec3 const &)\n");
  lua_error(L);return 0;
}


static int _wrap_hkvMat3_setScalingMatrix__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  hkvMat3 *arg1 = (hkvMat3 *) 0 ;
  hkvVec3 *arg2 = 0 ;
  
  SWIG_check_num_args("setScalingMatrix",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("setScalingMatrix",1,"hkvMat3 *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("setScalingMatrix",2,"hkvVec3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvMat3,0))){
    SWIG_fail_ptr("hkvMat3_setScalingMatrix",1,SWIGTYPE_p_hkvMat3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("hkvMat3_setScalingMatrix",2,SWIGTYPE_p_hkvVec3);
  }
  
  (arg1)->setScalingMatrix((hkvVec3 const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvMat3_setScalingMatrix(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_hkvMat3, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_hkvVec3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_hkvMat3_setScalingMatrix__SWIG_1(L);
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_hkvMat3, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_hkvMat3_setScalingMatrix__SWIG_0(L);
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'hkvMat3_setScalingMatrix'\n"
    "  Possible C/C++ prototypes are:\n"
    "    setScalingMatrix(hkvMat3 *,float,float,float)\n"
    "    setScalingMatrix(hkvMat3 *,hkvVec3 const &)\n");
  lua_error(L);return 0;
}


static int _wrap_hkvMat3_setRotationMatrixX(lua_State* L) {
  int SWIG_arg = 0;
  hkvMat3 *arg1 = (hkvMat3 *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("setRotationMatrixX",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("setRotationMatrixX",1,"hkvMat3 *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("setRotationMatrixX",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvMat3,0))){
    SWIG_fail_ptr("hkvMat3_setRotationMatrixX",1,SWIGTYPE_p_hkvMat3);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->setRotationMatrixX(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvMat3_setRotationMatrixY(lua_State* L) {
  int SWIG_arg = 0;
  hkvMat3 *arg1 = (hkvMat3 *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("setRotationMatrixY",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("setRotationMatrixY",1,"hkvMat3 *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("setRotationMatrixY",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvMat3,0))){
    SWIG_fail_ptr("hkvMat3_setRotationMatrixY",1,SWIGTYPE_p_hkvMat3);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->setRotationMatrixY(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvMat3_setRotationMatrixZ(lua_State* L) {
  int SWIG_arg = 0;
  hkvMat3 *arg1 = (hkvMat3 *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("setRotationMatrixZ",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("setRotationMatrixZ",1,"hkvMat3 *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("setRotationMatrixZ",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvMat3,0))){
    SWIG_fail_ptr("hkvMat3_setRotationMatrixZ",1,SWIGTYPE_p_hkvMat3);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->setRotationMatrixZ(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvMat3_isIdentical(lua_State* L) {
  int SWIG_arg = 0;
  hkvMat3 *arg1 = (hkvMat3 *) 0 ;
  hkvMat3 *arg2 = 0 ;
  bool result;
  
  SWIG_check_num_args("isIdentical",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("isIdentical",1,"hkvMat3 const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("isIdentical",2,"hkvMat3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvMat3,0))){
    SWIG_fail_ptr("hkvMat3_isIdentical",1,SWIGTYPE_p_hkvMat3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_hkvMat3,0))){
    SWIG_fail_ptr("hkvMat3_isIdentical",2,SWIGTYPE_p_hkvMat3);
  }
  
  result = (bool)((hkvMat3 const *)arg1)->isIdentical((hkvMat3 const &)*arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvMat3_isEqual(lua_State* L) {
  int SWIG_arg = 0;
  hkvMat3 *arg1 = (hkvMat3 *) 0 ;
  hkvMat3 *arg2 = 0 ;
  float arg3 ;
  bool result;
  
  SWIG_check_num_args("isEqual",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("isEqual",1,"hkvMat3 const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("isEqual",2,"hkvMat3 const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("isEqual",3,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvMat3,0))){
    SWIG_fail_ptr("hkvMat3_isEqual",1,SWIGTYPE_p_hkvMat3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_hkvMat3,0))){
    SWIG_fail_ptr("hkvMat3_isEqual",2,SWIGTYPE_p_hkvMat3);
  }
  
  arg3 = (float)lua_tonumber(L, 3);
  result = (bool)((hkvMat3 const *)arg1)->isEqual((hkvMat3 const &)*arg2,arg3);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvMat3_transformDirection(lua_State* L) {
  int SWIG_arg = 0;
  hkvMat3 *arg1 = (hkvMat3 *) 0 ;
  hkvVec3 *arg2 = 0 ;
  SwigValueWrapper< hkvVec3 > result;
  
  SWIG_check_num_args("transformDirection",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("transformDirection",1,"hkvMat3 const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("transformDirection",2,"hkvVec3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvMat3,0))){
    SWIG_fail_ptr("hkvMat3_transformDirection",1,SWIGTYPE_p_hkvMat3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("hkvMat3_transformDirection",2,SWIGTYPE_p_hkvVec3);
  }
  
  result = ((hkvMat3 const *)arg1)->transformDirection((hkvVec3 const &)*arg2);
  {
    hkvVec3 * resultptr = new hkvVec3((const hkvVec3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_hkvVec3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvMat3_multiply(lua_State* L) {
  int SWIG_arg = 0;
  hkvMat3 *arg1 = (hkvMat3 *) 0 ;
  hkvMat3 *arg2 = 0 ;
  SwigValueWrapper< hkvMat3 > result;
  
  SWIG_check_num_args("multiply",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("multiply",1,"hkvMat3 const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("multiply",2,"hkvMat3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvMat3,0))){
    SWIG_fail_ptr("hkvMat3_multiply",1,SWIGTYPE_p_hkvMat3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_hkvMat3,0))){
    SWIG_fail_ptr("hkvMat3_multiply",2,SWIGTYPE_p_hkvMat3);
  }
  
  result = ((hkvMat3 const *)arg1)->multiply((hkvMat3 const &)*arg2);
  {
    hkvMat3 * resultptr = new hkvMat3((const hkvMat3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_hkvMat3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvMat3_multiplyReverse(lua_State* L) {
  int SWIG_arg = 0;
  hkvMat3 *arg1 = (hkvMat3 *) 0 ;
  hkvMat3 *arg2 = 0 ;
  SwigValueWrapper< hkvMat3 > result;
  
  SWIG_check_num_args("multiplyReverse",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("multiplyReverse",1,"hkvMat3 const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("multiplyReverse",2,"hkvMat3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvMat3,0))){
    SWIG_fail_ptr("hkvMat3_multiplyReverse",1,SWIGTYPE_p_hkvMat3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_hkvMat3,0))){
    SWIG_fail_ptr("hkvMat3_multiplyReverse",2,SWIGTYPE_p_hkvMat3);
  }
  
  result = ((hkvMat3 const *)arg1)->multiplyReverse((hkvMat3 const &)*arg2);
  {
    hkvMat3 * resultptr = new hkvMat3((const hkvMat3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_hkvMat3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_hkvMat3__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  bool arg1 ;
  hkvMat3 *result = 0 ;
  
  SWIG_check_num_args("hkvMat3",1,1)
  if(!lua_isboolean(L,1)) SWIG_fail_arg("hkvMat3",1,"bool");
  arg1 = (lua_toboolean(L, 1)!=0);
  result = (hkvMat3 *)new_hkvMat3__SWIG_0(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_hkvMat3,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_hkvMat3__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  hkvMat3 *result = 0 ;
  
  SWIG_check_num_args("hkvMat3",0,0)
  result = (hkvMat3 *)new_hkvMat3__SWIG_0();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_hkvMat3,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_hkvMat3__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  hkvMat3 *arg1 = (hkvMat3 *) 0 ;
  hkvMat3 *result = 0 ;
  
  SWIG_check_num_args("hkvMat3",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("hkvMat3",1,"hkvMat3 const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvMat3,0))){
    SWIG_fail_ptr("new_hkvMat3",1,SWIGTYPE_p_hkvMat3);
  }
  
  result = (hkvMat3 *)new_hkvMat3__SWIG_2((hkvMat3 const *)arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_hkvMat3,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_hkvMat3__SWIG_3(lua_State* L) {
  int SWIG_arg = 0;
  float arg1 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  float arg5 ;
  float arg6 ;
  float arg7 ;
  float arg8 ;
  float arg9 ;
  bool arg10 ;
  hkvMat3 *result = 0 ;
  
  SWIG_check_num_args("hkvMat3",10,10)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("hkvMat3",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("hkvMat3",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("hkvMat3",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("hkvMat3",4,"float");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("hkvMat3",5,"float");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("hkvMat3",6,"float");
  if(!lua_isnumber(L,7)) SWIG_fail_arg("hkvMat3",7,"float");
  if(!lua_isnumber(L,8)) SWIG_fail_arg("hkvMat3",8,"float");
  if(!lua_isnumber(L,9)) SWIG_fail_arg("hkvMat3",9,"float");
  if(!lua_isboolean(L,10)) SWIG_fail_arg("hkvMat3",10,"bool");
  arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4);
  arg5 = (float)lua_tonumber(L, 5);
  arg6 = (float)lua_tonumber(L, 6);
  arg7 = (float)lua_tonumber(L, 7);
  arg8 = (float)lua_tonumber(L, 8);
  arg9 = (float)lua_tonumber(L, 9);
  arg10 = (lua_toboolean(L, 10)!=0);
  result = (hkvMat3 *)new_hkvMat3__SWIG_3(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_hkvMat3,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_hkvMat3__SWIG_4(lua_State* L) {
  int SWIG_arg = 0;
  float arg1 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  float arg5 ;
  float arg6 ;
  float arg7 ;
  float arg8 ;
  float arg9 ;
  hkvMat3 *result = 0 ;
  
  SWIG_check_num_args("hkvMat3",9,9)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("hkvMat3",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("hkvMat3",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("hkvMat3",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("hkvMat3",4,"float");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("hkvMat3",5,"float");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("hkvMat3",6,"float");
  if(!lua_isnumber(L,7)) SWIG_fail_arg("hkvMat3",7,"float");
  if(!lua_isnumber(L,8)) SWIG_fail_arg("hkvMat3",8,"float");
  if(!lua_isnumber(L,9)) SWIG_fail_arg("hkvMat3",9,"float");
  arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4);
  arg5 = (float)lua_tonumber(L, 5);
  arg6 = (float)lua_tonumber(L, 6);
  arg7 = (float)lua_tonumber(L, 7);
  arg8 = (float)lua_tonumber(L, 8);
  arg9 = (float)lua_tonumber(L, 9);
  result = (hkvMat3 *)new_hkvMat3__SWIG_3(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_hkvMat3,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_hkvMat3(lua_State* L) {
  int argc;
  int argv[11]={
    1,2,3,4,5,6,7,8,9,10,11
  };
  
  argc = lua_gettop(L);
  if (argc == 0) {
    return _wrap_new_hkvMat3__SWIG_1(L);
  }
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_hkvMat3, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_new_hkvMat3__SWIG_2(L);
    }
  }
  if (argc == 1) {
    int _v;
    {
      _v = lua_isboolean(L,argv[0]);
    }
    if (_v) {
      return _wrap_new_hkvMat3__SWIG_0(L);
    }
  }
  if (argc == 9) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isnumber(L,argv[4]);
            }
            if (_v) {
              {
                _v = lua_isnumber(L,argv[5]);
              }
              if (_v) {
                {
                  _v = lua_isnumber(L,argv[6]);
                }
                if (_v) {
                  {
                    _v = lua_isnumber(L,argv[7]);
                  }
                  if (_v) {
                    {
                      _v = lua_isnumber(L,argv[8]);
                    }
                    if (_v) {
                      return _wrap_new_hkvMat3__SWIG_4(L);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  if (argc == 10) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isnumber(L,argv[4]);
            }
            if (_v) {
              {
                _v = lua_isnumber(L,argv[5]);
              }
              if (_v) {
                {
                  _v = lua_isnumber(L,argv[6]);
                }
                if (_v) {
                  {
                    _v = lua_isnumber(L,argv[7]);
                  }
                  if (_v) {
                    {
                      _v = lua_isnumber(L,argv[8]);
                    }
                    if (_v) {
                      {
                        _v = lua_isboolean(L,argv[9]);
                      }
                      if (_v) {
                        return _wrap_new_hkvMat3__SWIG_3(L);
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'new_hkvMat3'\n"
    "  Possible C/C++ prototypes are:\n"
    "    hkvMat3(bool)\n"
    "    hkvMat3()\n"
    "    hkvMat3(hkvMat3 const *)\n"
    "    hkvMat3(float,float,float,float,float,float,float,float,float,bool)\n"
    "    hkvMat3(float,float,float,float,float,float,float,float,float)\n");
  lua_error(L);return 0;
}


static int _wrap_hkvMat3_set__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  hkvMat3 *arg1 = (hkvMat3 *) 0 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  float arg5 ;
  float arg6 ;
  float arg7 ;
  float arg8 ;
  float arg9 ;
  float arg10 ;
  bool arg11 ;
  
  SWIG_check_num_args("set",11,11)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("set",1,"hkvMat3 *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("set",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("set",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("set",4,"float");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("set",5,"float");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("set",6,"float");
  if(!lua_isnumber(L,7)) SWIG_fail_arg("set",7,"float");
  if(!lua_isnumber(L,8)) SWIG_fail_arg("set",8,"float");
  if(!lua_isnumber(L,9)) SWIG_fail_arg("set",9,"float");
  if(!lua_isnumber(L,10)) SWIG_fail_arg("set",10,"float");
  if(!lua_isboolean(L,11)) SWIG_fail_arg("set",11,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvMat3,0))){
    SWIG_fail_ptr("hkvMat3_set",1,SWIGTYPE_p_hkvMat3);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4);
  arg5 = (float)lua_tonumber(L, 5);
  arg6 = (float)lua_tonumber(L, 6);
  arg7 = (float)lua_tonumber(L, 7);
  arg8 = (float)lua_tonumber(L, 8);
  arg9 = (float)lua_tonumber(L, 9);
  arg10 = (float)lua_tonumber(L, 10);
  arg11 = (lua_toboolean(L, 11)!=0);
  hkvMat3_set__SWIG_0(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvMat3_set__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  hkvMat3 *arg1 = (hkvMat3 *) 0 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  float arg5 ;
  float arg6 ;
  float arg7 ;
  float arg8 ;
  float arg9 ;
  float arg10 ;
  
  SWIG_check_num_args("set",10,10)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("set",1,"hkvMat3 *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("set",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("set",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("set",4,"float");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("set",5,"float");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("set",6,"float");
  if(!lua_isnumber(L,7)) SWIG_fail_arg("set",7,"float");
  if(!lua_isnumber(L,8)) SWIG_fail_arg("set",8,"float");
  if(!lua_isnumber(L,9)) SWIG_fail_arg("set",9,"float");
  if(!lua_isnumber(L,10)) SWIG_fail_arg("set",10,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvMat3,0))){
    SWIG_fail_ptr("hkvMat3_set",1,SWIGTYPE_p_hkvMat3);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4);
  arg5 = (float)lua_tonumber(L, 5);
  arg6 = (float)lua_tonumber(L, 6);
  arg7 = (float)lua_tonumber(L, 7);
  arg8 = (float)lua_tonumber(L, 8);
  arg9 = (float)lua_tonumber(L, 9);
  arg10 = (float)lua_tonumber(L, 10);
  hkvMat3_set__SWIG_0(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvMat3_set(lua_State* L) {
  int argc;
  int argv[12]={
    1,2,3,4,5,6,7,8,9,10,11,12
  };
  
  argc = lua_gettop(L);
  if (argc == 10) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_hkvMat3, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isnumber(L,argv[4]);
            }
            if (_v) {
              {
                _v = lua_isnumber(L,argv[5]);
              }
              if (_v) {
                {
                  _v = lua_isnumber(L,argv[6]);
                }
                if (_v) {
                  {
                    _v = lua_isnumber(L,argv[7]);
                  }
                  if (_v) {
                    {
                      _v = lua_isnumber(L,argv[8]);
                    }
                    if (_v) {
                      {
                        _v = lua_isnumber(L,argv[9]);
                      }
                      if (_v) {
                        return _wrap_hkvMat3_set__SWIG_1(L);
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  if (argc == 11) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_hkvMat3, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isnumber(L,argv[4]);
            }
            if (_v) {
              {
                _v = lua_isnumber(L,argv[5]);
              }
              if (_v) {
                {
                  _v = lua_isnumber(L,argv[6]);
                }
                if (_v) {
                  {
                    _v = lua_isnumber(L,argv[7]);
                  }
                  if (_v) {
                    {
                      _v = lua_isnumber(L,argv[8]);
                    }
                    if (_v) {
                      {
                        _v = lua_isnumber(L,argv[9]);
                      }
                      if (_v) {
                        {
                          _v = lua_isboolean(L,argv[10]);
                        }
                        if (_v) {
                          return _wrap_hkvMat3_set__SWIG_0(L);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'hkvMat3_set'\n"
    "  Possible C/C++ prototypes are:\n"
    "    set(hkvMat3 *,float,float,float,float,float,float,float,float,float,bool)\n"
    "    set(hkvMat3 *,float,float,float,float,float,float,float,float,float)\n");
  lua_error(L);return 0;
}


static int _wrap_hkvMat3_clone(lua_State* L) {
  int SWIG_arg = 0;
  hkvMat3 *arg1 = (hkvMat3 *) 0 ;
  SwigValueWrapper< hkvMat3 > result;
  
  SWIG_check_num_args("clone",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("clone",1,"hkvMat3 const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvMat3,0))){
    SWIG_fail_ptr("hkvMat3_clone",1,SWIGTYPE_p_hkvMat3);
  }
  
  result = hkvMat3_clone((hkvMat3 const *)arg1);
  {
    hkvMat3 * resultptr = new hkvMat3((const hkvMat3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_hkvMat3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvMat3___eq(lua_State* L) {
  int SWIG_arg = 0;
  hkvMat3 *arg1 = (hkvMat3 *) 0 ;
  hkvMat3 *arg2 = (hkvMat3 *) 0 ;
  bool result;
  
  SWIG_check_num_args("__eq",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("__eq",1,"hkvMat3 const *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("__eq",2,"hkvMat3 const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvMat3,0))){
    SWIG_fail_ptr("hkvMat3___eq",1,SWIGTYPE_p_hkvMat3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_hkvMat3,0))){
    SWIG_fail_ptr("hkvMat3___eq",2,SWIGTYPE_p_hkvMat3);
  }
  
  result = (bool)hkvMat3___eq((hkvMat3 const *)arg1,(hkvMat3 const *)arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvMat3___add(lua_State* L) {
  int SWIG_arg = 0;
  hkvMat3 *arg1 = (hkvMat3 *) 0 ;
  hkvMat3 *arg2 = (hkvMat3 *) 0 ;
  SwigValueWrapper< hkvMat3 > result;
  
  SWIG_check_num_args("__add",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("__add",1,"hkvMat3 *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("__add",2,"hkvMat3 const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvMat3,0))){
    SWIG_fail_ptr("hkvMat3___add",1,SWIGTYPE_p_hkvMat3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_hkvMat3,0))){
    SWIG_fail_ptr("hkvMat3___add",2,SWIGTYPE_p_hkvMat3);
  }
  
  result = hkvMat3___add(arg1,(hkvMat3 const *)arg2);
  {
    hkvMat3 * resultptr = new hkvMat3((const hkvMat3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_hkvMat3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvMat3___sub(lua_State* L) {
  int SWIG_arg = 0;
  hkvMat3 *arg1 = (hkvMat3 *) 0 ;
  hkvMat3 *arg2 = (hkvMat3 *) 0 ;
  SwigValueWrapper< hkvMat3 > result;
  
  SWIG_check_num_args("__sub",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("__sub",1,"hkvMat3 *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("__sub",2,"hkvMat3 const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvMat3,0))){
    SWIG_fail_ptr("hkvMat3___sub",1,SWIGTYPE_p_hkvMat3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_hkvMat3,0))){
    SWIG_fail_ptr("hkvMat3___sub",2,SWIGTYPE_p_hkvMat3);
  }
  
  result = hkvMat3___sub(arg1,(hkvMat3 const *)arg2);
  {
    hkvMat3 * resultptr = new hkvMat3((const hkvMat3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_hkvMat3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvMat3___mul__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  hkvMat3 *arg1 = (hkvMat3 *) 0 ;
  hkvMat3 *arg2 = (hkvMat3 *) 0 ;
  SwigValueWrapper< hkvMat3 > result;
  
  SWIG_check_num_args("__mul",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("__mul",1,"hkvMat3 *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("__mul",2,"hkvMat3 const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvMat3,0))){
    SWIG_fail_ptr("hkvMat3___mul",1,SWIGTYPE_p_hkvMat3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_hkvMat3,0))){
    SWIG_fail_ptr("hkvMat3___mul",2,SWIGTYPE_p_hkvMat3);
  }
  
  result = hkvMat3___mul__SWIG_0(arg1,(hkvMat3 const *)arg2);
  {
    hkvMat3 * resultptr = new hkvMat3((const hkvMat3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_hkvMat3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvMat3___mul__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  hkvMat3 *arg1 = (hkvMat3 *) 0 ;
  float arg2 ;
  SwigValueWrapper< hkvMat3 > result;
  
  SWIG_check_num_args("__mul",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("__mul",1,"hkvMat3 *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("__mul",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvMat3,0))){
    SWIG_fail_ptr("hkvMat3___mul",1,SWIGTYPE_p_hkvMat3);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  result = hkvMat3___mul__SWIG_1(arg1,arg2);
  {
    hkvMat3 * resultptr = new hkvMat3((const hkvMat3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_hkvMat3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvMat3___mul(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_hkvMat3, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_hkvMat3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_hkvMat3___mul__SWIG_0(L);
      }
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_hkvMat3, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_hkvMat3___mul__SWIG_1(L);
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'hkvMat3___mul'\n"
    "  Possible C/C++ prototypes are:\n"
    "    __mul(hkvMat3 *,hkvMat3 const *)\n"
    "    __mul(hkvMat3 *,float)\n");
  lua_error(L);return 0;
}


static int _wrap_hkvMat3___div(lua_State* L) {
  int SWIG_arg = 0;
  hkvMat3 *arg1 = (hkvMat3 *) 0 ;
  float arg2 ;
  SwigValueWrapper< hkvMat3 > result;
  
  SWIG_check_num_args("__div",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("__div",1,"hkvMat3 *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("__div",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvMat3,0))){
    SWIG_fail_ptr("hkvMat3___div",1,SWIGTYPE_p_hkvMat3);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  result = hkvMat3___div(arg1,arg2);
  {
    hkvMat3 * resultptr = new hkvMat3((const hkvMat3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_hkvMat3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvMat3___getitem(lua_State* L) {
  int SWIG_arg = 0;
  hkvMat3 *arg1 = (hkvMat3 *) 0 ;
  int arg2 ;
  float result;
  
  SWIG_check_num_args("__getitem__",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("__getitem__",1,"hkvMat3 *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("__getitem__",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvMat3,0))){
    SWIG_fail_ptr("hkvMat3___getitem",1,SWIGTYPE_p_hkvMat3);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  result = (float)hkvMat3___getitem__(arg1,arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvMat3___setitem(lua_State* L) {
  int SWIG_arg = 0;
  hkvMat3 *arg1 = (hkvMat3 *) 0 ;
  int arg2 ;
  float arg3 ;
  
  SWIG_check_num_args("__setitem__",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("__setitem__",1,"hkvMat3 *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("__setitem__",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("__setitem__",3,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvMat3,0))){
    SWIG_fail_ptr("hkvMat3___setitem",1,SWIGTYPE_p_hkvMat3);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  hkvMat3___setitem__(arg1,arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_hkvMat3(void *obj) {
hkvMat3 *arg1 = (hkvMat3 *) obj;
delete arg1;
}
static swig_lua_method swig_hkvMat3_methods[] = {
    { "__tostring",hkvMat3_ToString},
    { "__concat",hkvMat3_Concat},
    {"setIdentity", _wrap_hkvMat3_setIdentity}, 
    {"setZero", _wrap_hkvMat3_setZero}, 
    {"isZero", _wrap_hkvMat3_isZero}, 
    {"isIdentity", _wrap_hkvMat3_isIdentity}, 
    {"getRow", _wrap_hkvMat3_getRow}, 
    {"getColumn", _wrap_hkvMat3_getColumn}, 
    {"getScalingFactors", _wrap_hkvMat3_getScalingFactors}, 
    {"transpose", _wrap_hkvMat3_transpose}, 
    {"getTransposed", _wrap_hkvMat3_getTransposed}, 
    {"invert", _wrap_hkvMat3_invert}, 
    {"setScalingFactors", _wrap_hkvMat3_setScalingFactors}, 
    {"getElement", _wrap_hkvMat3_getElement}, 
    {"setElement", _wrap_hkvMat3_setElement}, 
    {"setRow", _wrap_hkvMat3_setRow}, 
    {"setColumn", _wrap_hkvMat3_setColumn}, 
    {"setRotationMatrix", _wrap_hkvMat3_setRotationMatrix}, 
    {"setLookInDirectionMatrix", _wrap_hkvMat3_setLookInDirectionMatrix}, 
    {"getAxis", _wrap_hkvMat3_getAxis}, 
    {"setAxis", _wrap_hkvMat3_setAxis}, 
    {"setScalingMatrix", _wrap_hkvMat3_setScalingMatrix}, 
    {"setRotationMatrixX", _wrap_hkvMat3_setRotationMatrixX}, 
    {"setRotationMatrixY", _wrap_hkvMat3_setRotationMatrixY}, 
    {"setRotationMatrixZ", _wrap_hkvMat3_setRotationMatrixZ}, 
    {"isIdentical", _wrap_hkvMat3_isIdentical}, 
    {"isEqual", _wrap_hkvMat3_isEqual}, 
    {"transformDirection", _wrap_hkvMat3_transformDirection}, 
    {"multiply", _wrap_hkvMat3_multiply}, 
    {"multiplyReverse", _wrap_hkvMat3_multiplyReverse}, 
    {"set", _wrap_hkvMat3_set}, 
    {"clone", _wrap_hkvMat3_clone}, 
    {"__eq", _wrap_hkvMat3___eq}, 
    {"__add", _wrap_hkvMat3___add}, 
    {"__sub", _wrap_hkvMat3___sub}, 
    {"__mul", _wrap_hkvMat3___mul}, 
    {"__div", _wrap_hkvMat3___div}, 
    {"__getitem", _wrap_hkvMat3___getitem}, 
    {"__setitem", _wrap_hkvMat3___setitem}, 
    {0,0}
};
static swig_lua_attribute swig_hkvMat3_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_hkvMat3_bases[] = {0};
static const char *swig_hkvMat3_base_names[] = {0};
static swig_lua_class _wrap_class_hkvMat3 = { "hkvMat3", &SWIGTYPE_p_hkvMat3,_wrap_new_hkvMat3, swig_delete_hkvMat3, swig_hkvMat3_methods, swig_hkvMat3_attributes, swig_hkvMat3_bases, swig_hkvMat3_base_names };

static int _wrap_new_hkvAlignedBBox__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  hkvVec3 *arg1 = 0 ;
  hkvVec3 *arg2 = 0 ;
  hkvAlignedBBox *result = 0 ;
  
  SWIG_check_num_args("hkvAlignedBBox",2,2)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("hkvAlignedBBox",1,"hkvVec3 const &");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("hkvAlignedBBox",2,"hkvVec3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("new_hkvAlignedBBox",1,SWIGTYPE_p_hkvVec3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("new_hkvAlignedBBox",2,SWIGTYPE_p_hkvVec3);
  }
  
  result = (hkvAlignedBBox *)new hkvAlignedBBox((hkvVec3 const &)*arg1,(hkvVec3 const &)*arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_hkvAlignedBBox,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvAlignedBBox_setZero(lua_State* L) {
  int SWIG_arg = 0;
  hkvAlignedBBox *arg1 = (hkvAlignedBBox *) 0 ;
  
  SWIG_check_num_args("setZero",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("setZero",1,"hkvAlignedBBox *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvAlignedBBox,0))){
    SWIG_fail_ptr("hkvAlignedBBox_setZero",1,SWIGTYPE_p_hkvAlignedBBox);
  }
  
  (arg1)->setZero();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvAlignedBBox_isZero__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  hkvAlignedBBox *arg1 = (hkvAlignedBBox *) 0 ;
  bool result;
  
  SWIG_check_num_args("isZero",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("isZero",1,"hkvAlignedBBox const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvAlignedBBox,0))){
    SWIG_fail_ptr("hkvAlignedBBox_isZero",1,SWIGTYPE_p_hkvAlignedBBox);
  }
  
  result = (bool)((hkvAlignedBBox const *)arg1)->isZero();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvAlignedBBox_isZero__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  hkvAlignedBBox *arg1 = (hkvAlignedBBox *) 0 ;
  float arg2 ;
  bool result;
  
  SWIG_check_num_args("isZero",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("isZero",1,"hkvAlignedBBox const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("isZero",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvAlignedBBox,0))){
    SWIG_fail_ptr("hkvAlignedBBox_isZero",1,SWIGTYPE_p_hkvAlignedBBox);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  result = (bool)((hkvAlignedBBox const *)arg1)->isZero(arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvAlignedBBox_isZero(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_hkvAlignedBBox, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_hkvAlignedBBox_isZero__SWIG_0(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_hkvAlignedBBox, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_hkvAlignedBBox_isZero__SWIG_1(L);
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'hkvAlignedBBox_isZero'\n"
    "  Possible C/C++ prototypes are:\n"
    "    isZero(hkvAlignedBBox const *)\n"
    "    isZero(hkvAlignedBBox const *,float)\n");
  lua_error(L);return 0;
}


static int _wrap_hkvAlignedBBox_set__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  hkvAlignedBBox *arg1 = (hkvAlignedBBox *) 0 ;
  hkvVec3 *arg2 = 0 ;
  hkvVec3 *arg3 = 0 ;
  
  SWIG_check_num_args("set",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("set",1,"hkvAlignedBBox *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("set",2,"hkvVec3 const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("set",3,"hkvVec3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvAlignedBBox,0))){
    SWIG_fail_ptr("hkvAlignedBBox_set",1,SWIGTYPE_p_hkvAlignedBBox);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("hkvAlignedBBox_set",2,SWIGTYPE_p_hkvVec3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("hkvAlignedBBox_set",3,SWIGTYPE_p_hkvVec3);
  }
  
  (arg1)->set((hkvVec3 const &)*arg2,(hkvVec3 const &)*arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvAlignedBBox_setCenterAndSize(lua_State* L) {
  int SWIG_arg = 0;
  hkvAlignedBBox *arg1 = (hkvAlignedBBox *) 0 ;
  hkvVec3 *arg2 = 0 ;
  hkvVec3 *arg3 = 0 ;
  
  SWIG_check_num_args("setCenterAndSize",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("setCenterAndSize",1,"hkvAlignedBBox *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("setCenterAndSize",2,"hkvVec3 const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("setCenterAndSize",3,"hkvVec3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvAlignedBBox,0))){
    SWIG_fail_ptr("hkvAlignedBBox_setCenterAndSize",1,SWIGTYPE_p_hkvAlignedBBox);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("hkvAlignedBBox_setCenterAndSize",2,SWIGTYPE_p_hkvVec3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("hkvAlignedBBox_setCenterAndSize",3,SWIGTYPE_p_hkvVec3);
  }
  
  (arg1)->setCenterAndSize((hkvVec3 const &)*arg2,(hkvVec3 const &)*arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvAlignedBBox_setInvalid(lua_State* L) {
  int SWIG_arg = 0;
  hkvAlignedBBox *arg1 = (hkvAlignedBBox *) 0 ;
  
  SWIG_check_num_args("setInvalid",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("setInvalid",1,"hkvAlignedBBox *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvAlignedBBox,0))){
    SWIG_fail_ptr("hkvAlignedBBox_setInvalid",1,SWIGTYPE_p_hkvAlignedBBox);
  }
  
  (arg1)->setInvalid();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvAlignedBBox_isValid(lua_State* L) {
  int SWIG_arg = 0;
  hkvAlignedBBox *arg1 = (hkvAlignedBBox *) 0 ;
  bool result;
  
  SWIG_check_num_args("isValid",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("isValid",1,"hkvAlignedBBox const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvAlignedBBox,0))){
    SWIG_fail_ptr("hkvAlignedBBox_isValid",1,SWIGTYPE_p_hkvAlignedBBox);
  }
  
  result = (bool)((hkvAlignedBBox const *)arg1)->isValid();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvAlignedBBox_expandToInclude__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  hkvAlignedBBox *arg1 = (hkvAlignedBBox *) 0 ;
  hkvVec3 *arg2 = 0 ;
  
  SWIG_check_num_args("expandToInclude",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("expandToInclude",1,"hkvAlignedBBox *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("expandToInclude",2,"hkvVec3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvAlignedBBox,0))){
    SWIG_fail_ptr("hkvAlignedBBox_expandToInclude",1,SWIGTYPE_p_hkvAlignedBBox);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("hkvAlignedBBox_expandToInclude",2,SWIGTYPE_p_hkvVec3);
  }
  
  (arg1)->expandToInclude((hkvVec3 const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvAlignedBBox_expandToInclude__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  hkvAlignedBBox *arg1 = (hkvAlignedBBox *) 0 ;
  hkvAlignedBBox *arg2 = 0 ;
  
  SWIG_check_num_args("expandToInclude",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("expandToInclude",1,"hkvAlignedBBox *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("expandToInclude",2,"hkvAlignedBBox const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvAlignedBBox,0))){
    SWIG_fail_ptr("hkvAlignedBBox_expandToInclude",1,SWIGTYPE_p_hkvAlignedBBox);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_hkvAlignedBBox,0))){
    SWIG_fail_ptr("hkvAlignedBBox_expandToInclude",2,SWIGTYPE_p_hkvAlignedBBox);
  }
  
  (arg1)->expandToInclude((hkvAlignedBBox const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvAlignedBBox_expandToInclude(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_hkvAlignedBBox, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_hkvVec3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_hkvAlignedBBox_expandToInclude__SWIG_0(L);
      }
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_hkvAlignedBBox, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_hkvAlignedBBox, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_hkvAlignedBBox_expandToInclude__SWIG_1(L);
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'hkvAlignedBBox_expandToInclude'\n"
    "  Possible C/C++ prototypes are:\n"
    "    expandToInclude(hkvAlignedBBox *,hkvVec3 const &)\n"
    "    expandToInclude(hkvAlignedBBox *,hkvAlignedBBox const &)\n");
  lua_error(L);return 0;
}


static int _wrap_hkvAlignedBBox_translate(lua_State* L) {
  int SWIG_arg = 0;
  hkvAlignedBBox *arg1 = (hkvAlignedBBox *) 0 ;
  hkvVec3 *arg2 = 0 ;
  
  SWIG_check_num_args("translate",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("translate",1,"hkvAlignedBBox *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("translate",2,"hkvVec3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvAlignedBBox,0))){
    SWIG_fail_ptr("hkvAlignedBBox_translate",1,SWIGTYPE_p_hkvAlignedBBox);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("hkvAlignedBBox_translate",2,SWIGTYPE_p_hkvVec3);
  }
  
  (arg1)->translate((hkvVec3 const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvAlignedBBox_scaleFromCenter(lua_State* L) {
  int SWIG_arg = 0;
  hkvAlignedBBox *arg1 = (hkvAlignedBBox *) 0 ;
  hkvVec3 *arg2 = 0 ;
  
  SWIG_check_num_args("scaleFromCenter",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("scaleFromCenter",1,"hkvAlignedBBox *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("scaleFromCenter",2,"hkvVec3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvAlignedBBox,0))){
    SWIG_fail_ptr("hkvAlignedBBox_scaleFromCenter",1,SWIGTYPE_p_hkvAlignedBBox);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("hkvAlignedBBox_scaleFromCenter",2,SWIGTYPE_p_hkvVec3);
  }
  
  (arg1)->scaleFromCenter((hkvVec3 const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvAlignedBBox_scaleFromOrigin(lua_State* L) {
  int SWIG_arg = 0;
  hkvAlignedBBox *arg1 = (hkvAlignedBBox *) 0 ;
  hkvVec3 *arg2 = 0 ;
  
  SWIG_check_num_args("scaleFromOrigin",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("scaleFromOrigin",1,"hkvAlignedBBox *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("scaleFromOrigin",2,"hkvVec3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvAlignedBBox,0))){
    SWIG_fail_ptr("hkvAlignedBBox_scaleFromOrigin",1,SWIGTYPE_p_hkvAlignedBBox);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("hkvAlignedBBox_scaleFromOrigin",2,SWIGTYPE_p_hkvVec3);
  }
  
  (arg1)->scaleFromOrigin((hkvVec3 const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvAlignedBBox_addBoundary(lua_State* L) {
  int SWIG_arg = 0;
  hkvAlignedBBox *arg1 = (hkvAlignedBBox *) 0 ;
  hkvVec3 *arg2 = 0 ;
  
  SWIG_check_num_args("addBoundary",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("addBoundary",1,"hkvAlignedBBox *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("addBoundary",2,"hkvVec3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvAlignedBBox,0))){
    SWIG_fail_ptr("hkvAlignedBBox_addBoundary",1,SWIGTYPE_p_hkvAlignedBBox);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("hkvAlignedBBox_addBoundary",2,SWIGTYPE_p_hkvVec3);
  }
  
  (arg1)->addBoundary((hkvVec3 const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvAlignedBBox_expandToCube(lua_State* L) {
  int SWIG_arg = 0;
  hkvAlignedBBox *arg1 = (hkvAlignedBBox *) 0 ;
  
  SWIG_check_num_args("expandToCube",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("expandToCube",1,"hkvAlignedBBox *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvAlignedBBox,0))){
    SWIG_fail_ptr("hkvAlignedBBox_expandToCube",1,SWIGTYPE_p_hkvAlignedBBox);
  }
  
  (arg1)->expandToCube();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvAlignedBBox_isIdentical(lua_State* L) {
  int SWIG_arg = 0;
  hkvAlignedBBox *arg1 = (hkvAlignedBBox *) 0 ;
  hkvAlignedBBox *arg2 = 0 ;
  bool result;
  
  SWIG_check_num_args("isIdentical",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("isIdentical",1,"hkvAlignedBBox const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("isIdentical",2,"hkvAlignedBBox const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvAlignedBBox,0))){
    SWIG_fail_ptr("hkvAlignedBBox_isIdentical",1,SWIGTYPE_p_hkvAlignedBBox);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_hkvAlignedBBox,0))){
    SWIG_fail_ptr("hkvAlignedBBox_isIdentical",2,SWIGTYPE_p_hkvAlignedBBox);
  }
  
  result = (bool)((hkvAlignedBBox const *)arg1)->isIdentical((hkvAlignedBBox const &)*arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvAlignedBBox_isEqual(lua_State* L) {
  int SWIG_arg = 0;
  hkvAlignedBBox *arg1 = (hkvAlignedBBox *) 0 ;
  hkvAlignedBBox *arg2 = 0 ;
  float arg3 ;
  bool result;
  
  SWIG_check_num_args("isEqual",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("isEqual",1,"hkvAlignedBBox const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("isEqual",2,"hkvAlignedBBox const &");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("isEqual",3,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvAlignedBBox,0))){
    SWIG_fail_ptr("hkvAlignedBBox_isEqual",1,SWIGTYPE_p_hkvAlignedBBox);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_hkvAlignedBBox,0))){
    SWIG_fail_ptr("hkvAlignedBBox_isEqual",2,SWIGTYPE_p_hkvAlignedBBox);
  }
  
  arg3 = (float)lua_tonumber(L, 3);
  result = (bool)((hkvAlignedBBox const *)arg1)->isEqual((hkvAlignedBBox const &)*arg2,arg3);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvAlignedBBox_getCenter(lua_State* L) {
  int SWIG_arg = 0;
  hkvAlignedBBox *arg1 = (hkvAlignedBBox *) 0 ;
  SwigValueWrapper< hkvVec3 > result;
  
  SWIG_check_num_args("getCenter",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("getCenter",1,"hkvAlignedBBox const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvAlignedBBox,0))){
    SWIG_fail_ptr("hkvAlignedBBox_getCenter",1,SWIGTYPE_p_hkvAlignedBBox);
  }
  
  result = ((hkvAlignedBBox const *)arg1)->getCenter();
  {
    hkvVec3 * resultptr = new hkvVec3((const hkvVec3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_hkvVec3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvAlignedBBox_getSizeX(lua_State* L) {
  int SWIG_arg = 0;
  hkvAlignedBBox *arg1 = (hkvAlignedBBox *) 0 ;
  float result;
  
  SWIG_check_num_args("getSizeX",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("getSizeX",1,"hkvAlignedBBox const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvAlignedBBox,0))){
    SWIG_fail_ptr("hkvAlignedBBox_getSizeX",1,SWIGTYPE_p_hkvAlignedBBox);
  }
  
  result = (float)((hkvAlignedBBox const *)arg1)->getSizeX();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvAlignedBBox_getSizeY(lua_State* L) {
  int SWIG_arg = 0;
  hkvAlignedBBox *arg1 = (hkvAlignedBBox *) 0 ;
  float result;
  
  SWIG_check_num_args("getSizeY",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("getSizeY",1,"hkvAlignedBBox const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvAlignedBBox,0))){
    SWIG_fail_ptr("hkvAlignedBBox_getSizeY",1,SWIGTYPE_p_hkvAlignedBBox);
  }
  
  result = (float)((hkvAlignedBBox const *)arg1)->getSizeY();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvAlignedBBox_getSizeZ(lua_State* L) {
  int SWIG_arg = 0;
  hkvAlignedBBox *arg1 = (hkvAlignedBBox *) 0 ;
  float result;
  
  SWIG_check_num_args("getSizeZ",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("getSizeZ",1,"hkvAlignedBBox const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvAlignedBBox,0))){
    SWIG_fail_ptr("hkvAlignedBBox_getSizeZ",1,SWIGTYPE_p_hkvAlignedBBox);
  }
  
  result = (float)((hkvAlignedBBox const *)arg1)->getSizeZ();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvAlignedBBox_contains__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  hkvAlignedBBox *arg1 = (hkvAlignedBBox *) 0 ;
  hkvVec3 *arg2 = 0 ;
  bool result;
  
  SWIG_check_num_args("contains",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("contains",1,"hkvAlignedBBox const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("contains",2,"hkvVec3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvAlignedBBox,0))){
    SWIG_fail_ptr("hkvAlignedBBox_contains",1,SWIGTYPE_p_hkvAlignedBBox);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("hkvAlignedBBox_contains",2,SWIGTYPE_p_hkvVec3);
  }
  
  result = (bool)((hkvAlignedBBox const *)arg1)->contains((hkvVec3 const &)*arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvAlignedBBox_contains__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  hkvAlignedBBox *arg1 = (hkvAlignedBBox *) 0 ;
  hkvAlignedBBox *arg2 = 0 ;
  bool result;
  
  SWIG_check_num_args("contains",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("contains",1,"hkvAlignedBBox const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("contains",2,"hkvAlignedBBox const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvAlignedBBox,0))){
    SWIG_fail_ptr("hkvAlignedBBox_contains",1,SWIGTYPE_p_hkvAlignedBBox);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_hkvAlignedBBox,0))){
    SWIG_fail_ptr("hkvAlignedBBox_contains",2,SWIGTYPE_p_hkvAlignedBBox);
  }
  
  result = (bool)((hkvAlignedBBox const *)arg1)->contains((hkvAlignedBBox const &)*arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvAlignedBBox_contains(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_hkvAlignedBBox, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_hkvVec3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_hkvAlignedBBox_contains__SWIG_0(L);
      }
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_hkvAlignedBBox, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_hkvAlignedBBox, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_hkvAlignedBBox_contains__SWIG_1(L);
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'hkvAlignedBBox_contains'\n"
    "  Possible C/C++ prototypes are:\n"
    "    contains(hkvAlignedBBox const *,hkvVec3 const &)\n"
    "    contains(hkvAlignedBBox const *,hkvAlignedBBox const &)\n");
  lua_error(L);return 0;
}


static int _wrap_hkvAlignedBBox_overlaps(lua_State* L) {
  int SWIG_arg = 0;
  hkvAlignedBBox *arg1 = (hkvAlignedBBox *) 0 ;
  hkvAlignedBBox *arg2 = 0 ;
  bool result;
  
  SWIG_check_num_args("overlaps",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("overlaps",1,"hkvAlignedBBox const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("overlaps",2,"hkvAlignedBBox const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvAlignedBBox,0))){
    SWIG_fail_ptr("hkvAlignedBBox_overlaps",1,SWIGTYPE_p_hkvAlignedBBox);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_hkvAlignedBBox,0))){
    SWIG_fail_ptr("hkvAlignedBBox_overlaps",2,SWIGTYPE_p_hkvAlignedBBox);
  }
  
  result = (bool)((hkvAlignedBBox const *)arg1)->overlaps((hkvAlignedBBox const &)*arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvAlignedBBox_getDistanceToSquared__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  hkvAlignedBBox *arg1 = (hkvAlignedBBox *) 0 ;
  hkvVec3 *arg2 = 0 ;
  float result;
  
  SWIG_check_num_args("getDistanceToSquared",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("getDistanceToSquared",1,"hkvAlignedBBox const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("getDistanceToSquared",2,"hkvVec3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvAlignedBBox,0))){
    SWIG_fail_ptr("hkvAlignedBBox_getDistanceToSquared",1,SWIGTYPE_p_hkvAlignedBBox);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("hkvAlignedBBox_getDistanceToSquared",2,SWIGTYPE_p_hkvVec3);
  }
  
  result = (float)((hkvAlignedBBox const *)arg1)->getDistanceToSquared((hkvVec3 const &)*arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvAlignedBBox_getDistanceToSquared__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  hkvAlignedBBox *arg1 = (hkvAlignedBBox *) 0 ;
  hkvAlignedBBox *arg2 = 0 ;
  float result;
  
  SWIG_check_num_args("getDistanceToSquared",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("getDistanceToSquared",1,"hkvAlignedBBox const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("getDistanceToSquared",2,"hkvAlignedBBox const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvAlignedBBox,0))){
    SWIG_fail_ptr("hkvAlignedBBox_getDistanceToSquared",1,SWIGTYPE_p_hkvAlignedBBox);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_hkvAlignedBBox,0))){
    SWIG_fail_ptr("hkvAlignedBBox_getDistanceToSquared",2,SWIGTYPE_p_hkvAlignedBBox);
  }
  
  result = (float)((hkvAlignedBBox const *)arg1)->getDistanceToSquared((hkvAlignedBBox const &)*arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvAlignedBBox_getDistanceToSquared(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_hkvAlignedBBox, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_hkvVec3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_hkvAlignedBBox_getDistanceToSquared__SWIG_0(L);
      }
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_hkvAlignedBBox, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_hkvAlignedBBox, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_hkvAlignedBBox_getDistanceToSquared__SWIG_1(L);
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'hkvAlignedBBox_getDistanceToSquared'\n"
    "  Possible C/C++ prototypes are:\n"
    "    getDistanceToSquared(hkvAlignedBBox const *,hkvVec3 const &)\n"
    "    getDistanceToSquared(hkvAlignedBBox const *,hkvAlignedBBox const &)\n");
  lua_error(L);return 0;
}


static int _wrap_hkvAlignedBBox_getDistanceTo__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  hkvAlignedBBox *arg1 = (hkvAlignedBBox *) 0 ;
  hkvVec3 *arg2 = 0 ;
  float result;
  
  SWIG_check_num_args("getDistanceTo",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("getDistanceTo",1,"hkvAlignedBBox const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("getDistanceTo",2,"hkvVec3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvAlignedBBox,0))){
    SWIG_fail_ptr("hkvAlignedBBox_getDistanceTo",1,SWIGTYPE_p_hkvAlignedBBox);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("hkvAlignedBBox_getDistanceTo",2,SWIGTYPE_p_hkvVec3);
  }
  
  result = (float)((hkvAlignedBBox const *)arg1)->getDistanceTo((hkvVec3 const &)*arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvAlignedBBox_getDistanceTo__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  hkvAlignedBBox *arg1 = (hkvAlignedBBox *) 0 ;
  hkvAlignedBBox *arg2 = 0 ;
  float result;
  
  SWIG_check_num_args("getDistanceTo",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("getDistanceTo",1,"hkvAlignedBBox const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("getDistanceTo",2,"hkvAlignedBBox const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvAlignedBBox,0))){
    SWIG_fail_ptr("hkvAlignedBBox_getDistanceTo",1,SWIGTYPE_p_hkvAlignedBBox);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_hkvAlignedBBox,0))){
    SWIG_fail_ptr("hkvAlignedBBox_getDistanceTo",2,SWIGTYPE_p_hkvAlignedBBox);
  }
  
  result = (float)((hkvAlignedBBox const *)arg1)->getDistanceTo((hkvAlignedBBox const &)*arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvAlignedBBox_getDistanceTo(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_hkvAlignedBBox, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_hkvVec3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_hkvAlignedBBox_getDistanceTo__SWIG_0(L);
      }
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_hkvAlignedBBox, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_hkvAlignedBBox, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_hkvAlignedBBox_getDistanceTo__SWIG_1(L);
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'hkvAlignedBBox_getDistanceTo'\n"
    "  Possible C/C++ prototypes are:\n"
    "    getDistanceTo(hkvAlignedBBox const *,hkvVec3 const &)\n"
    "    getDistanceTo(hkvAlignedBBox const *,hkvAlignedBBox const &)\n");
  lua_error(L);return 0;
}


static int _wrap_hkvAlignedBBox_getClampedPosition(lua_State* L) {
  int SWIG_arg = 0;
  hkvAlignedBBox *arg1 = (hkvAlignedBBox *) 0 ;
  hkvVec3 *arg2 = 0 ;
  SwigValueWrapper< hkvVec3 > result;
  
  SWIG_check_num_args("getClampedPosition",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("getClampedPosition",1,"hkvAlignedBBox const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("getClampedPosition",2,"hkvVec3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvAlignedBBox,0))){
    SWIG_fail_ptr("hkvAlignedBBox_getClampedPosition",1,SWIGTYPE_p_hkvAlignedBBox);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("hkvAlignedBBox_getClampedPosition",2,SWIGTYPE_p_hkvVec3);
  }
  
  result = ((hkvAlignedBBox const *)arg1)->getClampedPosition((hkvVec3 const &)*arg2);
  {
    hkvVec3 * resultptr = new hkvVec3((const hkvVec3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_hkvVec3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_hkvAlignedBBox__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  bool arg1 ;
  hkvAlignedBBox *result = 0 ;
  
  SWIG_check_num_args("hkvAlignedBBox",1,1)
  if(!lua_isboolean(L,1)) SWIG_fail_arg("hkvAlignedBBox",1,"bool");
  arg1 = (lua_toboolean(L, 1)!=0);
  result = (hkvAlignedBBox *)new_hkvAlignedBBox__SWIG_1(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_hkvAlignedBBox,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_hkvAlignedBBox__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  hkvAlignedBBox *result = 0 ;
  
  SWIG_check_num_args("hkvAlignedBBox",0,0)
  result = (hkvAlignedBBox *)new_hkvAlignedBBox__SWIG_1();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_hkvAlignedBBox,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_hkvAlignedBBox__SWIG_3(lua_State* L) {
  int SWIG_arg = 0;
  float arg1 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  float arg5 ;
  float arg6 ;
  hkvAlignedBBox *result = 0 ;
  
  SWIG_check_num_args("hkvAlignedBBox",6,6)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("hkvAlignedBBox",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("hkvAlignedBBox",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("hkvAlignedBBox",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("hkvAlignedBBox",4,"float");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("hkvAlignedBBox",5,"float");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("hkvAlignedBBox",6,"float");
  arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4);
  arg5 = (float)lua_tonumber(L, 5);
  arg6 = (float)lua_tonumber(L, 6);
  result = (hkvAlignedBBox *)new_hkvAlignedBBox__SWIG_3(arg1,arg2,arg3,arg4,arg5,arg6);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_hkvAlignedBBox,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_hkvAlignedBBox(lua_State* L) {
  int argc;
  int argv[7]={
    1,2,3,4,5,6,7
  };
  
  argc = lua_gettop(L);
  if (argc == 0) {
    return _wrap_new_hkvAlignedBBox__SWIG_2(L);
  }
  if (argc == 1) {
    int _v;
    {
      _v = lua_isboolean(L,argv[0]);
    }
    if (_v) {
      return _wrap_new_hkvAlignedBBox__SWIG_1(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_hkvVec3, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_hkvVec3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_new_hkvAlignedBBox__SWIG_0(L);
      }
    }
  }
  if (argc == 6) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isnumber(L,argv[4]);
            }
            if (_v) {
              {
                _v = lua_isnumber(L,argv[5]);
              }
              if (_v) {
                return _wrap_new_hkvAlignedBBox__SWIG_3(L);
              }
            }
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'new_hkvAlignedBBox'\n"
    "  Possible C/C++ prototypes are:\n"
    "    hkvAlignedBBox(hkvVec3 const &,hkvVec3 const &)\n"
    "    hkvAlignedBBox(bool)\n"
    "    hkvAlignedBBox()\n"
    "    hkvAlignedBBox(float,float,float,float,float,float)\n");
  lua_error(L);return 0;
}


static int _wrap_hkvAlignedBBox_set__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  hkvAlignedBBox *arg1 = (hkvAlignedBBox *) 0 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  float arg5 ;
  float arg6 ;
  float arg7 ;
  
  SWIG_check_num_args("set",7,7)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("set",1,"hkvAlignedBBox *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("set",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("set",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("set",4,"float");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("set",5,"float");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("set",6,"float");
  if(!lua_isnumber(L,7)) SWIG_fail_arg("set",7,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvAlignedBBox,0))){
    SWIG_fail_ptr("hkvAlignedBBox_set",1,SWIGTYPE_p_hkvAlignedBBox);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4);
  arg5 = (float)lua_tonumber(L, 5);
  arg6 = (float)lua_tonumber(L, 6);
  arg7 = (float)lua_tonumber(L, 7);
  hkvAlignedBBox_set__SWIG_1(arg1,arg2,arg3,arg4,arg5,arg6,arg7);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvAlignedBBox_set(lua_State* L) {
  int argc;
  int argv[8]={
    1,2,3,4,5,6,7,8
  };
  
  argc = lua_gettop(L);
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_hkvAlignedBBox, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_hkvVec3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_hkvVec3, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          return _wrap_hkvAlignedBBox_set__SWIG_0(L);
        }
      }
    }
  }
  if (argc == 7) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_hkvAlignedBBox, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isnumber(L,argv[4]);
            }
            if (_v) {
              {
                _v = lua_isnumber(L,argv[5]);
              }
              if (_v) {
                {
                  _v = lua_isnumber(L,argv[6]);
                }
                if (_v) {
                  return _wrap_hkvAlignedBBox_set__SWIG_1(L);
                }
              }
            }
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'hkvAlignedBBox_set'\n"
    "  Possible C/C++ prototypes are:\n"
    "    set(hkvAlignedBBox *,hkvVec3 const &,hkvVec3 const &)\n"
    "    set(hkvAlignedBBox *,float,float,float,float,float,float)\n");
  lua_error(L);return 0;
}


static int _wrap_hkvAlignedBBox_clone(lua_State* L) {
  int SWIG_arg = 0;
  hkvAlignedBBox *arg1 = (hkvAlignedBBox *) 0 ;
  SwigValueWrapper< hkvAlignedBBox > result;
  
  SWIG_check_num_args("clone",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("clone",1,"hkvAlignedBBox const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvAlignedBBox,0))){
    SWIG_fail_ptr("hkvAlignedBBox_clone",1,SWIGTYPE_p_hkvAlignedBBox);
  }
  
  result = hkvAlignedBBox_clone((hkvAlignedBBox const *)arg1);
  {
    hkvAlignedBBox * resultptr = new hkvAlignedBBox((const hkvAlignedBBox &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_hkvAlignedBBox,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvAlignedBBox___eq(lua_State* L) {
  int SWIG_arg = 0;
  hkvAlignedBBox *arg1 = (hkvAlignedBBox *) 0 ;
  hkvAlignedBBox *arg2 = (hkvAlignedBBox *) 0 ;
  bool result;
  
  SWIG_check_num_args("__eq",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("__eq",1,"hkvAlignedBBox const *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("__eq",2,"hkvAlignedBBox const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvAlignedBBox,0))){
    SWIG_fail_ptr("hkvAlignedBBox___eq",1,SWIGTYPE_p_hkvAlignedBBox);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_hkvAlignedBBox,0))){
    SWIG_fail_ptr("hkvAlignedBBox___eq",2,SWIGTYPE_p_hkvAlignedBBox);
  }
  
  result = (bool)hkvAlignedBBox___eq((hkvAlignedBBox const *)arg1,(hkvAlignedBBox const *)arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvAlignedBBox_m_vMin_set(lua_State* L) {
  int SWIG_arg = 0;
  hkvAlignedBBox *arg1 = (hkvAlignedBBox *) 0 ;
  hkvVec3 *arg2 = (hkvVec3 *) 0 ;
  
  SWIG_check_num_args("m_vMin",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("m_vMin",1,"hkvAlignedBBox *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("m_vMin",2,"hkvVec3 *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvAlignedBBox,0))){
    SWIG_fail_ptr("hkvAlignedBBox_m_vMin_set",1,SWIGTYPE_p_hkvAlignedBBox);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("hkvAlignedBBox_m_vMin_set",2,SWIGTYPE_p_hkvVec3);
  }
  
  if (arg1) (arg1)->m_vMin = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvAlignedBBox_m_vMin_get(lua_State* L) {
  int SWIG_arg = 0;
  hkvAlignedBBox *arg1 = (hkvAlignedBBox *) 0 ;
  hkvVec3 *result = 0 ;
  
  SWIG_check_num_args("m_vMin",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("m_vMin",1,"hkvAlignedBBox *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvAlignedBBox,0))){
    SWIG_fail_ptr("hkvAlignedBBox_m_vMin_get",1,SWIGTYPE_p_hkvAlignedBBox);
  }
  
  result = (hkvVec3 *)& ((arg1)->m_vMin);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_hkvVec3,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvAlignedBBox_m_vMax_set(lua_State* L) {
  int SWIG_arg = 0;
  hkvAlignedBBox *arg1 = (hkvAlignedBBox *) 0 ;
  hkvVec3 *arg2 = (hkvVec3 *) 0 ;
  
  SWIG_check_num_args("m_vMax",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("m_vMax",1,"hkvAlignedBBox *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("m_vMax",2,"hkvVec3 *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvAlignedBBox,0))){
    SWIG_fail_ptr("hkvAlignedBBox_m_vMax_set",1,SWIGTYPE_p_hkvAlignedBBox);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("hkvAlignedBBox_m_vMax_set",2,SWIGTYPE_p_hkvVec3);
  }
  
  if (arg1) (arg1)->m_vMax = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hkvAlignedBBox_m_vMax_get(lua_State* L) {
  int SWIG_arg = 0;
  hkvAlignedBBox *arg1 = (hkvAlignedBBox *) 0 ;
  hkvVec3 *result = 0 ;
  
  SWIG_check_num_args("m_vMax",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("m_vMax",1,"hkvAlignedBBox *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hkvAlignedBBox,0))){
    SWIG_fail_ptr("hkvAlignedBBox_m_vMax_get",1,SWIGTYPE_p_hkvAlignedBBox);
  }
  
  result = (hkvVec3 *)& ((arg1)->m_vMax);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_hkvVec3,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_hkvAlignedBBox(void *obj) {
hkvAlignedBBox *arg1 = (hkvAlignedBBox *) obj;
delete arg1;
}
static swig_lua_method swig_hkvAlignedBBox_methods[] = {
    { "getCorners",hkvAlignedBBox_getCorners},
    { "__tostring",hkvAlignedBBox_ToString},
    { "__concat",hkvAlignedBBox_Concat},
    {"setZero", _wrap_hkvAlignedBBox_setZero}, 
    {"isZero", _wrap_hkvAlignedBBox_isZero}, 
    {"setCenterAndSize", _wrap_hkvAlignedBBox_setCenterAndSize}, 
    {"setInvalid", _wrap_hkvAlignedBBox_setInvalid}, 
    {"isValid", _wrap_hkvAlignedBBox_isValid}, 
    {"expandToInclude", _wrap_hkvAlignedBBox_expandToInclude}, 
    {"translate", _wrap_hkvAlignedBBox_translate}, 
    {"scaleFromCenter", _wrap_hkvAlignedBBox_scaleFromCenter}, 
    {"scaleFromOrigin", _wrap_hkvAlignedBBox_scaleFromOrigin}, 
    {"addBoundary", _wrap_hkvAlignedBBox_addBoundary}, 
    {"expandToCube", _wrap_hkvAlignedBBox_expandToCube}, 
    {"isIdentical", _wrap_hkvAlignedBBox_isIdentical}, 
    {"isEqual", _wrap_hkvAlignedBBox_isEqual}, 
    {"getCenter", _wrap_hkvAlignedBBox_getCenter}, 
    {"getSizeX", _wrap_hkvAlignedBBox_getSizeX}, 
    {"getSizeY", _wrap_hkvAlignedBBox_getSizeY}, 
    {"getSizeZ", _wrap_hkvAlignedBBox_getSizeZ}, 
    {"contains", _wrap_hkvAlignedBBox_contains}, 
    {"overlaps", _wrap_hkvAlignedBBox_overlaps}, 
    {"getDistanceToSquared", _wrap_hkvAlignedBBox_getDistanceToSquared}, 
    {"getDistanceTo", _wrap_hkvAlignedBBox_getDistanceTo}, 
    {"getClampedPosition", _wrap_hkvAlignedBBox_getClampedPosition}, 
    {"set", _wrap_hkvAlignedBBox_set}, 
    {"clone", _wrap_hkvAlignedBBox_clone}, 
    {"__eq", _wrap_hkvAlignedBBox___eq}, 
    {0,0}
};
static swig_lua_attribute swig_hkvAlignedBBox_attributes[] = {
    { "m_vMin", _wrap_hkvAlignedBBox_m_vMin_get, _wrap_hkvAlignedBBox_m_vMin_set},
    { "m_vMax", _wrap_hkvAlignedBBox_m_vMax_get, _wrap_hkvAlignedBBox_m_vMax_set},
    {0,0,0}
};
static swig_lua_class *swig_hkvAlignedBBox_bases[] = {0};
static const char *swig_hkvAlignedBBox_base_names[] = {0};
static swig_lua_class _wrap_class_hkvAlignedBBox = { "hkvAlignedBBox", &SWIGTYPE_p_hkvAlignedBBox,_wrap_new_hkvAlignedBBox, swig_delete_hkvAlignedBBox, swig_hkvAlignedBBox_methods, swig_hkvAlignedBBox_attributes, swig_hkvAlignedBBox_bases, swig_hkvAlignedBBox_base_names };

static int _wrap_V_RGBA_WHITE_get(lua_State* L) {
  int SWIG_arg = 0;
  VColorRef *result = 0 ;
  
  SWIG_check_num_args("V_RGBA_WHITE",0,0)
  result = (VColorRef *)&V_RGBA_WHITE;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_VColorRef,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_V_RGBA_GREY_get(lua_State* L) {
  int SWIG_arg = 0;
  VColorRef *result = 0 ;
  
  SWIG_check_num_args("V_RGBA_GREY",0,0)
  result = (VColorRef *)&V_RGBA_GREY;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_VColorRef,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_V_RGBA_BLACK_get(lua_State* L) {
  int SWIG_arg = 0;
  VColorRef *result = 0 ;
  
  SWIG_check_num_args("V_RGBA_BLACK",0,0)
  result = (VColorRef *)&V_RGBA_BLACK;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_VColorRef,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_V_RGBA_RED_get(lua_State* L) {
  int SWIG_arg = 0;
  VColorRef *result = 0 ;
  
  SWIG_check_num_args("V_RGBA_RED",0,0)
  result = (VColorRef *)&V_RGBA_RED;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_VColorRef,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_V_RGBA_YELLOW_get(lua_State* L) {
  int SWIG_arg = 0;
  VColorRef *result = 0 ;
  
  SWIG_check_num_args("V_RGBA_YELLOW",0,0)
  result = (VColorRef *)&V_RGBA_YELLOW;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_VColorRef,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_V_RGBA_GREEN_get(lua_State* L) {
  int SWIG_arg = 0;
  VColorRef *result = 0 ;
  
  SWIG_check_num_args("V_RGBA_GREEN",0,0)
  result = (VColorRef *)&V_RGBA_GREEN;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_VColorRef,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_V_RGBA_CYAN_get(lua_State* L) {
  int SWIG_arg = 0;
  VColorRef *result = 0 ;
  
  SWIG_check_num_args("V_RGBA_CYAN",0,0)
  result = (VColorRef *)&V_RGBA_CYAN;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_VColorRef,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_V_RGBA_BLUE_get(lua_State* L) {
  int SWIG_arg = 0;
  VColorRef *result = 0 ;
  
  SWIG_check_num_args("V_RGBA_BLUE",0,0)
  result = (VColorRef *)&V_RGBA_BLUE;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_VColorRef,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_V_RGBA_PURPLE_get(lua_State* L) {
  int SWIG_arg = 0;
  VColorRef *result = 0 ;
  
  SWIG_check_num_args("V_RGBA_PURPLE",0,0)
  result = (VColorRef *)&V_RGBA_PURPLE;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_VColorRef,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_VColorRef__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  VColorRef *result = 0 ;
  
  SWIG_check_num_args("VColorRef",0,0)
  result = (VColorRef *)new VColorRef();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_VColorRef,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_VColorRef__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  UBYTE arg1 ;
  UBYTE arg2 ;
  UBYTE arg3 ;
  UBYTE arg4 ;
  VColorRef *result = 0 ;
  
  SWIG_check_num_args("VColorRef",4,4)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("VColorRef",1,"UBYTE");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("VColorRef",2,"UBYTE");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("VColorRef",3,"UBYTE");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("VColorRef",4,"UBYTE");
  SWIG_contract_assert((lua_tonumber(L,1)>=0),"number must not be negative")
  arg1 = (UBYTE)lua_tonumber(L, 1);
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (UBYTE)lua_tonumber(L, 2);
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative")
  arg3 = (UBYTE)lua_tonumber(L, 3);
  SWIG_contract_assert((lua_tonumber(L,4)>=0),"number must not be negative")
  arg4 = (UBYTE)lua_tonumber(L, 4);
  result = (VColorRef *)new VColorRef(arg1,arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_VColorRef,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_VColorRef__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  UBYTE arg1 ;
  UBYTE arg2 ;
  UBYTE arg3 ;
  VColorRef *result = 0 ;
  
  SWIG_check_num_args("VColorRef",3,3)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("VColorRef",1,"UBYTE");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("VColorRef",2,"UBYTE");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("VColorRef",3,"UBYTE");
  SWIG_contract_assert((lua_tonumber(L,1)>=0),"number must not be negative")
  arg1 = (UBYTE)lua_tonumber(L, 1);
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (UBYTE)lua_tonumber(L, 2);
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative")
  arg3 = (UBYTE)lua_tonumber(L, 3);
  result = (VColorRef *)new VColorRef(arg1,arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_VColorRef,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VColorRef_Clear(lua_State* L) {
  int SWIG_arg = 0;
  VColorRef *arg1 = (VColorRef *) 0 ;
  
  SWIG_check_num_args("Clear",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Clear",1,"VColorRef *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VColorRef,0))){
    SWIG_fail_ptr("VColorRef_Clear",1,SWIGTYPE_p_VColorRef);
  }
  
  (arg1)->Clear();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VColorRef_SetRGBA(lua_State* L) {
  int SWIG_arg = 0;
  VColorRef *arg1 = (VColorRef *) 0 ;
  UINT arg2 ;
  UINT arg3 ;
  UINT arg4 ;
  UINT arg5 ;
  
  SWIG_check_num_args("SetRGBA",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetRGBA",1,"VColorRef *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SetRGBA",2,"UINT");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("SetRGBA",3,"UINT");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("SetRGBA",4,"UINT");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("SetRGBA",5,"UINT");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VColorRef,0))){
    SWIG_fail_ptr("VColorRef_SetRGBA",1,SWIGTYPE_p_VColorRef);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (UINT)lua_tonumber(L, 2);
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative")
  arg3 = (UINT)lua_tonumber(L, 3);
  SWIG_contract_assert((lua_tonumber(L,4)>=0),"number must not be negative")
  arg4 = (UINT)lua_tonumber(L, 4);
  SWIG_contract_assert((lua_tonumber(L,5)>=0),"number must not be negative")
  arg5 = (UINT)lua_tonumber(L, 5);
  (arg1)->SetRGBA(arg2,arg3,arg4,arg5);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VColorRef_SetRGB(lua_State* L) {
  int SWIG_arg = 0;
  VColorRef *arg1 = (VColorRef *) 0 ;
  UINT arg2 ;
  UINT arg3 ;
  UINT arg4 ;
  
  SWIG_check_num_args("SetRGB",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetRGB",1,"VColorRef *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SetRGB",2,"UINT");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("SetRGB",3,"UINT");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("SetRGB",4,"UINT");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VColorRef,0))){
    SWIG_fail_ptr("VColorRef_SetRGB",1,SWIGTYPE_p_VColorRef);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (UINT)lua_tonumber(L, 2);
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative")
  arg3 = (UINT)lua_tonumber(L, 3);
  SWIG_contract_assert((lua_tonumber(L,4)>=0),"number must not be negative")
  arg4 = (UINT)lua_tonumber(L, 4);
  (arg1)->SetRGB(arg2,arg3,arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VColorRef___eq(lua_State* L) {
  int SWIG_arg = 0;
  VColorRef *arg1 = (VColorRef *) 0 ;
  VColorRef *arg2 = 0 ;
  bool result;
  
  SWIG_check_num_args("operator ==",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("operator ==",1,"VColorRef *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("operator ==",2,"VColorRef const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VColorRef,0))){
    SWIG_fail_ptr("VColorRef___eq",1,SWIGTYPE_p_VColorRef);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_VColorRef,0))){
    SWIG_fail_ptr("VColorRef___eq",2,SWIGTYPE_p_VColorRef);
  }
  
  result = (bool)(arg1)->operator ==((VColorRef const &)*arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VColorRef___add(lua_State* L) {
  int SWIG_arg = 0;
  VColorRef *arg1 = (VColorRef *) 0 ;
  VColorRef *arg2 = 0 ;
  VColorRef result;
  
  SWIG_check_num_args("operator +",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("operator +",1,"VColorRef const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("operator +",2,"VColorRef const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VColorRef,0))){
    SWIG_fail_ptr("VColorRef___add",1,SWIGTYPE_p_VColorRef);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_VColorRef,0))){
    SWIG_fail_ptr("VColorRef___add",2,SWIGTYPE_p_VColorRef);
  }
  
  result = ((VColorRef const *)arg1)->operator +((VColorRef const &)*arg2);
  {
    VColorRef * resultptr = new VColorRef((const VColorRef &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_VColorRef,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VColorRef___sub(lua_State* L) {
  int SWIG_arg = 0;
  VColorRef *arg1 = (VColorRef *) 0 ;
  VColorRef *arg2 = 0 ;
  VColorRef result;
  
  SWIG_check_num_args("operator -",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("operator -",1,"VColorRef const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("operator -",2,"VColorRef const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VColorRef,0))){
    SWIG_fail_ptr("VColorRef___sub",1,SWIGTYPE_p_VColorRef);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_VColorRef,0))){
    SWIG_fail_ptr("VColorRef___sub",2,SWIGTYPE_p_VColorRef);
  }
  
  result = ((VColorRef const *)arg1)->operator -((VColorRef const &)*arg2);
  {
    VColorRef * resultptr = new VColorRef((const VColorRef &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_VColorRef,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VColorRef___mul__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  VColorRef *arg1 = (VColorRef *) 0 ;
  VColorRef *arg2 = 0 ;
  VColorRef result;
  
  SWIG_check_num_args("operator *",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("operator *",1,"VColorRef const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("operator *",2,"VColorRef const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VColorRef,0))){
    SWIG_fail_ptr("VColorRef___mul",1,SWIGTYPE_p_VColorRef);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_VColorRef,0))){
    SWIG_fail_ptr("VColorRef___mul",2,SWIGTYPE_p_VColorRef);
  }
  
  result = ((VColorRef const *)arg1)->operator *((VColorRef const &)*arg2);
  {
    VColorRef * resultptr = new VColorRef((const VColorRef &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_VColorRef,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VColorRef___mul__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  VColorRef *arg1 = (VColorRef *) 0 ;
  float arg2 ;
  VColorRef result;
  
  SWIG_check_num_args("operator *",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("operator *",1,"VColorRef const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("operator *",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VColorRef,0))){
    SWIG_fail_ptr("VColorRef___mul",1,SWIGTYPE_p_VColorRef);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  result = ((VColorRef const *)arg1)->operator *(arg2);
  {
    VColorRef * resultptr = new VColorRef((const VColorRef &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_VColorRef,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VColorRef___mul(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VColorRef, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_VColorRef, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_VColorRef___mul__SWIG_0(L);
      }
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VColorRef, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_VColorRef___mul__SWIG_1(L);
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'VColorRef___mul'\n"
    "  Possible C/C++ prototypes are:\n"
    "    operator *(VColorRef const *,VColorRef const &)\n"
    "    operator *(VColorRef const *,float)\n");
  lua_error(L);return 0;
}


static int _wrap_VColorRef_IsZero(lua_State* L) {
  int SWIG_arg = 0;
  VColorRef *arg1 = (VColorRef *) 0 ;
  bool result;
  
  SWIG_check_num_args("IsZero",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("IsZero",1,"VColorRef const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VColorRef,0))){
    SWIG_fail_ptr("VColorRef_IsZero",1,SWIGTYPE_p_VColorRef);
  }
  
  result = (bool)((VColorRef const *)arg1)->IsZero();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VColorRef_IsBlack(lua_State* L) {
  int SWIG_arg = 0;
  VColorRef *arg1 = (VColorRef *) 0 ;
  bool result;
  
  SWIG_check_num_args("IsBlack",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("IsBlack",1,"VColorRef const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VColorRef,0))){
    SWIG_fail_ptr("VColorRef_IsBlack",1,SWIGTYPE_p_VColorRef);
  }
  
  result = (bool)((VColorRef const *)arg1)->IsBlack();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VColorRef_GetIntensity(lua_State* L) {
  int SWIG_arg = 0;
  VColorRef *arg1 = (VColorRef *) 0 ;
  float result;
  
  SWIG_check_num_args("GetIntensity",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetIntensity",1,"VColorRef const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VColorRef,0))){
    SWIG_fail_ptr("VColorRef_GetIntensity",1,SWIGTYPE_p_VColorRef);
  }
  
  result = (float)((VColorRef const *)arg1)->GetIntensity();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VColorRef_Lerp(lua_State* L) {
  int SWIG_arg = 0;
  VColorRef *arg1 = (VColorRef *) 0 ;
  VColorRef *arg2 = 0 ;
  VColorRef *arg3 = 0 ;
  float arg4 ;
  
  SWIG_check_num_args("Lerp",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Lerp",1,"VColorRef *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Lerp",2,"VColorRef const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("Lerp",3,"VColorRef const &");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Lerp",4,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VColorRef,0))){
    SWIG_fail_ptr("VColorRef_Lerp",1,SWIGTYPE_p_VColorRef);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_VColorRef,0))){
    SWIG_fail_ptr("VColorRef_Lerp",2,SWIGTYPE_p_VColorRef);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_VColorRef,0))){
    SWIG_fail_ptr("VColorRef_Lerp",3,SWIGTYPE_p_VColorRef);
  }
  
  arg4 = (float)lua_tonumber(L, 4);
  (arg1)->Lerp((VColorRef const &)*arg2,(VColorRef const &)*arg3,arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VColorRef_r_set(lua_State* L) {
  int SWIG_arg = 0;
  VColorRef *arg1 = (VColorRef *) 0 ;
  UBYTE arg2 ;
  
  SWIG_check_num_args("r",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("r",1,"VColorRef *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("r",2,"UBYTE");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VColorRef,0))){
    SWIG_fail_ptr("VColorRef_r_set",1,SWIGTYPE_p_VColorRef);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (UBYTE)lua_tonumber(L, 2);
  if (arg1) (arg1)->r = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VColorRef_r_get(lua_State* L) {
  int SWIG_arg = 0;
  VColorRef *arg1 = (VColorRef *) 0 ;
  UBYTE result;
  
  SWIG_check_num_args("r",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("r",1,"VColorRef *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VColorRef,0))){
    SWIG_fail_ptr("VColorRef_r_get",1,SWIGTYPE_p_VColorRef);
  }
  
  result = (UBYTE) ((arg1)->r);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VColorRef_g_set(lua_State* L) {
  int SWIG_arg = 0;
  VColorRef *arg1 = (VColorRef *) 0 ;
  UBYTE arg2 ;
  
  SWIG_check_num_args("g",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("g",1,"VColorRef *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("g",2,"UBYTE");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VColorRef,0))){
    SWIG_fail_ptr("VColorRef_g_set",1,SWIGTYPE_p_VColorRef);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (UBYTE)lua_tonumber(L, 2);
  if (arg1) (arg1)->g = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VColorRef_g_get(lua_State* L) {
  int SWIG_arg = 0;
  VColorRef *arg1 = (VColorRef *) 0 ;
  UBYTE result;
  
  SWIG_check_num_args("g",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("g",1,"VColorRef *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VColorRef,0))){
    SWIG_fail_ptr("VColorRef_g_get",1,SWIGTYPE_p_VColorRef);
  }
  
  result = (UBYTE) ((arg1)->g);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VColorRef_b_set(lua_State* L) {
  int SWIG_arg = 0;
  VColorRef *arg1 = (VColorRef *) 0 ;
  UBYTE arg2 ;
  
  SWIG_check_num_args("b",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("b",1,"VColorRef *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("b",2,"UBYTE");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VColorRef,0))){
    SWIG_fail_ptr("VColorRef_b_set",1,SWIGTYPE_p_VColorRef);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (UBYTE)lua_tonumber(L, 2);
  if (arg1) (arg1)->b = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VColorRef_b_get(lua_State* L) {
  int SWIG_arg = 0;
  VColorRef *arg1 = (VColorRef *) 0 ;
  UBYTE result;
  
  SWIG_check_num_args("b",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("b",1,"VColorRef *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VColorRef,0))){
    SWIG_fail_ptr("VColorRef_b_get",1,SWIGTYPE_p_VColorRef);
  }
  
  result = (UBYTE) ((arg1)->b);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VColorRef_a_set(lua_State* L) {
  int SWIG_arg = 0;
  VColorRef *arg1 = (VColorRef *) 0 ;
  UBYTE arg2 ;
  
  SWIG_check_num_args("a",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("a",1,"VColorRef *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("a",2,"UBYTE");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VColorRef,0))){
    SWIG_fail_ptr("VColorRef_a_set",1,SWIGTYPE_p_VColorRef);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (UBYTE)lua_tonumber(L, 2);
  if (arg1) (arg1)->a = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VColorRef_a_get(lua_State* L) {
  int SWIG_arg = 0;
  VColorRef *arg1 = (VColorRef *) 0 ;
  UBYTE result;
  
  SWIG_check_num_args("a",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("a",1,"VColorRef *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VColorRef,0))){
    SWIG_fail_ptr("VColorRef_a_get",1,SWIGTYPE_p_VColorRef);
  }
  
  result = (UBYTE) ((arg1)->a);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_VColorRef__SWIG_3(lua_State* L) {
  int SWIG_arg = 0;
  VColorRef *arg1 = 0 ;
  VColorRef *result = 0 ;
  
  SWIG_check_num_args("VColorRef",1,1)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("VColorRef",1,"VColorRef const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VColorRef,0))){
    SWIG_fail_ptr("new_VColorRef",1,SWIGTYPE_p_VColorRef);
  }
  
  result = (VColorRef *)new_VColorRef__SWIG_3((VColorRef const &)*arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_VColorRef,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_VColorRef(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 0) {
    return _wrap_new_VColorRef__SWIG_0(L);
  }
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VColorRef, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_new_VColorRef__SWIG_3(L);
    }
  }
  if (argc == 3) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          return _wrap_new_VColorRef__SWIG_2(L);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_new_VColorRef__SWIG_1(L);
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'new_VColorRef'\n"
    "  Possible C/C++ prototypes are:\n"
    "    VColorRef()\n"
    "    VColorRef(UBYTE,UBYTE,UBYTE,UBYTE)\n"
    "    VColorRef(UBYTE,UBYTE,UBYTE)\n"
    "    VColorRef(VColorRef const &)\n");
  lua_error(L);return 0;
}


static int _wrap_VColorRef_Clone(lua_State* L) {
  int SWIG_arg = 0;
  VColorRef *arg1 = (VColorRef *) 0 ;
  VColorRef result;
  
  SWIG_check_num_args("Clone",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Clone",1,"VColorRef *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VColorRef,0))){
    SWIG_fail_ptr("VColorRef_Clone",1,SWIGTYPE_p_VColorRef);
  }
  
  result = VColorRef_Clone(arg1);
  {
    VColorRef * resultptr = new VColorRef((const VColorRef &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_VColorRef,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VColorRef_clone(lua_State* L) {
  int SWIG_arg = 0;
  VColorRef *arg1 = (VColorRef *) 0 ;
  VColorRef result;
  
  SWIG_check_num_args("clone",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("clone",1,"VColorRef *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VColorRef,0))){
    SWIG_fail_ptr("VColorRef_clone",1,SWIGTYPE_p_VColorRef);
  }
  
  result = VColorRef_clone(arg1);
  {
    VColorRef * resultptr = new VColorRef((const VColorRef &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_VColorRef,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_VColorRef(void *obj) {
VColorRef *arg1 = (VColorRef *) obj;
delete arg1;
}
static swig_lua_method swig_VColorRef_methods[] = {
    { "__tostring",VColorRef_ToString},
    { "__concat",VColorRef_Concat},
    {"Clear", _wrap_VColorRef_Clear}, 
    {"SetRGBA", _wrap_VColorRef_SetRGBA}, 
    {"SetRGB", _wrap_VColorRef_SetRGB}, 
    {"__eq", _wrap_VColorRef___eq}, 
    {"__add", _wrap_VColorRef___add}, 
    {"__sub", _wrap_VColorRef___sub}, 
    {"__mul", _wrap_VColorRef___mul}, 
    {"IsZero", _wrap_VColorRef_IsZero}, 
    {"IsBlack", _wrap_VColorRef_IsBlack}, 
    {"GetIntensity", _wrap_VColorRef_GetIntensity}, 
    {"Lerp", _wrap_VColorRef_Lerp}, 
    {"Clone", _wrap_VColorRef_Clone}, 
    {"clone", _wrap_VColorRef_clone}, 
    {0,0}
};
static swig_lua_attribute swig_VColorRef_attributes[] = {
    { "r", _wrap_VColorRef_r_get, _wrap_VColorRef_r_set},
    { "g", _wrap_VColorRef_g_get, _wrap_VColorRef_g_set},
    { "b", _wrap_VColorRef_b_get, _wrap_VColorRef_b_set},
    { "a", _wrap_VColorRef_a_get, _wrap_VColorRef_a_set},
    {0,0,0}
};
static swig_lua_class *swig_VColorRef_bases[] = {0};
static const char *swig_VColorRef_base_names[] = {0};
static swig_lua_class _wrap_class_VColorRef = { "VColorRef", &SWIGTYPE_p_VColorRef,_wrap_new_VColorRef, swig_delete_VColorRef, swig_VColorRef_methods, swig_VColorRef_attributes, swig_VColorRef_bases, swig_VColorRef_base_names };

static int _wrap_new_VBitmask__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  VBitmask *result = 0 ;
  
  SWIG_check_num_args("VBitmask",0,0)
  result = (VBitmask *)new VBitmask();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_VBitmask,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_VBitmask__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  unsigned int arg1 ;
  VBitmask *result = 0 ;
  
  SWIG_check_num_args("VBitmask",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("VBitmask",1,"unsigned int");
  SWIG_contract_assert((lua_tonumber(L,1)>=0),"number must not be negative")
  arg1 = (unsigned int)lua_tonumber(L, 1);
  result = (VBitmask *)new VBitmask(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_VBitmask,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_VBitmask__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  char *arg1 = (char *) 0 ;
  VBitmask *result = 0 ;
  
  SWIG_check_num_args("VBitmask",1,1)
  if(!SWIG_lua_isnilstring(L,1)) SWIG_fail_arg("VBitmask",1,"char const *");
  arg1 = (char *)lua_tostring(L, 1);
  result = (VBitmask *)new VBitmask((char const *)arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_VBitmask,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_VBitmask__SWIG_3(lua_State* L) {
  int SWIG_arg = 0;
  bool arg1 ;
  VBitmask *result = 0 ;
  
  SWIG_check_num_args("VBitmask",1,1)
  if(!lua_isboolean(L,1)) SWIG_fail_arg("VBitmask",1,"bool");
  arg1 = (lua_toboolean(L, 1)!=0);
  result = (VBitmask *)new VBitmask(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_VBitmask,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_VBitmask__SWIG_4(lua_State* L) {
  int SWIG_arg = 0;
  VBitmask *arg1 = 0 ;
  VBitmask *result = 0 ;
  
  SWIG_check_num_args("VBitmask",1,1)
  if(!lua_isuserdata(L,1)) SWIG_fail_arg("VBitmask",1,"VBitmask const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VBitmask,0))){
    SWIG_fail_ptr("new_VBitmask",1,SWIGTYPE_p_VBitmask);
  }
  
  result = (VBitmask *)new VBitmask((VBitmask const &)*arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_VBitmask,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_VBitmask(lua_State* L) {
  int argc;
  int argv[2]={
    1,2
  };
  
  argc = lua_gettop(L);
  if (argc == 0) {
    return _wrap_new_VBitmask__SWIG_0(L);
  }
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VBitmask, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_new_VBitmask__SWIG_4(L);
    }
  }
  if (argc == 1) {
    int _v;
    {
      _v = lua_isboolean(L,argv[0]);
    }
    if (_v) {
      return _wrap_new_VBitmask__SWIG_3(L);
    }
  }
  if (argc == 1) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      return _wrap_new_VBitmask__SWIG_1(L);
    }
  }
  if (argc == 1) {
    int _v;
    {
      _v = SWIG_lua_isnilstring(L,argv[0]);
    }
    if (_v) {
      return _wrap_new_VBitmask__SWIG_2(L);
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'new_VBitmask'\n"
    "  Possible C/C++ prototypes are:\n"
    "    VBitmask()\n"
    "    VBitmask(unsigned int)\n"
    "    VBitmask(char const *)\n"
    "    VBitmask(bool)\n"
    "    VBitmask(VBitmask const &)\n");
  lua_error(L);return 0;
}


static int _wrap_VBitmask_Set__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  VBitmask *arg1 = (VBitmask *) 0 ;
  
  SWIG_check_num_args("Set",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Set",1,"VBitmask *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VBitmask,0))){
    SWIG_fail_ptr("VBitmask_Set",1,SWIGTYPE_p_VBitmask);
  }
  
  (arg1)->Set();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VBitmask_Set__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  VBitmask *arg1 = (VBitmask *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("Set",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Set",1,"VBitmask *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Set",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VBitmask,0))){
    SWIG_fail_ptr("VBitmask_Set",1,SWIGTYPE_p_VBitmask);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->Set(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VBitmask_Set__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  VBitmask *arg1 = (VBitmask *) 0 ;
  VBitmask *arg2 = (VBitmask *) 0 ;
  
  SWIG_check_num_args("Set",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Set",1,"VBitmask *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Set",2,"VBitmask const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VBitmask,0))){
    SWIG_fail_ptr("VBitmask_Set",1,SWIGTYPE_p_VBitmask);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_VBitmask,0))){
    SWIG_fail_ptr("VBitmask_Set",2,SWIGTYPE_p_VBitmask);
  }
  
  (arg1)->Set((VBitmask const *)arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VBitmask_Set__SWIG_3(lua_State* L) {
  int SWIG_arg = 0;
  VBitmask *arg1 = (VBitmask *) 0 ;
  char *arg2 = (char *) 0 ;
  
  SWIG_check_num_args("Set",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Set",1,"VBitmask *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("Set",2,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VBitmask,0))){
    SWIG_fail_ptr("VBitmask_Set",1,SWIGTYPE_p_VBitmask);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  (arg1)->Set((char const *)arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VBitmask_Set(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VBitmask, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_VBitmask_Set__SWIG_0(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VBitmask, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_VBitmask, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_VBitmask_Set__SWIG_2(L);
      }
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VBitmask, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_VBitmask_Set__SWIG_1(L);
      }
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VBitmask, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = SWIG_lua_isnilstring(L,argv[1]);
      }
      if (_v) {
        return _wrap_VBitmask_Set__SWIG_3(L);
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'VBitmask_Set'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Set(VBitmask *)\n"
    "    Set(VBitmask *,int)\n"
    "    Set(VBitmask *,VBitmask const *)\n"
    "    Set(VBitmask *,char const *)\n");
  lua_error(L);return 0;
}


static int _wrap_VBitmask_Clear__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  VBitmask *arg1 = (VBitmask *) 0 ;
  
  SWIG_check_num_args("Clear",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Clear",1,"VBitmask *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VBitmask,0))){
    SWIG_fail_ptr("VBitmask_Clear",1,SWIGTYPE_p_VBitmask);
  }
  
  (arg1)->Clear();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VBitmask_Clear__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  VBitmask *arg1 = (VBitmask *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("Clear",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Clear",1,"VBitmask *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Clear",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VBitmask,0))){
    SWIG_fail_ptr("VBitmask_Clear",1,SWIGTYPE_p_VBitmask);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->Clear(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VBitmask_Clear__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  VBitmask *arg1 = (VBitmask *) 0 ;
  VBitmask *arg2 = (VBitmask *) 0 ;
  
  SWIG_check_num_args("Clear",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Clear",1,"VBitmask *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Clear",2,"VBitmask const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VBitmask,0))){
    SWIG_fail_ptr("VBitmask_Clear",1,SWIGTYPE_p_VBitmask);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_VBitmask,0))){
    SWIG_fail_ptr("VBitmask_Clear",2,SWIGTYPE_p_VBitmask);
  }
  
  (arg1)->Clear((VBitmask const *)arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VBitmask_Clear__SWIG_3(lua_State* L) {
  int SWIG_arg = 0;
  VBitmask *arg1 = (VBitmask *) 0 ;
  char *arg2 = (char *) 0 ;
  
  SWIG_check_num_args("Clear",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Clear",1,"VBitmask *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("Clear",2,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VBitmask,0))){
    SWIG_fail_ptr("VBitmask_Clear",1,SWIGTYPE_p_VBitmask);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  (arg1)->Clear((char const *)arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VBitmask_Clear(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VBitmask, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_VBitmask_Clear__SWIG_0(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VBitmask, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_VBitmask, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_VBitmask_Clear__SWIG_2(L);
      }
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VBitmask, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_VBitmask_Clear__SWIG_1(L);
      }
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VBitmask, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = SWIG_lua_isnilstring(L,argv[1]);
      }
      if (_v) {
        return _wrap_VBitmask_Clear__SWIG_3(L);
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'VBitmask_Clear'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Clear(VBitmask *)\n"
    "    Clear(VBitmask *,int)\n"
    "    Clear(VBitmask *,VBitmask const *)\n"
    "    Clear(VBitmask *,char const *)\n");
  lua_error(L);return 0;
}


static int _wrap_VBitmask_IsSet__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  VBitmask *arg1 = (VBitmask *) 0 ;
  int arg2 ;
  bool result;
  
  SWIG_check_num_args("IsSet",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("IsSet",1,"VBitmask const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("IsSet",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VBitmask,0))){
    SWIG_fail_ptr("VBitmask_IsSet",1,SWIGTYPE_p_VBitmask);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  result = (bool)((VBitmask const *)arg1)->IsSet(arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VBitmask_IsSet__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  VBitmask *arg1 = (VBitmask *) 0 ;
  bool result;
  
  SWIG_check_num_args("IsSet",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("IsSet",1,"VBitmask const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VBitmask,0))){
    SWIG_fail_ptr("VBitmask_IsSet",1,SWIGTYPE_p_VBitmask);
  }
  
  result = (bool)((VBitmask const *)arg1)->IsSet();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VBitmask_IsSet(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VBitmask, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_VBitmask_IsSet__SWIG_1(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VBitmask, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_VBitmask_IsSet__SWIG_0(L);
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'VBitmask_IsSet'\n"
    "  Possible C/C++ prototypes are:\n"
    "    IsSet(VBitmask const *,int)\n"
    "    IsSet(VBitmask const *)\n");
  lua_error(L);return 0;
}


static int _wrap_VBitmask_Get(lua_State* L) {
  int SWIG_arg = 0;
  VBitmask *arg1 = (VBitmask *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("Get",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Get",1,"VBitmask const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VBitmask,0))){
    SWIG_fail_ptr("VBitmask_Get",1,SWIGTYPE_p_VBitmask);
  }
  
  result = (unsigned int)((VBitmask const *)arg1)->Get();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VBitmask___setitem(lua_State* L) {
  int SWIG_arg = 0;
  VBitmask *arg1 = (VBitmask *) 0 ;
  int arg2 ;
  bool arg3 ;
  
  SWIG_check_num_args("__setitem__",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("__setitem__",1,"VBitmask *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("__setitem__",2,"int");
  if(!lua_isboolean(L,3)) SWIG_fail_arg("__setitem__",3,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VBitmask,0))){
    SWIG_fail_ptr("VBitmask___setitem",1,SWIGTYPE_p_VBitmask);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (lua_toboolean(L, 3)!=0);
  (arg1)->__setitem__(arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VBitmask___getitem(lua_State* L) {
  int SWIG_arg = 0;
  VBitmask *arg1 = (VBitmask *) 0 ;
  int arg2 ;
  bool result;
  
  SWIG_check_num_args("__getitem__",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("__getitem__",1,"VBitmask const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("__getitem__",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VBitmask,0))){
    SWIG_fail_ptr("VBitmask___getitem",1,SWIGTYPE_p_VBitmask);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  result = (bool)((VBitmask const *)arg1)->__getitem__(arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VBitmask___eq(lua_State* L) {
  int SWIG_arg = 0;
  VBitmask *arg1 = (VBitmask *) 0 ;
  VBitmask *arg2 = 0 ;
  bool result;
  
  SWIG_check_num_args("operator ==",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("operator ==",1,"VBitmask const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("operator ==",2,"VBitmask const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VBitmask,0))){
    SWIG_fail_ptr("VBitmask___eq",1,SWIGTYPE_p_VBitmask);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_VBitmask,0))){
    SWIG_fail_ptr("VBitmask___eq",2,SWIGTYPE_p_VBitmask);
  }
  
  result = (bool)((VBitmask const *)arg1)->operator ==((VBitmask const &)*arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VBitmask_Clone(lua_State* L) {
  int SWIG_arg = 0;
  VBitmask *arg1 = (VBitmask *) 0 ;
  VBitmask result;
  
  SWIG_check_num_args("Clone",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Clone",1,"VBitmask *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VBitmask,0))){
    SWIG_fail_ptr("VBitmask_Clone",1,SWIGTYPE_p_VBitmask);
  }
  
  result = VBitmask_Clone(arg1);
  {
    VBitmask * resultptr = new VBitmask((const VBitmask &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_VBitmask,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_VBitmask(void *obj) {
VBitmask *arg1 = (VBitmask *) obj;
delete arg1;
}
static swig_lua_method swig_VBitmask_methods[] = {
    { "__tostring",VBitmask_ToString},
    { "__concat",VBitmask_Concat},
    {"Set", _wrap_VBitmask_Set}, 
    {"Clear", _wrap_VBitmask_Clear}, 
    {"IsSet", _wrap_VBitmask_IsSet}, 
    {"Get", _wrap_VBitmask_Get}, 
    {"__setitem", _wrap_VBitmask___setitem}, 
    {"__getitem", _wrap_VBitmask___getitem}, 
    {"__eq", _wrap_VBitmask___eq}, 
    {"Clone", _wrap_VBitmask_Clone}, 
    {0,0}
};
static swig_lua_attribute swig_VBitmask_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_VBitmask_bases[] = {0};
static const char *swig_VBitmask_base_names[] = {0};
static swig_lua_class _wrap_class_VBitmask = { "VBitmask", &SWIGTYPE_p_VBitmask,_wrap_new_VBitmask, swig_delete_VBitmask, swig_VBitmask_methods, swig_VBitmask_attributes, swig_VBitmask_bases, swig_VBitmask_base_names };

static int _wrap_VTypedObject_GetType(lua_State* L) {
  int SWIG_arg = 0;
  VTypedObject *arg1 = (VTypedObject *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("GetType",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetType",1,"VTypedObject const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VTypedObject,0))){
    SWIG_fail_ptr("VTypedObject_GetType",1,SWIGTYPE_p_VTypedObject);
  }
  
  result = (char *)VTypedObject_GetType((VTypedObject const *)arg1);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VTypedObject_IsOfType(lua_State* L) {
  int SWIG_arg = 0;
  VTypedObject *arg1 = (VTypedObject *) 0 ;
  char *arg2 = (char *) 0 ;
  bool result;
  
  SWIG_check_num_args("IsOfType",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("IsOfType",1,"VTypedObject *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("IsOfType",2,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VTypedObject,0))){
    SWIG_fail_ptr("VTypedObject_IsOfType",1,SWIGTYPE_p_VTypedObject);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  result = (bool)VTypedObject_IsOfType(arg1,(char const *)arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VTypedObject_GetPropertyType(lua_State* L) {
  int SWIG_arg = 0;
  VTypedObject *arg1 = (VTypedObject *) 0 ;
  char *arg2 = (char *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("GetPropertyType",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetPropertyType",1,"VTypedObject *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("GetPropertyType",2,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VTypedObject,0))){
    SWIG_fail_ptr("VTypedObject_GetPropertyType",1,SWIGTYPE_p_VTypedObject);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  result = (char *)VTypedObject_GetPropertyType(arg1,(char const *)arg2);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VTypedObject___eq(lua_State* L) {
  int SWIG_arg = 0;
  VTypedObject *arg1 = (VTypedObject *) 0 ;
  VTypedObject *arg2 = 0 ;
  bool result;
  
  SWIG_check_num_args("operator ==",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("operator ==",1,"VTypedObject *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("operator ==",2,"VTypedObject const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VTypedObject,0))){
    SWIG_fail_ptr("VTypedObject___eq",1,SWIGTYPE_p_VTypedObject);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_VTypedObject,0))){
    SWIG_fail_ptr("VTypedObject___eq",2,SWIGTYPE_p_VTypedObject);
  }
  
  result = (bool)VTypedObject_operator_Se__Se_(arg1,(VTypedObject const &)*arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VTypedObject_GetNumProperties(lua_State* L) {
  int SWIG_arg = 0;
  VTypedObject *arg1 = (VTypedObject *) 0 ;
  int result;
  
  SWIG_check_num_args("GetNumVariables",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetNumVariables",1,"VTypedObject const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VTypedObject,0))){
    SWIG_fail_ptr("VTypedObject_GetNumProperties",1,SWIGTYPE_p_VTypedObject);
  }
  
  result = (int)((VTypedObject const *)arg1)->GetNumVariables();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VTypedObject_UpdateProperty(lua_State* L) {
  int SWIG_arg = 0;
  VTypedObject *arg1 = (VTypedObject *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  bool result;
  
  SWIG_check_num_args("SetVariable",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetVariable",1,"VTypedObject *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("SetVariable",2,"char const *");
  if(!SWIG_lua_isnilstring(L,3)) SWIG_fail_arg("SetVariable",3,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VTypedObject,0))){
    SWIG_fail_ptr("VTypedObject_UpdateProperty",1,SWIGTYPE_p_VTypedObject);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  arg3 = (char *)lua_tostring(L, 3);
  result = (bool)(arg1)->SetVariable((char const *)arg2,(char const *)arg3);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static swig_lua_method swig_VTypedObject_methods[] = {
    { "__tostring",VTypedObject_ToString},
    { "SetProperty",VTypedObject_SetProperty},
    { "GetProperty",VTypedObject_GetProperty},
    { "GetProperties",VTypedObject_GetProperties},
    { "__concat",VTypedObject_Concat},
    {"GetType", _wrap_VTypedObject_GetType}, 
    {"IsOfType", _wrap_VTypedObject_IsOfType}, 
    {"GetPropertyType", _wrap_VTypedObject_GetPropertyType}, 
    {"__eq", _wrap_VTypedObject___eq}, 
    {"GetNumProperties", _wrap_VTypedObject_GetNumProperties}, 
    {"UpdateProperty", _wrap_VTypedObject_UpdateProperty}, 
    {0,0}
};
static swig_lua_attribute swig_VTypedObject_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_VTypedObject_bases[] = {0};
static const char *swig_VTypedObject_base_names[] = {0};
static swig_lua_class _wrap_class_VTypedObject = { "VTypedObject", &SWIGTYPE_p_VTypedObject,0,0, swig_VTypedObject_methods, swig_VTypedObject_attributes, swig_VTypedObject_bases, swig_VTypedObject_base_names };

static int _wrap_VisTypedEngineObject_cl_GetComponentCount(lua_State* L) {
  int SWIG_arg = 0;
  VisTypedEngineObject_cl *arg1 = (VisTypedEngineObject_cl *) 0 ;
  int result;
  
  SWIG_check_num_args("GetComponentCount",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetComponentCount",1,"VisTypedEngineObject_cl *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisTypedEngineObject_cl,0))){
    SWIG_fail_ptr("VisTypedEngineObject_cl_GetComponentCount",1,SWIGTYPE_p_VisTypedEngineObject_cl);
  }
  
  result = (int)VisTypedEngineObject_cl_GetComponentCount(arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisTypedEngineObject_cl_AddComponent(lua_State* L) {
  int SWIG_arg = 0;
  VisTypedEngineObject_cl *arg1 = (VisTypedEngineObject_cl *) 0 ;
  IVObjectComponent *arg2 = (IVObjectComponent *) 0 ;
  bool result;
  
  SWIG_check_num_args("AddComponent",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("AddComponent",1,"VisTypedEngineObject_cl *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("AddComponent",2,"IVObjectComponent *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisTypedEngineObject_cl,0))){
    SWIG_fail_ptr("VisTypedEngineObject_cl_AddComponent",1,SWIGTYPE_p_VisTypedEngineObject_cl);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_IVObjectComponent,0))){
    SWIG_fail_ptr("VisTypedEngineObject_cl_AddComponent",2,SWIGTYPE_p_IVObjectComponent);
  }
  
  result = (bool)VisTypedEngineObject_cl_AddComponent(arg1,arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisTypedEngineObject_cl_RemoveComponent(lua_State* L) {
  int SWIG_arg = 0;
  VisTypedEngineObject_cl *arg1 = (VisTypedEngineObject_cl *) 0 ;
  IVObjectComponent *arg2 = (IVObjectComponent *) 0 ;
  bool result;
  
  SWIG_check_num_args("RemoveComponent",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("RemoveComponent",1,"VisTypedEngineObject_cl *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("RemoveComponent",2,"IVObjectComponent *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisTypedEngineObject_cl,0))){
    SWIG_fail_ptr("VisTypedEngineObject_cl_RemoveComponent",1,SWIGTYPE_p_VisTypedEngineObject_cl);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_IVObjectComponent,0))){
    SWIG_fail_ptr("VisTypedEngineObject_cl_RemoveComponent",2,SWIGTYPE_p_IVObjectComponent);
  }
  
  result = (bool)VisTypedEngineObject_cl_RemoveComponent(arg1,arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisTypedEngineObject_cl_RemoveComponentOfType__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  VisTypedEngineObject_cl *arg1 = (VisTypedEngineObject_cl *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  bool result;
  
  SWIG_check_num_args("RemoveComponentOfType",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("RemoveComponentOfType",1,"VisTypedEngineObject_cl *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("RemoveComponentOfType",2,"char const *");
  if(!SWIG_lua_isnilstring(L,3)) SWIG_fail_arg("RemoveComponentOfType",3,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisTypedEngineObject_cl,0))){
    SWIG_fail_ptr("VisTypedEngineObject_cl_RemoveComponentOfType",1,SWIGTYPE_p_VisTypedEngineObject_cl);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  arg3 = (char *)lua_tostring(L, 3);
  result = (bool)VisTypedEngineObject_cl_RemoveComponentOfType__SWIG_0(arg1,(char const *)arg2,(char const *)arg3);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisTypedEngineObject_cl_RemoveComponentOfType__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  VisTypedEngineObject_cl *arg1 = (VisTypedEngineObject_cl *) 0 ;
  char *arg2 = (char *) 0 ;
  bool result;
  
  SWIG_check_num_args("RemoveComponentOfType",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("RemoveComponentOfType",1,"VisTypedEngineObject_cl *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("RemoveComponentOfType",2,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisTypedEngineObject_cl,0))){
    SWIG_fail_ptr("VisTypedEngineObject_cl_RemoveComponentOfType",1,SWIGTYPE_p_VisTypedEngineObject_cl);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  result = (bool)VisTypedEngineObject_cl_RemoveComponentOfType__SWIG_0(arg1,(char const *)arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisTypedEngineObject_cl_RemoveComponentOfType(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VisTypedEngineObject_cl, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = SWIG_lua_isnilstring(L,argv[1]);
      }
      if (_v) {
        return _wrap_VisTypedEngineObject_cl_RemoveComponentOfType__SWIG_1(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VisTypedEngineObject_cl, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = SWIG_lua_isnilstring(L,argv[1]);
      }
      if (_v) {
        {
          _v = SWIG_lua_isnilstring(L,argv[2]);
        }
        if (_v) {
          return _wrap_VisTypedEngineObject_cl_RemoveComponentOfType__SWIG_0(L);
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'VisTypedEngineObject_cl_RemoveComponentOfType'\n"
    "  Possible C/C++ prototypes are:\n"
    "    RemoveComponentOfType(VisTypedEngineObject_cl *,char const *,char const *)\n"
    "    RemoveComponentOfType(VisTypedEngineObject_cl *,char const *)\n");
  lua_error(L);return 0;
}


static int _wrap_VisTypedEngineObject_cl_RemoveAllComponents(lua_State* L) {
  int SWIG_arg = 0;
  VisTypedEngineObject_cl *arg1 = (VisTypedEngineObject_cl *) 0 ;
  
  SWIG_check_num_args("RemoveAllComponents",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("RemoveAllComponents",1,"VisTypedEngineObject_cl *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisTypedEngineObject_cl,0))){
    SWIG_fail_ptr("VisTypedEngineObject_cl_RemoveAllComponents",1,SWIGTYPE_p_VisTypedEngineObject_cl);
  }
  
  (arg1)->RemoveAllComponents();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static swig_lua_method swig_VisTypedEngineObject_cl_methods[] = {
    { "__tostring",VisTypedEngineObject_cl_ToString},
    { "GetComponentOfType",VisTypedEngineObject_cl_GetComponentOfType},
    { "GetComponentOfBaseType",VisTypedEngineObject_cl_GetComponentOfBaseType},
    { "GetComponentAt",VisTypedEngineObject_cl_GetComponentAt},
    { "__concat",VisTypedEngineObject_cl_Concat},
    { "AddTriggerTarget",VisTypedEngineObject_cl_AddTriggerTarget},
    { "AddTriggerSource",VisTypedEngineObject_cl_AddTriggerSource},
    { "AddTransitionStateMachine",VisTypedEngineObject_cl_AddTransitionStateMachine},
    { "AddTimedValue",VisTypedEngineObject_cl_AddTimedValue},
    { "AddComponentOfType",VisTypedEngineObject_cl_AddComponentOfType},
    { "AddAnimation",VisTypedEngineObject_cl_AddAnimation},
    {"GetComponentCount", _wrap_VisTypedEngineObject_cl_GetComponentCount}, 
    {"AddComponent", _wrap_VisTypedEngineObject_cl_AddComponent}, 
    {"RemoveComponent", _wrap_VisTypedEngineObject_cl_RemoveComponent}, 
    {"RemoveComponentOfType", _wrap_VisTypedEngineObject_cl_RemoveComponentOfType}, 
    {"RemoveAllComponents", _wrap_VisTypedEngineObject_cl_RemoveAllComponents}, 
    {0,0}
};
static swig_lua_attribute swig_VisTypedEngineObject_cl_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_VisTypedEngineObject_cl_bases[] = {0,0};
static const char *swig_VisTypedEngineObject_cl_base_names[] = {"VTypedObject *",0};
static swig_lua_class _wrap_class_VisTypedEngineObject_cl = { "VisTypedEngineObject_cl", &SWIGTYPE_p_VisTypedEngineObject_cl,0,0, swig_VisTypedEngineObject_cl_methods, swig_VisTypedEngineObject_cl_attributes, swig_VisTypedEngineObject_cl_bases, swig_VisTypedEngineObject_cl_base_names };

static int _wrap_VisObjectKey_cl_SetKey(lua_State* L) {
  int SWIG_arg = 0;
  VisObjectKey_cl *arg1 = (VisObjectKey_cl *) 0 ;
  char *arg2 = (char *) 0 ;
  
  SWIG_check_num_args("SetObjectKey",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetObjectKey",1,"VisObjectKey_cl *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("SetObjectKey",2,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisObjectKey_cl,0))){
    SWIG_fail_ptr("VisObjectKey_cl_SetKey",1,SWIGTYPE_p_VisObjectKey_cl);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  (arg1)->SetObjectKey((char const *)arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisObjectKey_cl_GetKey(lua_State* L) {
  int SWIG_arg = 0;
  VisObjectKey_cl *arg1 = (VisObjectKey_cl *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("GetObjectKey",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetObjectKey",1,"VisObjectKey_cl const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisObjectKey_cl,0))){
    SWIG_fail_ptr("VisObjectKey_cl_GetKey",1,SWIGTYPE_p_VisObjectKey_cl);
  }
  
  result = (char *)((VisObjectKey_cl const *)arg1)->GetObjectKey();
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisObjectKey_cl_HasKey__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  VisObjectKey_cl *arg1 = (VisObjectKey_cl *) 0 ;
  char *arg2 = (char *) 0 ;
  bool arg3 ;
  bool result;
  
  SWIG_check_num_args("HasKey",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("HasKey",1,"VisObjectKey_cl *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("HasKey",2,"char const *");
  if(!lua_isboolean(L,3)) SWIG_fail_arg("HasKey",3,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisObjectKey_cl,0))){
    SWIG_fail_ptr("VisObjectKey_cl_HasKey",1,SWIGTYPE_p_VisObjectKey_cl);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  arg3 = (lua_toboolean(L, 3)!=0);
  result = (bool)VisObjectKey_cl_HasKey__SWIG_0(arg1,(char const *)arg2,arg3);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisObjectKey_cl_HasKey__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  VisObjectKey_cl *arg1 = (VisObjectKey_cl *) 0 ;
  char *arg2 = (char *) 0 ;
  bool result;
  
  SWIG_check_num_args("HasKey",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("HasKey",1,"VisObjectKey_cl *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("HasKey",2,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisObjectKey_cl,0))){
    SWIG_fail_ptr("VisObjectKey_cl_HasKey",1,SWIGTYPE_p_VisObjectKey_cl);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  result = (bool)VisObjectKey_cl_HasKey__SWIG_0(arg1,(char const *)arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisObjectKey_cl_HasKey(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VisObjectKey_cl, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = SWIG_lua_isnilstring(L,argv[1]);
      }
      if (_v) {
        return _wrap_VisObjectKey_cl_HasKey__SWIG_1(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VisObjectKey_cl, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = SWIG_lua_isnilstring(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isboolean(L,argv[2]);
        }
        if (_v) {
          return _wrap_VisObjectKey_cl_HasKey__SWIG_0(L);
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'VisObjectKey_cl_HasKey'\n"
    "  Possible C/C++ prototypes are:\n"
    "    HasKey(VisObjectKey_cl *,char const *,bool)\n"
    "    HasKey(VisObjectKey_cl *,char const *)\n");
  lua_error(L);return 0;
}


static swig_lua_method swig_VisObjectKey_cl_methods[] = {
    {"SetKey", _wrap_VisObjectKey_cl_SetKey}, 
    {"GetKey", _wrap_VisObjectKey_cl_GetKey}, 
    {"HasKey", _wrap_VisObjectKey_cl_HasKey}, 
    {0,0}
};
static swig_lua_attribute swig_VisObjectKey_cl_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_VisObjectKey_cl_bases[] = {0};
static const char *swig_VisObjectKey_cl_base_names[] = {0};
static swig_lua_class _wrap_class_VisObjectKey_cl = { "VisObjectKey_cl", &SWIGTYPE_p_VisObjectKey_cl,0,0, swig_VisObjectKey_cl_methods, swig_VisObjectKey_cl_attributes, swig_VisObjectKey_cl_bases, swig_VisObjectKey_cl_base_names };

static int _wrap_VisObject3D_cl_SetPosition__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  VisObject3D_cl *arg1 = (VisObject3D_cl *) 0 ;
  hkvVec3 *arg2 = 0 ;
  
  SWIG_check_num_args("SetPosition",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetPosition",1,"VisObject3D_cl *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("SetPosition",2,"hkvVec3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisObject3D_cl,0))){
    SWIG_fail_ptr("VisObject3D_cl_SetPosition",1,SWIGTYPE_p_VisObject3D_cl);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("VisObject3D_cl_SetPosition",2,SWIGTYPE_p_hkvVec3);
  }
  
  (arg1)->SetPosition((hkvVec3 const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisObject3D_cl_IncPosition__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  VisObject3D_cl *arg1 = (VisObject3D_cl *) 0 ;
  hkvVec3 *arg2 = 0 ;
  
  SWIG_check_num_args("IncPosition",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("IncPosition",1,"VisObject3D_cl *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("IncPosition",2,"hkvVec3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisObject3D_cl,0))){
    SWIG_fail_ptr("VisObject3D_cl_IncPosition",1,SWIGTYPE_p_VisObject3D_cl);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("VisObject3D_cl_IncPosition",2,SWIGTYPE_p_hkvVec3);
  }
  
  (arg1)->IncPosition((hkvVec3 const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisObject3D_cl_GetPosition(lua_State* L) {
  int SWIG_arg = 0;
  VisObject3D_cl *arg1 = (VisObject3D_cl *) 0 ;
  SwigValueWrapper< hkvVec3 > result;
  
  SWIG_check_num_args("GetPosition",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetPosition",1,"VisObject3D_cl *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisObject3D_cl,0))){
    SWIG_fail_ptr("VisObject3D_cl_GetPosition",1,SWIGTYPE_p_VisObject3D_cl);
  }
  
  result = VisObject3D_cl_GetPosition(arg1);
  {
    hkvVec3 * resultptr = new hkvVec3((const hkvVec3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_hkvVec3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisObject3D_cl_SetPosition__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  VisObject3D_cl *arg1 = (VisObject3D_cl *) 0 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  
  SWIG_check_num_args("SetPosition",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetPosition",1,"VisObject3D_cl *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SetPosition",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("SetPosition",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("SetPosition",4,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisObject3D_cl,0))){
    SWIG_fail_ptr("VisObject3D_cl_SetPosition",1,SWIGTYPE_p_VisObject3D_cl);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4);
  VisObject3D_cl_SetPosition__SWIG_1(arg1,arg2,arg3,arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisObject3D_cl_SetPosition(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VisObject3D_cl, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_hkvVec3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_VisObject3D_cl_SetPosition__SWIG_0(L);
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VisObject3D_cl, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_VisObject3D_cl_SetPosition__SWIG_1(L);
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'VisObject3D_cl_SetPosition'\n"
    "  Possible C/C++ prototypes are:\n"
    "    SetPosition(VisObject3D_cl *,hkvVec3 const &)\n"
    "    SetPosition(VisObject3D_cl *,float,float,float)\n");
  lua_error(L);return 0;
}


static int _wrap_VisObject3D_cl_IncPosition__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  VisObject3D_cl *arg1 = (VisObject3D_cl *) 0 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  
  SWIG_check_num_args("IncPosition",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("IncPosition",1,"VisObject3D_cl *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("IncPosition",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("IncPosition",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("IncPosition",4,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisObject3D_cl,0))){
    SWIG_fail_ptr("VisObject3D_cl_IncPosition",1,SWIGTYPE_p_VisObject3D_cl);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4);
  VisObject3D_cl_IncPosition__SWIG_1(arg1,arg2,arg3,arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisObject3D_cl_IncPosition(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VisObject3D_cl, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_hkvVec3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_VisObject3D_cl_IncPosition__SWIG_0(L);
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VisObject3D_cl, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_VisObject3D_cl_IncPosition__SWIG_1(L);
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'VisObject3D_cl_IncPosition'\n"
    "  Possible C/C++ prototypes are:\n"
    "    IncPosition(VisObject3D_cl *,hkvVec3 const &)\n"
    "    IncPosition(VisObject3D_cl *,float,float,float)\n");
  lua_error(L);return 0;
}


static int _wrap_VisObject3D_cl_SetOrientation__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  VisObject3D_cl *arg1 = (VisObject3D_cl *) 0 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  
  SWIG_check_num_args("SetOrientation",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetOrientation",1,"VisObject3D_cl *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SetOrientation",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("SetOrientation",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("SetOrientation",4,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisObject3D_cl,0))){
    SWIG_fail_ptr("VisObject3D_cl_SetOrientation",1,SWIGTYPE_p_VisObject3D_cl);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4);
  VisObject3D_cl_SetOrientation__SWIG_0(arg1,arg2,arg3,arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisObject3D_cl_IncOrientation__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  VisObject3D_cl *arg1 = (VisObject3D_cl *) 0 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  
  SWIG_check_num_args("IncOrientation",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("IncOrientation",1,"VisObject3D_cl *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("IncOrientation",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("IncOrientation",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("IncOrientation",4,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisObject3D_cl,0))){
    SWIG_fail_ptr("VisObject3D_cl_IncOrientation",1,SWIGTYPE_p_VisObject3D_cl);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4);
  VisObject3D_cl_IncOrientation__SWIG_0(arg1,arg2,arg3,arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisObject3D_cl_SetUseEulerAngles(lua_State* L) {
  int SWIG_arg = 0;
  VisObject3D_cl *arg1 = (VisObject3D_cl *) 0 ;
  bool arg2 ;
  
  SWIG_check_num_args("SetUseEulerAngles",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetUseEulerAngles",1,"VisObject3D_cl *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("SetUseEulerAngles",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisObject3D_cl,0))){
    SWIG_fail_ptr("VisObject3D_cl_SetUseEulerAngles",1,SWIGTYPE_p_VisObject3D_cl);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  VisObject3D_cl_SetUseEulerAngles(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisObject3D_cl_GetUseEulerAngles(lua_State* L) {
  int SWIG_arg = 0;
  VisObject3D_cl *arg1 = (VisObject3D_cl *) 0 ;
  bool result;
  
  SWIG_check_num_args("GetUseEulerAngles",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetUseEulerAngles",1,"VisObject3D_cl const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisObject3D_cl,0))){
    SWIG_fail_ptr("VisObject3D_cl_GetUseEulerAngles",1,SWIGTYPE_p_VisObject3D_cl);
  }
  
  result = (bool)VisObject3D_cl_GetUseEulerAngles((VisObject3D_cl const *)arg1);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisObject3D_cl_TransformToObjectSpace(lua_State* L) {
  int SWIG_arg = 0;
  VisObject3D_cl *arg1 = (VisObject3D_cl *) 0 ;
  hkvVec3 *arg2 = 0 ;
  SwigValueWrapper< hkvVec3 > result;
  
  SWIG_check_num_args("TransformToObjectSpace",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("TransformToObjectSpace",1,"VisObject3D_cl const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("TransformToObjectSpace",2,"hkvVec3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisObject3D_cl,0))){
    SWIG_fail_ptr("VisObject3D_cl_TransformToObjectSpace",1,SWIGTYPE_p_VisObject3D_cl);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("VisObject3D_cl_TransformToObjectSpace",2,SWIGTYPE_p_hkvVec3);
  }
  
  result = ((VisObject3D_cl const *)arg1)->TransformToObjectSpace((hkvVec3 const &)*arg2);
  {
    hkvVec3 * resultptr = new hkvVec3((const hkvVec3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_hkvVec3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisObject3D_cl_SetOrientation__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  VisObject3D_cl *arg1 = (VisObject3D_cl *) 0 ;
  hkvVec3 *arg2 = 0 ;
  
  SWIG_check_num_args("SetOrientation",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetOrientation",1,"VisObject3D_cl *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("SetOrientation",2,"hkvVec3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisObject3D_cl,0))){
    SWIG_fail_ptr("VisObject3D_cl_SetOrientation",1,SWIGTYPE_p_VisObject3D_cl);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("VisObject3D_cl_SetOrientation",2,SWIGTYPE_p_hkvVec3);
  }
  
  (arg1)->SetOrientation((hkvVec3 const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisObject3D_cl_SetOrientation(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VisObject3D_cl, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_hkvVec3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_VisObject3D_cl_SetOrientation__SWIG_1(L);
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VisObject3D_cl, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_VisObject3D_cl_SetOrientation__SWIG_0(L);
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'VisObject3D_cl_SetOrientation'\n"
    "  Possible C/C++ prototypes are:\n"
    "    SetOrientation(VisObject3D_cl *,float,float,float)\n"
    "    SetOrientation(VisObject3D_cl *,hkvVec3 const &)\n");
  lua_error(L);return 0;
}


static int _wrap_VisObject3D_cl_IncOrientation__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  VisObject3D_cl *arg1 = (VisObject3D_cl *) 0 ;
  hkvVec3 *arg2 = 0 ;
  
  SWIG_check_num_args("IncOrientation",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("IncOrientation",1,"VisObject3D_cl *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("IncOrientation",2,"hkvVec3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisObject3D_cl,0))){
    SWIG_fail_ptr("VisObject3D_cl_IncOrientation",1,SWIGTYPE_p_VisObject3D_cl);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("VisObject3D_cl_IncOrientation",2,SWIGTYPE_p_hkvVec3);
  }
  
  (arg1)->IncOrientation((hkvVec3 const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisObject3D_cl_IncOrientation(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VisObject3D_cl, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_hkvVec3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_VisObject3D_cl_IncOrientation__SWIG_1(L);
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VisObject3D_cl, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_VisObject3D_cl_IncOrientation__SWIG_0(L);
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'VisObject3D_cl_IncOrientation'\n"
    "  Possible C/C++ prototypes are:\n"
    "    IncOrientation(VisObject3D_cl *,float,float,float)\n"
    "    IncOrientation(VisObject3D_cl *,hkvVec3 const &)\n");
  lua_error(L);return 0;
}


static int _wrap_VisObject3D_cl_GetOrientation(lua_State* L) {
  int SWIG_arg = 0;
  VisObject3D_cl *arg1 = (VisObject3D_cl *) 0 ;
  SwigValueWrapper< hkvVec3 > result;
  
  SWIG_check_num_args("GetActualOrientation",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetActualOrientation",1,"VisObject3D_cl const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisObject3D_cl,0))){
    SWIG_fail_ptr("VisObject3D_cl_GetOrientation",1,SWIGTYPE_p_VisObject3D_cl);
  }
  
  result = ((VisObject3D_cl const *)arg1)->GetActualOrientation();
  {
    hkvVec3 * resultptr = new hkvVec3((const hkvVec3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_hkvVec3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisObject3D_cl_SetRotationMatrix(lua_State* L) {
  int SWIG_arg = 0;
  VisObject3D_cl *arg1 = (VisObject3D_cl *) 0 ;
  hkvMat3 *arg2 = 0 ;
  
  SWIG_check_num_args("SetRotationMatrix",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetRotationMatrix",1,"VisObject3D_cl *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("SetRotationMatrix",2,"hkvMat3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisObject3D_cl,0))){
    SWIG_fail_ptr("VisObject3D_cl_SetRotationMatrix",1,SWIGTYPE_p_VisObject3D_cl);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_hkvMat3,0))){
    SWIG_fail_ptr("VisObject3D_cl_SetRotationMatrix",2,SWIGTYPE_p_hkvMat3);
  }
  
  (arg1)->SetRotationMatrix((hkvMat3 const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisObject3D_cl_GetRotationMatrix(lua_State* L) {
  int SWIG_arg = 0;
  VisObject3D_cl *arg1 = (VisObject3D_cl *) 0 ;
  SwigValueWrapper< hkvMat3 > result;
  
  SWIG_check_num_args("GetRotationMatrix",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetRotationMatrix",1,"VisObject3D_cl const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisObject3D_cl,0))){
    SWIG_fail_ptr("VisObject3D_cl_GetRotationMatrix",1,SWIGTYPE_p_VisObject3D_cl);
  }
  
  result = ((VisObject3D_cl const *)arg1)->GetRotationMatrix();
  {
    hkvMat3 * resultptr = new hkvMat3((const hkvMat3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_hkvMat3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisObject3D_cl_GetTransposedRotationMatrix(lua_State* L) {
  int SWIG_arg = 0;
  VisObject3D_cl *arg1 = (VisObject3D_cl *) 0 ;
  SwigValueWrapper< hkvMat3 > result;
  
  SWIG_check_num_args("GetTransposedRotationMatrix",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetTransposedRotationMatrix",1,"VisObject3D_cl const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisObject3D_cl,0))){
    SWIG_fail_ptr("VisObject3D_cl_GetTransposedRotationMatrix",1,SWIGTYPE_p_VisObject3D_cl);
  }
  
  result = ((VisObject3D_cl const *)arg1)->GetTransposedRotationMatrix();
  {
    hkvMat3 * resultptr = new hkvMat3((const hkvMat3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_hkvMat3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisObject3D_cl_GetDirection(lua_State* L) {
  int SWIG_arg = 0;
  VisObject3D_cl *arg1 = (VisObject3D_cl *) 0 ;
  SwigValueWrapper< hkvVec3 > result;
  
  SWIG_check_num_args("GetDirection",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetDirection",1,"VisObject3D_cl const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisObject3D_cl,0))){
    SWIG_fail_ptr("VisObject3D_cl_GetDirection",1,SWIGTYPE_p_VisObject3D_cl);
  }
  
  result = ((VisObject3D_cl const *)arg1)->GetDirection();
  {
    hkvVec3 * resultptr = new hkvVec3((const hkvVec3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_hkvVec3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisObject3D_cl_SetDirection(lua_State* L) {
  int SWIG_arg = 0;
  VisObject3D_cl *arg1 = (VisObject3D_cl *) 0 ;
  hkvVec3 *arg2 = 0 ;
  
  SWIG_check_num_args("SetDirection",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetDirection",1,"VisObject3D_cl *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("SetDirection",2,"hkvVec3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisObject3D_cl,0))){
    SWIG_fail_ptr("VisObject3D_cl_SetDirection",1,SWIGTYPE_p_VisObject3D_cl);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("VisObject3D_cl_SetDirection",2,SWIGTYPE_p_hkvVec3);
  }
  
  (arg1)->SetDirection((hkvVec3 const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisObject3D_cl_AttachToParent(lua_State* L) {
  int SWIG_arg = 0;
  VisObject3D_cl *arg1 = (VisObject3D_cl *) 0 ;
  VisObject3D_cl *arg2 = (VisObject3D_cl *) 0 ;
  
  SWIG_check_num_args("AttachToParent",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("AttachToParent",1,"VisObject3D_cl *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("AttachToParent",2,"VisObject3D_cl *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisObject3D_cl,0))){
    SWIG_fail_ptr("VisObject3D_cl_AttachToParent",1,SWIGTYPE_p_VisObject3D_cl);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_VisObject3D_cl,0))){
    SWIG_fail_ptr("VisObject3D_cl_AttachToParent",2,SWIGTYPE_p_VisObject3D_cl);
  }
  
  (arg1)->AttachToParent(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisObject3D_cl_DetachFromParent(lua_State* L) {
  int SWIG_arg = 0;
  VisObject3D_cl *arg1 = (VisObject3D_cl *) 0 ;
  
  SWIG_check_num_args("DetachFromParent",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("DetachFromParent",1,"VisObject3D_cl *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisObject3D_cl,0))){
    SWIG_fail_ptr("VisObject3D_cl_DetachFromParent",1,SWIGTYPE_p_VisObject3D_cl);
  }
  
  (arg1)->DetachFromParent();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisObject3D_cl_GetNumChildren(lua_State* L) {
  int SWIG_arg = 0;
  VisObject3D_cl *arg1 = (VisObject3D_cl *) 0 ;
  int result;
  
  SWIG_check_num_args("GetNumChildren",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetNumChildren",1,"VisObject3D_cl *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisObject3D_cl,0))){
    SWIG_fail_ptr("VisObject3D_cl_GetNumChildren",1,SWIGTYPE_p_VisObject3D_cl);
  }
  
  result = (int)(arg1)->GetNumChildren();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisObject3D_cl_SetLocalPosition(lua_State* L) {
  int SWIG_arg = 0;
  VisObject3D_cl *arg1 = (VisObject3D_cl *) 0 ;
  hkvVec3 *arg2 = 0 ;
  
  SWIG_check_num_args("SetLocalPosition",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetLocalPosition",1,"VisObject3D_cl *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("SetLocalPosition",2,"hkvVec3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisObject3D_cl,0))){
    SWIG_fail_ptr("VisObject3D_cl_SetLocalPosition",1,SWIGTYPE_p_VisObject3D_cl);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("VisObject3D_cl_SetLocalPosition",2,SWIGTYPE_p_hkvVec3);
  }
  
  (arg1)->SetLocalPosition((hkvVec3 const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisObject3D_cl_GetLocalPosition(lua_State* L) {
  int SWIG_arg = 0;
  VisObject3D_cl *arg1 = (VisObject3D_cl *) 0 ;
  SwigValueWrapper< hkvVec3 > result;
  
  SWIG_check_num_args("GetLocalPosition",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetLocalPosition",1,"VisObject3D_cl const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisObject3D_cl,0))){
    SWIG_fail_ptr("VisObject3D_cl_GetLocalPosition",1,SWIGTYPE_p_VisObject3D_cl);
  }
  
  result = ((VisObject3D_cl const *)arg1)->GetLocalPosition();
  {
    hkvVec3 * resultptr = new hkvVec3((const hkvVec3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_hkvVec3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisObject3D_cl_SetLocalOrientation(lua_State* L) {
  int SWIG_arg = 0;
  VisObject3D_cl *arg1 = (VisObject3D_cl *) 0 ;
  hkvVec3 *arg2 = 0 ;
  
  SWIG_check_num_args("SetLocalOrientation",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetLocalOrientation",1,"VisObject3D_cl *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("SetLocalOrientation",2,"hkvVec3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisObject3D_cl,0))){
    SWIG_fail_ptr("VisObject3D_cl_SetLocalOrientation",1,SWIGTYPE_p_VisObject3D_cl);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("VisObject3D_cl_SetLocalOrientation",2,SWIGTYPE_p_hkvVec3);
  }
  
  (arg1)->SetLocalOrientation((hkvVec3 const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisObject3D_cl_GetLocalOrientation(lua_State* L) {
  int SWIG_arg = 0;
  VisObject3D_cl *arg1 = (VisObject3D_cl *) 0 ;
  SwigValueWrapper< hkvVec3 > result;
  
  SWIG_check_num_args("GetLocalOrientation",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetLocalOrientation",1,"VisObject3D_cl const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisObject3D_cl,0))){
    SWIG_fail_ptr("VisObject3D_cl_GetLocalOrientation",1,SWIGTYPE_p_VisObject3D_cl);
  }
  
  result = ((VisObject3D_cl const *)arg1)->GetLocalOrientation();
  {
    hkvVec3 * resultptr = new hkvVec3((const hkvVec3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_hkvVec3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisObject3D_cl_ResetLocalTransformation(lua_State* L) {
  int SWIG_arg = 0;
  VisObject3D_cl *arg1 = (VisObject3D_cl *) 0 ;
  
  SWIG_check_num_args("ResetLocalTransformation",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ResetLocalTransformation",1,"VisObject3D_cl *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisObject3D_cl,0))){
    SWIG_fail_ptr("VisObject3D_cl_ResetLocalTransformation",1,SWIGTYPE_p_VisObject3D_cl);
  }
  
  (arg1)->ResetLocalTransformation();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisObject3D_cl_SetMotionDeltaWorldSpace(lua_State* L) {
  int SWIG_arg = 0;
  VisObject3D_cl *arg1 = (VisObject3D_cl *) 0 ;
  hkvVec3 *arg2 = 0 ;
  
  SWIG_check_num_args("SetMotionDeltaWorldSpace",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetMotionDeltaWorldSpace",1,"VisObject3D_cl *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("SetMotionDeltaWorldSpace",2,"hkvVec3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisObject3D_cl,0))){
    SWIG_fail_ptr("VisObject3D_cl_SetMotionDeltaWorldSpace",1,SWIGTYPE_p_VisObject3D_cl);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("VisObject3D_cl_SetMotionDeltaWorldSpace",2,SWIGTYPE_p_hkvVec3);
  }
  
  (arg1)->SetMotionDeltaWorldSpace((hkvVec3 const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisObject3D_cl_SetMotionDeltaLocalSpace(lua_State* L) {
  int SWIG_arg = 0;
  VisObject3D_cl *arg1 = (VisObject3D_cl *) 0 ;
  hkvVec3 *arg2 = 0 ;
  
  SWIG_check_num_args("SetMotionDeltaLocalSpace",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetMotionDeltaLocalSpace",1,"VisObject3D_cl *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("SetMotionDeltaLocalSpace",2,"hkvVec3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisObject3D_cl,0))){
    SWIG_fail_ptr("VisObject3D_cl_SetMotionDeltaLocalSpace",1,SWIGTYPE_p_VisObject3D_cl);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("VisObject3D_cl_SetMotionDeltaLocalSpace",2,SWIGTYPE_p_hkvVec3);
  }
  
  (arg1)->SetMotionDeltaLocalSpace((hkvVec3 const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisObject3D_cl_IncMotionDeltaWorldSpace(lua_State* L) {
  int SWIG_arg = 0;
  VisObject3D_cl *arg1 = (VisObject3D_cl *) 0 ;
  hkvVec3 *arg2 = 0 ;
  
  SWIG_check_num_args("IncMotionDeltaWorldSpace",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("IncMotionDeltaWorldSpace",1,"VisObject3D_cl *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("IncMotionDeltaWorldSpace",2,"hkvVec3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisObject3D_cl,0))){
    SWIG_fail_ptr("VisObject3D_cl_IncMotionDeltaWorldSpace",1,SWIGTYPE_p_VisObject3D_cl);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("VisObject3D_cl_IncMotionDeltaWorldSpace",2,SWIGTYPE_p_hkvVec3);
  }
  
  (arg1)->IncMotionDeltaWorldSpace((hkvVec3 const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisObject3D_cl_IncMotionDeltaLocalSpace(lua_State* L) {
  int SWIG_arg = 0;
  VisObject3D_cl *arg1 = (VisObject3D_cl *) 0 ;
  hkvVec3 *arg2 = 0 ;
  
  SWIG_check_num_args("IncMotionDeltaLocalSpace",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("IncMotionDeltaLocalSpace",1,"VisObject3D_cl *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("IncMotionDeltaLocalSpace",2,"hkvVec3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisObject3D_cl,0))){
    SWIG_fail_ptr("VisObject3D_cl_IncMotionDeltaLocalSpace",1,SWIGTYPE_p_VisObject3D_cl);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("VisObject3D_cl_IncMotionDeltaLocalSpace",2,SWIGTYPE_p_hkvVec3);
  }
  
  (arg1)->IncMotionDeltaLocalSpace((hkvVec3 const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisObject3D_cl_GetMotionDeltaWorldSpace(lua_State* L) {
  int SWIG_arg = 0;
  VisObject3D_cl *arg1 = (VisObject3D_cl *) 0 ;
  SwigValueWrapper< hkvVec3 > result;
  
  SWIG_check_num_args("GetMotionDeltaWorldSpace",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetMotionDeltaWorldSpace",1,"VisObject3D_cl const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisObject3D_cl,0))){
    SWIG_fail_ptr("VisObject3D_cl_GetMotionDeltaWorldSpace",1,SWIGTYPE_p_VisObject3D_cl);
  }
  
  result = VisObject3D_cl_GetMotionDeltaWorldSpace((VisObject3D_cl const *)arg1);
  {
    hkvVec3 * resultptr = new hkvVec3((const hkvVec3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_hkvVec3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisObject3D_cl_GetMotionDeltaLocalSpace(lua_State* L) {
  int SWIG_arg = 0;
  VisObject3D_cl *arg1 = (VisObject3D_cl *) 0 ;
  SwigValueWrapper< hkvVec3 > result;
  
  SWIG_check_num_args("GetMotionDeltaLocalSpace",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetMotionDeltaLocalSpace",1,"VisObject3D_cl const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisObject3D_cl,0))){
    SWIG_fail_ptr("VisObject3D_cl_GetMotionDeltaLocalSpace",1,SWIGTYPE_p_VisObject3D_cl);
  }
  
  result = VisObject3D_cl_GetMotionDeltaLocalSpace((VisObject3D_cl const *)arg1);
  {
    hkvVec3 * resultptr = new hkvVec3((const hkvVec3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_hkvVec3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisObject3D_cl_HasRotationDelta(lua_State* L) {
  int SWIG_arg = 0;
  VisObject3D_cl *arg1 = (VisObject3D_cl *) 0 ;
  bool result;
  
  SWIG_check_num_args("HasRotationDelta",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("HasRotationDelta",1,"VisObject3D_cl const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisObject3D_cl,0))){
    SWIG_fail_ptr("VisObject3D_cl_HasRotationDelta",1,SWIGTYPE_p_VisObject3D_cl);
  }
  
  result = (bool)VisObject3D_cl_HasRotationDelta((VisObject3D_cl const *)arg1);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisObject3D_cl_GetRotationDelta(lua_State* L) {
  int SWIG_arg = 0;
  VisObject3D_cl *arg1 = (VisObject3D_cl *) 0 ;
  SwigValueWrapper< hkvVec3 > result;
  
  SWIG_check_num_args("GetRotationDelta",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetRotationDelta",1,"VisObject3D_cl const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisObject3D_cl,0))){
    SWIG_fail_ptr("VisObject3D_cl_GetRotationDelta",1,SWIGTYPE_p_VisObject3D_cl);
  }
  
  result = VisObject3D_cl_GetRotationDelta((VisObject3D_cl const *)arg1);
  {
    hkvVec3 * resultptr = new hkvVec3((const hkvVec3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_hkvVec3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisObject3D_cl_ResetMotionDeltaLocalSpace(lua_State* L) {
  int SWIG_arg = 0;
  VisObject3D_cl *arg1 = (VisObject3D_cl *) 0 ;
  
  SWIG_check_num_args("ResetMotionDeltaLocalSpace",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ResetMotionDeltaLocalSpace",1,"VisObject3D_cl *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisObject3D_cl,0))){
    SWIG_fail_ptr("VisObject3D_cl_ResetMotionDeltaLocalSpace",1,SWIGTYPE_p_VisObject3D_cl);
  }
  
  (arg1)->ResetMotionDeltaLocalSpace();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisObject3D_cl_ResetMotionDeltaWorldSpace(lua_State* L) {
  int SWIG_arg = 0;
  VisObject3D_cl *arg1 = (VisObject3D_cl *) 0 ;
  
  SWIG_check_num_args("ResetMotionDeltaWorldSpace",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ResetMotionDeltaWorldSpace",1,"VisObject3D_cl *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisObject3D_cl,0))){
    SWIG_fail_ptr("VisObject3D_cl_ResetMotionDeltaWorldSpace",1,SWIGTYPE_p_VisObject3D_cl);
  }
  
  (arg1)->ResetMotionDeltaWorldSpace();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisObject3D_cl_ResetMotionDelta(lua_State* L) {
  int SWIG_arg = 0;
  VisObject3D_cl *arg1 = (VisObject3D_cl *) 0 ;
  
  SWIG_check_num_args("ResetMotionDelta",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ResetMotionDelta",1,"VisObject3D_cl *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisObject3D_cl,0))){
    SWIG_fail_ptr("VisObject3D_cl_ResetMotionDelta",1,SWIGTYPE_p_VisObject3D_cl);
  }
  
  (arg1)->ResetMotionDelta();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisObject3D_cl_SetRotationDelta(lua_State* L) {
  int SWIG_arg = 0;
  VisObject3D_cl *arg1 = (VisObject3D_cl *) 0 ;
  hkvVec3 *arg2 = 0 ;
  
  SWIG_check_num_args("SetRotationDelta",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetRotationDelta",1,"VisObject3D_cl *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("SetRotationDelta",2,"hkvVec3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisObject3D_cl,0))){
    SWIG_fail_ptr("VisObject3D_cl_SetRotationDelta",1,SWIGTYPE_p_VisObject3D_cl);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("VisObject3D_cl_SetRotationDelta",2,SWIGTYPE_p_hkvVec3);
  }
  
  (arg1)->SetRotationDelta((hkvVec3 const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisObject3D_cl_IncRotationDelta(lua_State* L) {
  int SWIG_arg = 0;
  VisObject3D_cl *arg1 = (VisObject3D_cl *) 0 ;
  hkvVec3 *arg2 = 0 ;
  
  SWIG_check_num_args("IncRotationDelta",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("IncRotationDelta",1,"VisObject3D_cl *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("IncRotationDelta",2,"hkvVec3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisObject3D_cl,0))){
    SWIG_fail_ptr("VisObject3D_cl_IncRotationDelta",1,SWIGTYPE_p_VisObject3D_cl);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("VisObject3D_cl_IncRotationDelta",2,SWIGTYPE_p_hkvVec3);
  }
  
  (arg1)->IncRotationDelta((hkvVec3 const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisObject3D_cl_ResetRotationDelta(lua_State* L) {
  int SWIG_arg = 0;
  VisObject3D_cl *arg1 = (VisObject3D_cl *) 0 ;
  
  SWIG_check_num_args("ResetRotationDelta",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ResetRotationDelta",1,"VisObject3D_cl *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisObject3D_cl,0))){
    SWIG_fail_ptr("VisObject3D_cl_ResetRotationDelta",1,SWIGTYPE_p_VisObject3D_cl);
  }
  
  (arg1)->ResetRotationDelta();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisObject3D_cl_GetObjDir(lua_State* L) {
  int SWIG_arg = 0;
  VisObject3D_cl *arg1 = (VisObject3D_cl *) 0 ;
  SwigValueWrapper< hkvVec3 > result;
  
  SWIG_check_num_args("GetObjDir",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetObjDir",1,"VisObject3D_cl const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisObject3D_cl,0))){
    SWIG_fail_ptr("VisObject3D_cl_GetObjDir",1,SWIGTYPE_p_VisObject3D_cl);
  }
  
  result = ((VisObject3D_cl const *)arg1)->GetObjDir();
  {
    hkvVec3 * resultptr = new hkvVec3((const hkvVec3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_hkvVec3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisObject3D_cl_GetObjDir_Right(lua_State* L) {
  int SWIG_arg = 0;
  VisObject3D_cl *arg1 = (VisObject3D_cl *) 0 ;
  SwigValueWrapper< hkvVec3 > result;
  
  SWIG_check_num_args("GetObjDir_Right",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetObjDir_Right",1,"VisObject3D_cl const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisObject3D_cl,0))){
    SWIG_fail_ptr("VisObject3D_cl_GetObjDir_Right",1,SWIGTYPE_p_VisObject3D_cl);
  }
  
  result = ((VisObject3D_cl const *)arg1)->GetObjDir_Right();
  {
    hkvVec3 * resultptr = new hkvVec3((const hkvVec3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_hkvVec3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisObject3D_cl_GetObjDir_Up(lua_State* L) {
  int SWIG_arg = 0;
  VisObject3D_cl *arg1 = (VisObject3D_cl *) 0 ;
  SwigValueWrapper< hkvVec3 > result;
  
  SWIG_check_num_args("GetObjDir_Up",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetObjDir_Up",1,"VisObject3D_cl const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisObject3D_cl,0))){
    SWIG_fail_ptr("VisObject3D_cl_GetObjDir_Up",1,SWIGTYPE_p_VisObject3D_cl);
  }
  
  result = ((VisObject3D_cl const *)arg1)->GetObjDir_Up();
  {
    hkvVec3 * resultptr = new hkvVec3((const hkvVec3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_hkvVec3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static swig_lua_method swig_VisObject3D_cl_methods[] = {
    { "__tostring",VisObject3D_cl_ToString},
    { "GetParent",VisObject3D_cl_GetParent},
    { "GetChild",VisObject3D_cl_GetChild},
    { "__concat",VisObject3D_cl_Concat},
    {"GetPosition", _wrap_VisObject3D_cl_GetPosition}, 
    {"SetPosition", _wrap_VisObject3D_cl_SetPosition}, 
    {"IncPosition", _wrap_VisObject3D_cl_IncPosition}, 
    {"SetUseEulerAngles", _wrap_VisObject3D_cl_SetUseEulerAngles}, 
    {"GetUseEulerAngles", _wrap_VisObject3D_cl_GetUseEulerAngles}, 
    {"TransformToObjectSpace", _wrap_VisObject3D_cl_TransformToObjectSpace}, 
    {"SetOrientation", _wrap_VisObject3D_cl_SetOrientation}, 
    {"IncOrientation", _wrap_VisObject3D_cl_IncOrientation}, 
    {"GetOrientation", _wrap_VisObject3D_cl_GetOrientation}, 
    {"SetRotationMatrix", _wrap_VisObject3D_cl_SetRotationMatrix}, 
    {"GetRotationMatrix", _wrap_VisObject3D_cl_GetRotationMatrix}, 
    {"GetTransposedRotationMatrix", _wrap_VisObject3D_cl_GetTransposedRotationMatrix}, 
    {"GetDirection", _wrap_VisObject3D_cl_GetDirection}, 
    {"SetDirection", _wrap_VisObject3D_cl_SetDirection}, 
    {"AttachToParent", _wrap_VisObject3D_cl_AttachToParent}, 
    {"DetachFromParent", _wrap_VisObject3D_cl_DetachFromParent}, 
    {"GetNumChildren", _wrap_VisObject3D_cl_GetNumChildren}, 
    {"SetLocalPosition", _wrap_VisObject3D_cl_SetLocalPosition}, 
    {"GetLocalPosition", _wrap_VisObject3D_cl_GetLocalPosition}, 
    {"SetLocalOrientation", _wrap_VisObject3D_cl_SetLocalOrientation}, 
    {"GetLocalOrientation", _wrap_VisObject3D_cl_GetLocalOrientation}, 
    {"ResetLocalTransformation", _wrap_VisObject3D_cl_ResetLocalTransformation}, 
    {"SetMotionDeltaWorldSpace", _wrap_VisObject3D_cl_SetMotionDeltaWorldSpace}, 
    {"SetMotionDeltaLocalSpace", _wrap_VisObject3D_cl_SetMotionDeltaLocalSpace}, 
    {"IncMotionDeltaWorldSpace", _wrap_VisObject3D_cl_IncMotionDeltaWorldSpace}, 
    {"IncMotionDeltaLocalSpace", _wrap_VisObject3D_cl_IncMotionDeltaLocalSpace}, 
    {"GetMotionDeltaWorldSpace", _wrap_VisObject3D_cl_GetMotionDeltaWorldSpace}, 
    {"GetMotionDeltaLocalSpace", _wrap_VisObject3D_cl_GetMotionDeltaLocalSpace}, 
    {"HasRotationDelta", _wrap_VisObject3D_cl_HasRotationDelta}, 
    {"GetRotationDelta", _wrap_VisObject3D_cl_GetRotationDelta}, 
    {"ResetMotionDeltaLocalSpace", _wrap_VisObject3D_cl_ResetMotionDeltaLocalSpace}, 
    {"ResetMotionDeltaWorldSpace", _wrap_VisObject3D_cl_ResetMotionDeltaWorldSpace}, 
    {"ResetMotionDelta", _wrap_VisObject3D_cl_ResetMotionDelta}, 
    {"SetRotationDelta", _wrap_VisObject3D_cl_SetRotationDelta}, 
    {"IncRotationDelta", _wrap_VisObject3D_cl_IncRotationDelta}, 
    {"ResetRotationDelta", _wrap_VisObject3D_cl_ResetRotationDelta}, 
    {"GetObjDir", _wrap_VisObject3D_cl_GetObjDir}, 
    {"GetObjDir_Right", _wrap_VisObject3D_cl_GetObjDir_Right}, 
    {"GetObjDir_Up", _wrap_VisObject3D_cl_GetObjDir_Up}, 
    {0,0}
};
static swig_lua_attribute swig_VisObject3D_cl_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_VisObject3D_cl_bases[] = {0,0,0};
static const char *swig_VisObject3D_cl_base_names[] = {"VisTypedEngineObject_cl *","VisObjectKey_cl *",0};
static swig_lua_class _wrap_class_VisObject3D_cl = { "VisObject3D_cl", &SWIGTYPE_p_VisObject3D_cl,0,0, swig_VisObject3D_cl_methods, swig_VisObject3D_cl_attributes, swig_VisObject3D_cl_bases, swig_VisObject3D_cl_base_names };

static int _wrap_IVObjectComponent_SetOwner(lua_State* L) {
  int SWIG_arg = 0;
  IVObjectComponent *arg1 = (IVObjectComponent *) 0 ;
  VisTypedEngineObject_cl *arg2 = (VisTypedEngineObject_cl *) 0 ;
  
  SWIG_check_num_args("SetOwner",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetOwner",1,"IVObjectComponent *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SetOwner",2,"VisTypedEngineObject_cl *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_IVObjectComponent,0))){
    SWIG_fail_ptr("IVObjectComponent_SetOwner",1,SWIGTYPE_p_IVObjectComponent);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_VisTypedEngineObject_cl,0))){
    SWIG_fail_ptr("IVObjectComponent_SetOwner",2,SWIGTYPE_p_VisTypedEngineObject_cl);
  }
  
  (arg1)->SetOwner(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_IVObjectComponent_GetComponentID(lua_State* L) {
  int SWIG_arg = 0;
  IVObjectComponent *arg1 = (IVObjectComponent *) 0 ;
  int result;
  
  SWIG_check_num_args("GetComponentID",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetComponentID",1,"IVObjectComponent const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_IVObjectComponent,0))){
    SWIG_fail_ptr("IVObjectComponent_GetComponentID",1,SWIGTYPE_p_IVObjectComponent);
  }
  
  result = (int)((IVObjectComponent const *)arg1)->GetComponentID();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_IVObjectComponent_GetComponentName(lua_State* L) {
  int SWIG_arg = 0;
  IVObjectComponent *arg1 = (IVObjectComponent *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("GetComponentName",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetComponentName",1,"IVObjectComponent *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_IVObjectComponent,0))){
    SWIG_fail_ptr("IVObjectComponent_GetComponentName",1,SWIGTYPE_p_IVObjectComponent);
  }
  
  result = (char *)(arg1)->GetComponentName();
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_IVObjectComponent_SetComponentID(lua_State* L) {
  int SWIG_arg = 0;
  IVObjectComponent *arg1 = (IVObjectComponent *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("SetComponentID",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetComponentID",1,"IVObjectComponent *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SetComponentID",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_IVObjectComponent,0))){
    SWIG_fail_ptr("IVObjectComponent_SetComponentID",1,SWIGTYPE_p_IVObjectComponent);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->SetComponentID(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_IVObjectComponent_SetComponentName(lua_State* L) {
  int SWIG_arg = 0;
  IVObjectComponent *arg1 = (IVObjectComponent *) 0 ;
  char *arg2 = (char *) 0 ;
  
  SWIG_check_num_args("SetComponentName",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetComponentName",1,"IVObjectComponent *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("SetComponentName",2,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_IVObjectComponent,0))){
    SWIG_fail_ptr("IVObjectComponent_SetComponentName",1,SWIGTYPE_p_IVObjectComponent);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  (arg1)->SetComponentName((char const *)arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_IVObjectComponent_CanAttachToObject(lua_State* L) {
  int SWIG_arg = 0;
  IVObjectComponent *arg1 = (IVObjectComponent *) 0 ;
  VisTypedEngineObject_cl *arg2 = (VisTypedEngineObject_cl *) 0 ;
  bool result;
  
  SWIG_check_num_args("CanAttachToObject",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("CanAttachToObject",1,"IVObjectComponent *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("CanAttachToObject",2,"VisTypedEngineObject_cl *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_IVObjectComponent,0))){
    SWIG_fail_ptr("IVObjectComponent_CanAttachToObject",1,SWIGTYPE_p_IVObjectComponent);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_VisTypedEngineObject_cl,0))){
    SWIG_fail_ptr("IVObjectComponent_CanAttachToObject",2,SWIGTYPE_p_VisTypedEngineObject_cl);
  }
  
  result = (bool)IVObjectComponent_CanAttachToObject(arg1,arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static swig_lua_method swig_IVObjectComponent_methods[] = {
    { "__tostring",IVObjectComponent_ToString},
    { "GetOwner",IVObjectComponent_GetOwner},
    { "__concat",IVObjectComponent_Concat},
    {"SetOwner", _wrap_IVObjectComponent_SetOwner}, 
    {"GetComponentID", _wrap_IVObjectComponent_GetComponentID}, 
    {"GetComponentName", _wrap_IVObjectComponent_GetComponentName}, 
    {"SetComponentID", _wrap_IVObjectComponent_SetComponentID}, 
    {"SetComponentName", _wrap_IVObjectComponent_SetComponentName}, 
    {"CanAttachToObject", _wrap_IVObjectComponent_CanAttachToObject}, 
    {0,0}
};
static swig_lua_attribute swig_IVObjectComponent_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_IVObjectComponent_bases[] = {0,0};
static const char *swig_IVObjectComponent_base_names[] = {"VisTypedEngineObject_cl *",0};
static swig_lua_class _wrap_class_IVObjectComponent = { "IVObjectComponent", &SWIGTYPE_p_IVObjectComponent,0,0, swig_IVObjectComponent_methods, swig_IVObjectComponent_attributes, swig_IVObjectComponent_bases, swig_IVObjectComponent_base_names };

static int _wrap_VisBaseEntity_cl_Remove(lua_State* L) {
  int SWIG_arg = 0;
  VisBaseEntity_cl *arg1 = (VisBaseEntity_cl *) 0 ;
  
  SWIG_check_num_args("Remove",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Remove",1,"VisBaseEntity_cl *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisBaseEntity_cl,0))){
    SWIG_fail_ptr("VisBaseEntity_cl_Remove",1,SWIGTYPE_p_VisBaseEntity_cl);
  }
  
  (arg1)->Remove();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisBaseEntity_cl_InitFunction(lua_State* L) {
  int SWIG_arg = 0;
  VisBaseEntity_cl *arg1 = (VisBaseEntity_cl *) 0 ;
  
  SWIG_check_num_args("InitFunction",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("InitFunction",1,"VisBaseEntity_cl *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisBaseEntity_cl,0))){
    SWIG_fail_ptr("VisBaseEntity_cl_InitFunction",1,SWIGTYPE_p_VisBaseEntity_cl);
  }
  
  (arg1)->InitFunction();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisBaseEntity_cl_DeInitFunction(lua_State* L) {
  int SWIG_arg = 0;
  VisBaseEntity_cl *arg1 = (VisBaseEntity_cl *) 0 ;
  
  SWIG_check_num_args("DeInitFunction",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("DeInitFunction",1,"VisBaseEntity_cl *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisBaseEntity_cl,0))){
    SWIG_fail_ptr("VisBaseEntity_cl_DeInitFunction",1,SWIGTYPE_p_VisBaseEntity_cl);
  }
  
  (arg1)->DeInitFunction();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisBaseEntity_cl_GetMesh(lua_State* L) {
  int SWIG_arg = 0;
  VisBaseEntity_cl *arg1 = (VisBaseEntity_cl *) 0 ;
  VDynamicMesh *result = 0 ;
  
  SWIG_check_num_args("GetMesh",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetMesh",1,"VisBaseEntity_cl const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisBaseEntity_cl,0))){
    SWIG_fail_ptr("VisBaseEntity_cl_GetMesh",1,SWIGTYPE_p_VisBaseEntity_cl);
  }
  
  result = (VDynamicMesh *)((VisBaseEntity_cl const *)arg1)->GetMesh();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_VDynamicMesh,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisBaseEntity_cl_SetMesh__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  VisBaseEntity_cl *arg1 = (VisBaseEntity_cl *) 0 ;
  char *arg2 = (char *) 0 ;
  bool result;
  
  SWIG_check_num_args("SetMesh",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetMesh",1,"VisBaseEntity_cl *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("SetMesh",2,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisBaseEntity_cl,0))){
    SWIG_fail_ptr("VisBaseEntity_cl_SetMesh",1,SWIGTYPE_p_VisBaseEntity_cl);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  result = (bool)VisBaseEntity_cl_SetMesh__SWIG_0(arg1,(char const *)arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisBaseEntity_cl_SetMesh__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  VisBaseEntity_cl *arg1 = (VisBaseEntity_cl *) 0 ;
  VDynamicMesh *arg2 = (VDynamicMesh *) 0 ;
  bool result;
  
  SWIG_check_num_args("SetMesh",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetMesh",1,"VisBaseEntity_cl *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SetMesh",2,"VDynamicMesh *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisBaseEntity_cl,0))){
    SWIG_fail_ptr("VisBaseEntity_cl_SetMesh",1,SWIGTYPE_p_VisBaseEntity_cl);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_VDynamicMesh,0))){
    SWIG_fail_ptr("VisBaseEntity_cl_SetMesh",2,SWIGTYPE_p_VDynamicMesh);
  }
  
  result = (bool)VisBaseEntity_cl_SetMesh__SWIG_1(arg1,arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisBaseEntity_cl_SetMesh(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VisBaseEntity_cl, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_VDynamicMesh, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_VisBaseEntity_cl_SetMesh__SWIG_1(L);
      }
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VisBaseEntity_cl, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = SWIG_lua_isnilstring(L,argv[1]);
      }
      if (_v) {
        return _wrap_VisBaseEntity_cl_SetMesh__SWIG_0(L);
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'VisBaseEntity_cl_SetMesh'\n"
    "  Possible C/C++ prototypes are:\n"
    "    SetMesh(VisBaseEntity_cl *,char const *)\n"
    "    SetMesh(VisBaseEntity_cl *,VDynamicMesh *)\n");
  lua_error(L);return 0;
}


static int _wrap_VisBaseEntity_cl_SetThinkFunctionStatus(lua_State* L) {
  int SWIG_arg = 0;
  VisBaseEntity_cl *arg1 = (VisBaseEntity_cl *) 0 ;
  bool arg2 ;
  
  SWIG_check_num_args("SetThinkFunctionStatus",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetThinkFunctionStatus",1,"VisBaseEntity_cl *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("SetThinkFunctionStatus",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisBaseEntity_cl,0))){
    SWIG_fail_ptr("VisBaseEntity_cl_SetThinkFunctionStatus",1,SWIGTYPE_p_VisBaseEntity_cl);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  VisBaseEntity_cl_SetThinkFunctionStatus(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisBaseEntity_cl_GetThinkFunctionStatus(lua_State* L) {
  int SWIG_arg = 0;
  VisBaseEntity_cl *arg1 = (VisBaseEntity_cl *) 0 ;
  bool result;
  
  SWIG_check_num_args("GetThinkFunctionStatus",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetThinkFunctionStatus",1,"VisBaseEntity_cl const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisBaseEntity_cl,0))){
    SWIG_fail_ptr("VisBaseEntity_cl_GetThinkFunctionStatus",1,SWIGTYPE_p_VisBaseEntity_cl);
  }
  
  result = (bool)VisBaseEntity_cl_GetThinkFunctionStatus((VisBaseEntity_cl const *)arg1);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisBaseEntity_cl_HasMesh(lua_State* L) {
  int SWIG_arg = 0;
  VisBaseEntity_cl *arg1 = (VisBaseEntity_cl *) 0 ;
  bool result;
  
  SWIG_check_num_args("HasMesh",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("HasMesh",1,"VisBaseEntity_cl const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisBaseEntity_cl,0))){
    SWIG_fail_ptr("VisBaseEntity_cl_HasMesh",1,SWIGTYPE_p_VisBaseEntity_cl);
  }
  
  result = (bool)VisBaseEntity_cl_HasMesh((VisBaseEntity_cl const *)arg1);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisBaseEntity_cl_SetCastShadows(lua_State* L) {
  int SWIG_arg = 0;
  VisBaseEntity_cl *arg1 = (VisBaseEntity_cl *) 0 ;
  bool arg2 ;
  
  SWIG_check_num_args("SetCastShadows",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetCastShadows",1,"VisBaseEntity_cl *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("SetCastShadows",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisBaseEntity_cl,0))){
    SWIG_fail_ptr("VisBaseEntity_cl_SetCastShadows",1,SWIGTYPE_p_VisBaseEntity_cl);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  VisBaseEntity_cl_SetCastShadows(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisBaseEntity_cl_GetCastShadows(lua_State* L) {
  int SWIG_arg = 0;
  VisBaseEntity_cl *arg1 = (VisBaseEntity_cl *) 0 ;
  bool result;
  
  SWIG_check_num_args("GetCastShadows",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetCastShadows",1,"VisBaseEntity_cl const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisBaseEntity_cl,0))){
    SWIG_fail_ptr("VisBaseEntity_cl_GetCastShadows",1,SWIGTYPE_p_VisBaseEntity_cl);
  }
  
  result = (bool)VisBaseEntity_cl_GetCastShadows((VisBaseEntity_cl const *)arg1);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisBaseEntity_cl_SetScaling__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  VisBaseEntity_cl *arg1 = (VisBaseEntity_cl *) 0 ;
  float arg2 ;
  bool result;
  
  SWIG_check_num_args("SetScaling",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetScaling",1,"VisBaseEntity_cl *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SetScaling",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisBaseEntity_cl,0))){
    SWIG_fail_ptr("VisBaseEntity_cl_SetScaling",1,SWIGTYPE_p_VisBaseEntity_cl);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  result = (bool)VisBaseEntity_cl_SetScaling__SWIG_0(arg1,arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisBaseEntity_cl_SetScaling__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  VisBaseEntity_cl *arg1 = (VisBaseEntity_cl *) 0 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  bool result;
  
  SWIG_check_num_args("SetScaling",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetScaling",1,"VisBaseEntity_cl *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SetScaling",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("SetScaling",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("SetScaling",4,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisBaseEntity_cl,0))){
    SWIG_fail_ptr("VisBaseEntity_cl_SetScaling",1,SWIGTYPE_p_VisBaseEntity_cl);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4);
  result = (bool)VisBaseEntity_cl_SetScaling__SWIG_1(arg1,arg2,arg3,arg4);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisBaseEntity_cl_SetScaling__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  VisBaseEntity_cl *arg1 = (VisBaseEntity_cl *) 0 ;
  hkvVec3 *arg2 = (hkvVec3 *) 0 ;
  bool result;
  
  SWIG_check_num_args("SetScaling",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetScaling",1,"VisBaseEntity_cl *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SetScaling",2,"hkvVec3 const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisBaseEntity_cl,0))){
    SWIG_fail_ptr("VisBaseEntity_cl_SetScaling",1,SWIGTYPE_p_VisBaseEntity_cl);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("VisBaseEntity_cl_SetScaling",2,SWIGTYPE_p_hkvVec3);
  }
  
  result = (bool)VisBaseEntity_cl_SetScaling__SWIG_2(arg1,(hkvVec3 const *)arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisBaseEntity_cl_SetScaling(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VisBaseEntity_cl, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_hkvVec3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_VisBaseEntity_cl_SetScaling__SWIG_2(L);
      }
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VisBaseEntity_cl, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_VisBaseEntity_cl_SetScaling__SWIG_0(L);
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VisBaseEntity_cl, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_VisBaseEntity_cl_SetScaling__SWIG_1(L);
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'VisBaseEntity_cl_SetScaling'\n"
    "  Possible C/C++ prototypes are:\n"
    "    SetScaling(VisBaseEntity_cl *,float)\n"
    "    SetScaling(VisBaseEntity_cl *,float,float,float)\n"
    "    SetScaling(VisBaseEntity_cl *,hkvVec3 const *)\n");
  lua_error(L);return 0;
}


static int _wrap_VisBaseEntity_cl_GetScaling(lua_State* L) {
  int SWIG_arg = 0;
  VisBaseEntity_cl *arg1 = (VisBaseEntity_cl *) 0 ;
  SwigValueWrapper< hkvVec3 > result;
  
  SWIG_check_num_args("GetScaling",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetScaling",1,"VisBaseEntity_cl const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisBaseEntity_cl,0))){
    SWIG_fail_ptr("VisBaseEntity_cl_GetScaling",1,SWIGTYPE_p_VisBaseEntity_cl);
  }
  
  result = VisBaseEntity_cl_GetScaling((VisBaseEntity_cl const *)arg1);
  {
    hkvVec3 * resultptr = new hkvVec3((const hkvVec3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_hkvVec3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisBaseEntity_cl_SetAlwaysInForeGround__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  VisBaseEntity_cl *arg1 = (VisBaseEntity_cl *) 0 ;
  bool arg2 ;
  
  SWIG_check_num_args("SetAlwaysInForeGround",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetAlwaysInForeGround",1,"VisBaseEntity_cl *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("SetAlwaysInForeGround",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisBaseEntity_cl,0))){
    SWIG_fail_ptr("VisBaseEntity_cl_SetAlwaysInForeGround",1,SWIGTYPE_p_VisBaseEntity_cl);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  (arg1)->SetAlwaysInForeGround(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisBaseEntity_cl_SetAlwaysInForeGround__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  VisBaseEntity_cl *arg1 = (VisBaseEntity_cl *) 0 ;
  
  SWIG_check_num_args("SetAlwaysInForeGround",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetAlwaysInForeGround",1,"VisBaseEntity_cl *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisBaseEntity_cl,0))){
    SWIG_fail_ptr("VisBaseEntity_cl_SetAlwaysInForeGround",1,SWIGTYPE_p_VisBaseEntity_cl);
  }
  
  (arg1)->SetAlwaysInForeGround();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisBaseEntity_cl_SetAlwaysInForeGround(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VisBaseEntity_cl, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_VisBaseEntity_cl_SetAlwaysInForeGround__SWIG_1(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VisBaseEntity_cl, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isboolean(L,argv[1]);
      }
      if (_v) {
        return _wrap_VisBaseEntity_cl_SetAlwaysInForeGround__SWIG_0(L);
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'VisBaseEntity_cl_SetAlwaysInForeGround'\n"
    "  Possible C/C++ prototypes are:\n"
    "    SetAlwaysInForeGround(VisBaseEntity_cl *,bool)\n"
    "    SetAlwaysInForeGround(VisBaseEntity_cl *)\n");
  lua_error(L);return 0;
}


static int _wrap_VisBaseEntity_cl_IsObjectAlwaysInForegroundEnabled(lua_State* L) {
  int SWIG_arg = 0;
  VisBaseEntity_cl *arg1 = (VisBaseEntity_cl *) 0 ;
  bool result;
  
  SWIG_check_num_args("IsObjectAlwaysInForegroundEnabled",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("IsObjectAlwaysInForegroundEnabled",1,"VisBaseEntity_cl *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisBaseEntity_cl,0))){
    SWIG_fail_ptr("VisBaseEntity_cl_IsObjectAlwaysInForegroundEnabled",1,SWIGTYPE_p_VisBaseEntity_cl);
  }
  
  result = (bool)(arg1)->IsObjectAlwaysInForegroundEnabled();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisBaseEntity_cl_SetCastStaticShadows(lua_State* L) {
  int SWIG_arg = 0;
  VisBaseEntity_cl *arg1 = (VisBaseEntity_cl *) 0 ;
  bool arg2 ;
  
  SWIG_check_num_args("SetCastStaticShadows",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetCastStaticShadows",1,"VisBaseEntity_cl *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("SetCastStaticShadows",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisBaseEntity_cl,0))){
    SWIG_fail_ptr("VisBaseEntity_cl_SetCastStaticShadows",1,SWIGTYPE_p_VisBaseEntity_cl);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  (arg1)->SetCastStaticShadows(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisBaseEntity_cl_GetCastStaticShadows(lua_State* L) {
  int SWIG_arg = 0;
  VisBaseEntity_cl *arg1 = (VisBaseEntity_cl *) 0 ;
  bool result;
  
  SWIG_check_num_args("GetCastStaticShadows",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetCastStaticShadows",1,"VisBaseEntity_cl *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisBaseEntity_cl,0))){
    SWIG_fail_ptr("VisBaseEntity_cl_GetCastStaticShadows",1,SWIGTYPE_p_VisBaseEntity_cl);
  }
  
  result = (bool)(arg1)->GetCastStaticShadows();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisBaseEntity_cl_SetCustomTraceBBox(lua_State* L) {
  int SWIG_arg = 0;
  VisBaseEntity_cl *arg1 = (VisBaseEntity_cl *) 0 ;
  hkvAlignedBBox *arg2 = (hkvAlignedBBox *) 0 ;
  
  SWIG_check_num_args("SetCustomTraceBBox",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetCustomTraceBBox",1,"VisBaseEntity_cl *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SetCustomTraceBBox",2,"hkvAlignedBBox const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisBaseEntity_cl,0))){
    SWIG_fail_ptr("VisBaseEntity_cl_SetCustomTraceBBox",1,SWIGTYPE_p_VisBaseEntity_cl);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_hkvAlignedBBox,0))){
    SWIG_fail_ptr("VisBaseEntity_cl_SetCustomTraceBBox",2,SWIGTYPE_p_hkvAlignedBBox);
  }
  
  (arg1)->SetCustomTraceBBox((hkvAlignedBBox const *)arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisBaseEntity_cl_GetCustomTraceBBox(lua_State* L) {
  int SWIG_arg = 0;
  VisBaseEntity_cl *arg1 = (VisBaseEntity_cl *) 0 ;
  SwigValueWrapper< hkvAlignedBBox > result;
  
  SWIG_check_num_args("GetCustomTraceBBox",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetCustomTraceBBox",1,"VisBaseEntity_cl *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisBaseEntity_cl,0))){
    SWIG_fail_ptr("VisBaseEntity_cl_GetCustomTraceBBox",1,SWIGTYPE_p_VisBaseEntity_cl);
  }
  
  result = VisBaseEntity_cl_GetCustomTraceBBox(arg1);
  {
    hkvAlignedBBox * resultptr = new hkvAlignedBBox((const hkvAlignedBBox &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_hkvAlignedBBox,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisBaseEntity_cl_SetTraceAccuracy(lua_State* L) {
  int SWIG_arg = 0;
  VisBaseEntity_cl *arg1 = (VisBaseEntity_cl *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("SetTraceAccuracy",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetTraceAccuracy",1,"VisBaseEntity_cl *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SetTraceAccuracy",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisBaseEntity_cl,0))){
    SWIG_fail_ptr("VisBaseEntity_cl_SetTraceAccuracy",1,SWIGTYPE_p_VisBaseEntity_cl);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  VisBaseEntity_cl_SetTraceAccuracy(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisBaseEntity_cl_WasVisibleInLastFrame(lua_State* L) {
  int SWIG_arg = 0;
  VisBaseEntity_cl *arg1 = (VisBaseEntity_cl *) 0 ;
  bool result;
  
  SWIG_check_num_args("WasVisibleInLastFrame",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("WasVisibleInLastFrame",1,"VisBaseEntity_cl const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisBaseEntity_cl,0))){
    SWIG_fail_ptr("VisBaseEntity_cl_WasVisibleInLastFrame",1,SWIGTYPE_p_VisBaseEntity_cl);
  }
  
  result = (bool)VisBaseEntity_cl_WasVisibleInLastFrame((VisBaseEntity_cl const *)arg1);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisBaseEntity_cl_WasVisibleInAnyLastFrame(lua_State* L) {
  int SWIG_arg = 0;
  VisBaseEntity_cl *arg1 = (VisBaseEntity_cl *) 0 ;
  bool result;
  
  SWIG_check_num_args("WasVisibleInAnyLastFrame",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("WasVisibleInAnyLastFrame",1,"VisBaseEntity_cl const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisBaseEntity_cl,0))){
    SWIG_fail_ptr("VisBaseEntity_cl_WasVisibleInAnyLastFrame",1,SWIGTYPE_p_VisBaseEntity_cl);
  }
  
  result = (bool)VisBaseEntity_cl_WasVisibleInAnyLastFrame((VisBaseEntity_cl const *)arg1);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisBaseEntity_cl_GetBoundingBox(lua_State* L) {
  int SWIG_arg = 0;
  VisBaseEntity_cl *arg1 = (VisBaseEntity_cl *) 0 ;
  SwigValueWrapper< hkvAlignedBBox > result;
  
  SWIG_check_num_args("GetBoundingBox",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetBoundingBox",1,"VisBaseEntity_cl *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisBaseEntity_cl,0))){
    SWIG_fail_ptr("VisBaseEntity_cl_GetBoundingBox",1,SWIGTYPE_p_VisBaseEntity_cl);
  }
  
  result = VisBaseEntity_cl_GetBoundingBox(arg1);
  {
    hkvAlignedBBox * resultptr = new hkvAlignedBBox((const hkvAlignedBBox &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_hkvAlignedBBox,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisBaseEntity_cl_GetCollisionBoundingBox(lua_State* L) {
  int SWIG_arg = 0;
  VisBaseEntity_cl *arg1 = (VisBaseEntity_cl *) 0 ;
  SwigValueWrapper< hkvAlignedBBox > result;
  
  SWIG_check_num_args("GetCollisionBoundingBox",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetCollisionBoundingBox",1,"VisBaseEntity_cl *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisBaseEntity_cl,0))){
    SWIG_fail_ptr("VisBaseEntity_cl_GetCollisionBoundingBox",1,SWIGTYPE_p_VisBaseEntity_cl);
  }
  
  result = VisBaseEntity_cl_GetCollisionBoundingBox(arg1);
  {
    hkvAlignedBBox * resultptr = new hkvAlignedBBox((const hkvAlignedBBox &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_hkvAlignedBBox,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisBaseEntity_cl_SetVisible(lua_State* L) {
  int SWIG_arg = 0;
  VisBaseEntity_cl *arg1 = (VisBaseEntity_cl *) 0 ;
  bool arg2 ;
  
  SWIG_check_num_args("SetVisible",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetVisible",1,"VisBaseEntity_cl *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("SetVisible",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisBaseEntity_cl,0))){
    SWIG_fail_ptr("VisBaseEntity_cl_SetVisible",1,SWIGTYPE_p_VisBaseEntity_cl);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  VisBaseEntity_cl_SetVisible(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisBaseEntity_cl_IsVisible(lua_State* L) {
  int SWIG_arg = 0;
  VisBaseEntity_cl *arg1 = (VisBaseEntity_cl *) 0 ;
  bool result;
  
  SWIG_check_num_args("IsVisible",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("IsVisible",1,"VisBaseEntity_cl *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisBaseEntity_cl,0))){
    SWIG_fail_ptr("VisBaseEntity_cl_IsVisible",1,SWIGTYPE_p_VisBaseEntity_cl);
  }
  
  result = (bool)VisBaseEntity_cl_IsVisible(arg1);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisBaseEntity_cl_SetVisibleBitmask(lua_State* L) {
  int SWIG_arg = 0;
  VisBaseEntity_cl *arg1 = (VisBaseEntity_cl *) 0 ;
  VBitmask *arg2 = (VBitmask *) 0 ;
  
  SWIG_check_num_args("SetVisibleBitmask",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetVisibleBitmask",1,"VisBaseEntity_cl *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SetVisibleBitmask",2,"VBitmask *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisBaseEntity_cl,0))){
    SWIG_fail_ptr("VisBaseEntity_cl_SetVisibleBitmask",1,SWIGTYPE_p_VisBaseEntity_cl);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_VBitmask,0))){
    SWIG_fail_ptr("VisBaseEntity_cl_SetVisibleBitmask",2,SWIGTYPE_p_VBitmask);
  }
  
  VisBaseEntity_cl_SetVisibleBitmask(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisBaseEntity_cl_GetVisibleBitmask(lua_State* L) {
  int SWIG_arg = 0;
  VisBaseEntity_cl *arg1 = (VisBaseEntity_cl *) 0 ;
  VBitmask result;
  
  SWIG_check_num_args("GetVisibleBitmask",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetVisibleBitmask",1,"VisBaseEntity_cl const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisBaseEntity_cl,0))){
    SWIG_fail_ptr("VisBaseEntity_cl_GetVisibleBitmask",1,SWIGTYPE_p_VisBaseEntity_cl);
  }
  
  result = VisBaseEntity_cl_GetVisibleBitmask((VisBaseEntity_cl const *)arg1);
  {
    VBitmask * resultptr = new VBitmask((const VBitmask &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_VBitmask,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisBaseEntity_cl_SetLightInfluenceBitmask(lua_State* L) {
  int SWIG_arg = 0;
  VisBaseEntity_cl *arg1 = (VisBaseEntity_cl *) 0 ;
  VBitmask *arg2 = (VBitmask *) 0 ;
  
  SWIG_check_num_args("SetLightInfluenceBitmask",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetLightInfluenceBitmask",1,"VisBaseEntity_cl *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SetLightInfluenceBitmask",2,"VBitmask *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisBaseEntity_cl,0))){
    SWIG_fail_ptr("VisBaseEntity_cl_SetLightInfluenceBitmask",1,SWIGTYPE_p_VisBaseEntity_cl);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_VBitmask,0))){
    SWIG_fail_ptr("VisBaseEntity_cl_SetLightInfluenceBitmask",2,SWIGTYPE_p_VBitmask);
  }
  
  VisBaseEntity_cl_SetLightInfluenceBitmask(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisBaseEntity_cl_GetLightInfluenceBitmask(lua_State* L) {
  int SWIG_arg = 0;
  VisBaseEntity_cl *arg1 = (VisBaseEntity_cl *) 0 ;
  VBitmask result;
  
  SWIG_check_num_args("GetLightInfluenceBitmask",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetLightInfluenceBitmask",1,"VisBaseEntity_cl const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisBaseEntity_cl,0))){
    SWIG_fail_ptr("VisBaseEntity_cl_GetLightInfluenceBitmask",1,SWIGTYPE_p_VisBaseEntity_cl);
  }
  
  result = VisBaseEntity_cl_GetLightInfluenceBitmask((VisBaseEntity_cl const *)arg1);
  {
    VBitmask * resultptr = new VBitmask((const VBitmask &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_VBitmask,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisBaseEntity_cl_SetTechnique__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  VisBaseEntity_cl *arg1 = (VisBaseEntity_cl *) 0 ;
  VisSurface_cl *arg2 = (VisSurface_cl *) 0 ;
  char *arg3 = (char *) 0 ;
  char *arg4 = (char *) 0 ;
  char *arg5 = (char *) 0 ;
  bool result;
  
  SWIG_check_num_args("SetTechnique",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetTechnique",1,"VisBaseEntity_cl *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SetTechnique",2,"VisSurface_cl *");
  if(!SWIG_lua_isnilstring(L,3)) SWIG_fail_arg("SetTechnique",3,"char const *");
  if(!SWIG_lua_isnilstring(L,4)) SWIG_fail_arg("SetTechnique",4,"char const *");
  if(!SWIG_lua_isnilstring(L,5)) SWIG_fail_arg("SetTechnique",5,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisBaseEntity_cl,0))){
    SWIG_fail_ptr("VisBaseEntity_cl_SetTechnique",1,SWIGTYPE_p_VisBaseEntity_cl);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_VisSurface_cl,0))){
    SWIG_fail_ptr("VisBaseEntity_cl_SetTechnique",2,SWIGTYPE_p_VisSurface_cl);
  }
  
  arg3 = (char *)lua_tostring(L, 3);
  arg4 = (char *)lua_tostring(L, 4);
  arg5 = (char *)lua_tostring(L, 5);
  result = (bool)VisBaseEntity_cl_SetTechnique__SWIG_0(arg1,arg2,(char const *)arg3,(char const *)arg4,(char const *)arg5);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisBaseEntity_cl_SetTechnique__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  VisBaseEntity_cl *arg1 = (VisBaseEntity_cl *) 0 ;
  VisSurface_cl *arg2 = (VisSurface_cl *) 0 ;
  char *arg3 = (char *) 0 ;
  char *arg4 = (char *) 0 ;
  bool result;
  
  SWIG_check_num_args("SetTechnique",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetTechnique",1,"VisBaseEntity_cl *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SetTechnique",2,"VisSurface_cl *");
  if(!SWIG_lua_isnilstring(L,3)) SWIG_fail_arg("SetTechnique",3,"char const *");
  if(!SWIG_lua_isnilstring(L,4)) SWIG_fail_arg("SetTechnique",4,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisBaseEntity_cl,0))){
    SWIG_fail_ptr("VisBaseEntity_cl_SetTechnique",1,SWIGTYPE_p_VisBaseEntity_cl);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_VisSurface_cl,0))){
    SWIG_fail_ptr("VisBaseEntity_cl_SetTechnique",2,SWIGTYPE_p_VisSurface_cl);
  }
  
  arg3 = (char *)lua_tostring(L, 3);
  arg4 = (char *)lua_tostring(L, 4);
  result = (bool)VisBaseEntity_cl_SetTechnique__SWIG_0(arg1,arg2,(char const *)arg3,(char const *)arg4);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisBaseEntity_cl_SetTechnique__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  VisBaseEntity_cl *arg1 = (VisBaseEntity_cl *) 0 ;
  int arg2 ;
  char *arg3 = (char *) 0 ;
  char *arg4 = (char *) 0 ;
  char *arg5 = (char *) 0 ;
  bool result;
  
  SWIG_check_num_args("SetTechnique",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetTechnique",1,"VisBaseEntity_cl *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SetTechnique",2,"int");
  if(!SWIG_lua_isnilstring(L,3)) SWIG_fail_arg("SetTechnique",3,"char const *");
  if(!SWIG_lua_isnilstring(L,4)) SWIG_fail_arg("SetTechnique",4,"char const *");
  if(!SWIG_lua_isnilstring(L,5)) SWIG_fail_arg("SetTechnique",5,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisBaseEntity_cl,0))){
    SWIG_fail_ptr("VisBaseEntity_cl_SetTechnique",1,SWIGTYPE_p_VisBaseEntity_cl);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (char *)lua_tostring(L, 3);
  arg4 = (char *)lua_tostring(L, 4);
  arg5 = (char *)lua_tostring(L, 5);
  result = (bool)VisBaseEntity_cl_SetTechnique__SWIG_2(arg1,arg2,(char const *)arg3,(char const *)arg4,(char const *)arg5);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisBaseEntity_cl_SetTechnique__SWIG_3(lua_State* L) {
  int SWIG_arg = 0;
  VisBaseEntity_cl *arg1 = (VisBaseEntity_cl *) 0 ;
  int arg2 ;
  char *arg3 = (char *) 0 ;
  char *arg4 = (char *) 0 ;
  bool result;
  
  SWIG_check_num_args("SetTechnique",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetTechnique",1,"VisBaseEntity_cl *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SetTechnique",2,"int");
  if(!SWIG_lua_isnilstring(L,3)) SWIG_fail_arg("SetTechnique",3,"char const *");
  if(!SWIG_lua_isnilstring(L,4)) SWIG_fail_arg("SetTechnique",4,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisBaseEntity_cl,0))){
    SWIG_fail_ptr("VisBaseEntity_cl_SetTechnique",1,SWIGTYPE_p_VisBaseEntity_cl);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (char *)lua_tostring(L, 3);
  arg4 = (char *)lua_tostring(L, 4);
  result = (bool)VisBaseEntity_cl_SetTechnique__SWIG_2(arg1,arg2,(char const *)arg3,(char const *)arg4);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisBaseEntity_cl_SetTechnique__SWIG_4(lua_State* L) {
  int SWIG_arg = 0;
  VisBaseEntity_cl *arg1 = (VisBaseEntity_cl *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  char *arg4 = (char *) 0 ;
  char *arg5 = (char *) 0 ;
  bool result;
  
  SWIG_check_num_args("SetTechnique",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetTechnique",1,"VisBaseEntity_cl *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("SetTechnique",2,"char const *");
  if(!SWIG_lua_isnilstring(L,3)) SWIG_fail_arg("SetTechnique",3,"char const *");
  if(!SWIG_lua_isnilstring(L,4)) SWIG_fail_arg("SetTechnique",4,"char const *");
  if(!SWIG_lua_isnilstring(L,5)) SWIG_fail_arg("SetTechnique",5,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisBaseEntity_cl,0))){
    SWIG_fail_ptr("VisBaseEntity_cl_SetTechnique",1,SWIGTYPE_p_VisBaseEntity_cl);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  arg3 = (char *)lua_tostring(L, 3);
  arg4 = (char *)lua_tostring(L, 4);
  arg5 = (char *)lua_tostring(L, 5);
  result = (bool)VisBaseEntity_cl_SetTechnique__SWIG_4(arg1,(char const *)arg2,(char const *)arg3,(char const *)arg4,(char const *)arg5);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisBaseEntity_cl_SetTechnique__SWIG_5(lua_State* L) {
  int SWIG_arg = 0;
  VisBaseEntity_cl *arg1 = (VisBaseEntity_cl *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  char *arg4 = (char *) 0 ;
  bool result;
  
  SWIG_check_num_args("SetTechnique",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetTechnique",1,"VisBaseEntity_cl *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("SetTechnique",2,"char const *");
  if(!SWIG_lua_isnilstring(L,3)) SWIG_fail_arg("SetTechnique",3,"char const *");
  if(!SWIG_lua_isnilstring(L,4)) SWIG_fail_arg("SetTechnique",4,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisBaseEntity_cl,0))){
    SWIG_fail_ptr("VisBaseEntity_cl_SetTechnique",1,SWIGTYPE_p_VisBaseEntity_cl);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  arg3 = (char *)lua_tostring(L, 3);
  arg4 = (char *)lua_tostring(L, 4);
  result = (bool)VisBaseEntity_cl_SetTechnique__SWIG_4(arg1,(char const *)arg2,(char const *)arg3,(char const *)arg4);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisBaseEntity_cl_SetTechnique(lua_State* L) {
  int argc;
  int argv[6]={
    1,2,3,4,5,6
  };
  
  argc = lua_gettop(L);
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VisBaseEntity_cl, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_VisSurface_cl, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          _v = SWIG_lua_isnilstring(L,argv[2]);
        }
        if (_v) {
          {
            _v = SWIG_lua_isnilstring(L,argv[3]);
          }
          if (_v) {
            return _wrap_VisBaseEntity_cl_SetTechnique__SWIG_1(L);
          }
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VisBaseEntity_cl, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = SWIG_lua_isnilstring(L,argv[2]);
        }
        if (_v) {
          {
            _v = SWIG_lua_isnilstring(L,argv[3]);
          }
          if (_v) {
            return _wrap_VisBaseEntity_cl_SetTechnique__SWIG_3(L);
          }
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VisBaseEntity_cl, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = SWIG_lua_isnilstring(L,argv[1]);
      }
      if (_v) {
        {
          _v = SWIG_lua_isnilstring(L,argv[2]);
        }
        if (_v) {
          {
            _v = SWIG_lua_isnilstring(L,argv[3]);
          }
          if (_v) {
            return _wrap_VisBaseEntity_cl_SetTechnique__SWIG_5(L);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VisBaseEntity_cl, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_VisSurface_cl, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          _v = SWIG_lua_isnilstring(L,argv[2]);
        }
        if (_v) {
          {
            _v = SWIG_lua_isnilstring(L,argv[3]);
          }
          if (_v) {
            {
              _v = SWIG_lua_isnilstring(L,argv[4]);
            }
            if (_v) {
              return _wrap_VisBaseEntity_cl_SetTechnique__SWIG_0(L);
            }
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VisBaseEntity_cl, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = SWIG_lua_isnilstring(L,argv[2]);
        }
        if (_v) {
          {
            _v = SWIG_lua_isnilstring(L,argv[3]);
          }
          if (_v) {
            {
              _v = SWIG_lua_isnilstring(L,argv[4]);
            }
            if (_v) {
              return _wrap_VisBaseEntity_cl_SetTechnique__SWIG_2(L);
            }
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VisBaseEntity_cl, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = SWIG_lua_isnilstring(L,argv[1]);
      }
      if (_v) {
        {
          _v = SWIG_lua_isnilstring(L,argv[2]);
        }
        if (_v) {
          {
            _v = SWIG_lua_isnilstring(L,argv[3]);
          }
          if (_v) {
            {
              _v = SWIG_lua_isnilstring(L,argv[4]);
            }
            if (_v) {
              return _wrap_VisBaseEntity_cl_SetTechnique__SWIG_4(L);
            }
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'VisBaseEntity_cl_SetTechnique'\n"
    "  Possible C/C++ prototypes are:\n"
    "    SetTechnique(VisBaseEntity_cl *,VisSurface_cl *,char const *,char const *,char const *)\n"
    "    SetTechnique(VisBaseEntity_cl *,VisSurface_cl *,char const *,char const *)\n"
    "    SetTechnique(VisBaseEntity_cl *,int,char const *,char const *,char const *)\n"
    "    SetTechnique(VisBaseEntity_cl *,int,char const *,char const *)\n"
    "    SetTechnique(VisBaseEntity_cl *,char const *,char const *,char const *,char const *)\n"
    "    SetTechnique(VisBaseEntity_cl *,char const *,char const *,char const *)\n");
  lua_error(L);return 0;
}


static int _wrap_VisBaseEntity_cl_AddTechnique__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  VisBaseEntity_cl *arg1 = (VisBaseEntity_cl *) 0 ;
  VisSurface_cl *arg2 = (VisSurface_cl *) 0 ;
  char *arg3 = (char *) 0 ;
  char *arg4 = (char *) 0 ;
  char *arg5 = (char *) 0 ;
  bool result;
  
  SWIG_check_num_args("AddTechnique",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("AddTechnique",1,"VisBaseEntity_cl *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("AddTechnique",2,"VisSurface_cl *");
  if(!SWIG_lua_isnilstring(L,3)) SWIG_fail_arg("AddTechnique",3,"char const *");
  if(!SWIG_lua_isnilstring(L,4)) SWIG_fail_arg("AddTechnique",4,"char const *");
  if(!SWIG_lua_isnilstring(L,5)) SWIG_fail_arg("AddTechnique",5,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisBaseEntity_cl,0))){
    SWIG_fail_ptr("VisBaseEntity_cl_AddTechnique",1,SWIGTYPE_p_VisBaseEntity_cl);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_VisSurface_cl,0))){
    SWIG_fail_ptr("VisBaseEntity_cl_AddTechnique",2,SWIGTYPE_p_VisSurface_cl);
  }
  
  arg3 = (char *)lua_tostring(L, 3);
  arg4 = (char *)lua_tostring(L, 4);
  arg5 = (char *)lua_tostring(L, 5);
  result = (bool)VisBaseEntity_cl_AddTechnique__SWIG_0(arg1,arg2,(char const *)arg3,(char const *)arg4,(char const *)arg5);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisBaseEntity_cl_AddTechnique__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  VisBaseEntity_cl *arg1 = (VisBaseEntity_cl *) 0 ;
  VisSurface_cl *arg2 = (VisSurface_cl *) 0 ;
  char *arg3 = (char *) 0 ;
  char *arg4 = (char *) 0 ;
  bool result;
  
  SWIG_check_num_args("AddTechnique",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("AddTechnique",1,"VisBaseEntity_cl *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("AddTechnique",2,"VisSurface_cl *");
  if(!SWIG_lua_isnilstring(L,3)) SWIG_fail_arg("AddTechnique",3,"char const *");
  if(!SWIG_lua_isnilstring(L,4)) SWIG_fail_arg("AddTechnique",4,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisBaseEntity_cl,0))){
    SWIG_fail_ptr("VisBaseEntity_cl_AddTechnique",1,SWIGTYPE_p_VisBaseEntity_cl);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_VisSurface_cl,0))){
    SWIG_fail_ptr("VisBaseEntity_cl_AddTechnique",2,SWIGTYPE_p_VisSurface_cl);
  }
  
  arg3 = (char *)lua_tostring(L, 3);
  arg4 = (char *)lua_tostring(L, 4);
  result = (bool)VisBaseEntity_cl_AddTechnique__SWIG_0(arg1,arg2,(char const *)arg3,(char const *)arg4);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisBaseEntity_cl_AddTechnique__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  VisBaseEntity_cl *arg1 = (VisBaseEntity_cl *) 0 ;
  int arg2 ;
  char *arg3 = (char *) 0 ;
  char *arg4 = (char *) 0 ;
  char *arg5 = (char *) 0 ;
  bool result;
  
  SWIG_check_num_args("AddTechnique",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("AddTechnique",1,"VisBaseEntity_cl *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("AddTechnique",2,"int");
  if(!SWIG_lua_isnilstring(L,3)) SWIG_fail_arg("AddTechnique",3,"char const *");
  if(!SWIG_lua_isnilstring(L,4)) SWIG_fail_arg("AddTechnique",4,"char const *");
  if(!SWIG_lua_isnilstring(L,5)) SWIG_fail_arg("AddTechnique",5,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisBaseEntity_cl,0))){
    SWIG_fail_ptr("VisBaseEntity_cl_AddTechnique",1,SWIGTYPE_p_VisBaseEntity_cl);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (char *)lua_tostring(L, 3);
  arg4 = (char *)lua_tostring(L, 4);
  arg5 = (char *)lua_tostring(L, 5);
  result = (bool)VisBaseEntity_cl_AddTechnique__SWIG_2(arg1,arg2,(char const *)arg3,(char const *)arg4,(char const *)arg5);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisBaseEntity_cl_AddTechnique__SWIG_3(lua_State* L) {
  int SWIG_arg = 0;
  VisBaseEntity_cl *arg1 = (VisBaseEntity_cl *) 0 ;
  int arg2 ;
  char *arg3 = (char *) 0 ;
  char *arg4 = (char *) 0 ;
  bool result;
  
  SWIG_check_num_args("AddTechnique",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("AddTechnique",1,"VisBaseEntity_cl *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("AddTechnique",2,"int");
  if(!SWIG_lua_isnilstring(L,3)) SWIG_fail_arg("AddTechnique",3,"char const *");
  if(!SWIG_lua_isnilstring(L,4)) SWIG_fail_arg("AddTechnique",4,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisBaseEntity_cl,0))){
    SWIG_fail_ptr("VisBaseEntity_cl_AddTechnique",1,SWIGTYPE_p_VisBaseEntity_cl);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (char *)lua_tostring(L, 3);
  arg4 = (char *)lua_tostring(L, 4);
  result = (bool)VisBaseEntity_cl_AddTechnique__SWIG_2(arg1,arg2,(char const *)arg3,(char const *)arg4);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisBaseEntity_cl_AddTechnique__SWIG_4(lua_State* L) {
  int SWIG_arg = 0;
  VisBaseEntity_cl *arg1 = (VisBaseEntity_cl *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  char *arg4 = (char *) 0 ;
  char *arg5 = (char *) 0 ;
  bool result;
  
  SWIG_check_num_args("AddTechnique",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("AddTechnique",1,"VisBaseEntity_cl *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("AddTechnique",2,"char const *");
  if(!SWIG_lua_isnilstring(L,3)) SWIG_fail_arg("AddTechnique",3,"char const *");
  if(!SWIG_lua_isnilstring(L,4)) SWIG_fail_arg("AddTechnique",4,"char const *");
  if(!SWIG_lua_isnilstring(L,5)) SWIG_fail_arg("AddTechnique",5,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisBaseEntity_cl,0))){
    SWIG_fail_ptr("VisBaseEntity_cl_AddTechnique",1,SWIGTYPE_p_VisBaseEntity_cl);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  arg3 = (char *)lua_tostring(L, 3);
  arg4 = (char *)lua_tostring(L, 4);
  arg5 = (char *)lua_tostring(L, 5);
  result = (bool)VisBaseEntity_cl_AddTechnique__SWIG_4(arg1,(char const *)arg2,(char const *)arg3,(char const *)arg4,(char const *)arg5);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisBaseEntity_cl_AddTechnique__SWIG_5(lua_State* L) {
  int SWIG_arg = 0;
  VisBaseEntity_cl *arg1 = (VisBaseEntity_cl *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  char *arg4 = (char *) 0 ;
  bool result;
  
  SWIG_check_num_args("AddTechnique",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("AddTechnique",1,"VisBaseEntity_cl *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("AddTechnique",2,"char const *");
  if(!SWIG_lua_isnilstring(L,3)) SWIG_fail_arg("AddTechnique",3,"char const *");
  if(!SWIG_lua_isnilstring(L,4)) SWIG_fail_arg("AddTechnique",4,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisBaseEntity_cl,0))){
    SWIG_fail_ptr("VisBaseEntity_cl_AddTechnique",1,SWIGTYPE_p_VisBaseEntity_cl);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  arg3 = (char *)lua_tostring(L, 3);
  arg4 = (char *)lua_tostring(L, 4);
  result = (bool)VisBaseEntity_cl_AddTechnique__SWIG_4(arg1,(char const *)arg2,(char const *)arg3,(char const *)arg4);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisBaseEntity_cl_AddTechnique(lua_State* L) {
  int argc;
  int argv[6]={
    1,2,3,4,5,6
  };
  
  argc = lua_gettop(L);
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VisBaseEntity_cl, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_VisSurface_cl, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          _v = SWIG_lua_isnilstring(L,argv[2]);
        }
        if (_v) {
          {
            _v = SWIG_lua_isnilstring(L,argv[3]);
          }
          if (_v) {
            return _wrap_VisBaseEntity_cl_AddTechnique__SWIG_1(L);
          }
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VisBaseEntity_cl, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = SWIG_lua_isnilstring(L,argv[2]);
        }
        if (_v) {
          {
            _v = SWIG_lua_isnilstring(L,argv[3]);
          }
          if (_v) {
            return _wrap_VisBaseEntity_cl_AddTechnique__SWIG_3(L);
          }
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VisBaseEntity_cl, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = SWIG_lua_isnilstring(L,argv[1]);
      }
      if (_v) {
        {
          _v = SWIG_lua_isnilstring(L,argv[2]);
        }
        if (_v) {
          {
            _v = SWIG_lua_isnilstring(L,argv[3]);
          }
          if (_v) {
            return _wrap_VisBaseEntity_cl_AddTechnique__SWIG_5(L);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VisBaseEntity_cl, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_VisSurface_cl, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          _v = SWIG_lua_isnilstring(L,argv[2]);
        }
        if (_v) {
          {
            _v = SWIG_lua_isnilstring(L,argv[3]);
          }
          if (_v) {
            {
              _v = SWIG_lua_isnilstring(L,argv[4]);
            }
            if (_v) {
              return _wrap_VisBaseEntity_cl_AddTechnique__SWIG_0(L);
            }
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VisBaseEntity_cl, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = SWIG_lua_isnilstring(L,argv[2]);
        }
        if (_v) {
          {
            _v = SWIG_lua_isnilstring(L,argv[3]);
          }
          if (_v) {
            {
              _v = SWIG_lua_isnilstring(L,argv[4]);
            }
            if (_v) {
              return _wrap_VisBaseEntity_cl_AddTechnique__SWIG_2(L);
            }
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VisBaseEntity_cl, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = SWIG_lua_isnilstring(L,argv[1]);
      }
      if (_v) {
        {
          _v = SWIG_lua_isnilstring(L,argv[2]);
        }
        if (_v) {
          {
            _v = SWIG_lua_isnilstring(L,argv[3]);
          }
          if (_v) {
            {
              _v = SWIG_lua_isnilstring(L,argv[4]);
            }
            if (_v) {
              return _wrap_VisBaseEntity_cl_AddTechnique__SWIG_4(L);
            }
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'VisBaseEntity_cl_AddTechnique'\n"
    "  Possible C/C++ prototypes are:\n"
    "    AddTechnique(VisBaseEntity_cl *,VisSurface_cl *,char const *,char const *,char const *)\n"
    "    AddTechnique(VisBaseEntity_cl *,VisSurface_cl *,char const *,char const *)\n"
    "    AddTechnique(VisBaseEntity_cl *,int,char const *,char const *,char const *)\n"
    "    AddTechnique(VisBaseEntity_cl *,int,char const *,char const *)\n"
    "    AddTechnique(VisBaseEntity_cl *,char const *,char const *,char const *,char const *)\n"
    "    AddTechnique(VisBaseEntity_cl *,char const *,char const *,char const *)\n");
  lua_error(L);return 0;
}


static int _wrap_VisBaseEntity_cl_SetEffect__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  VisBaseEntity_cl *arg1 = (VisBaseEntity_cl *) 0 ;
  VisSurface_cl *arg2 = (VisSurface_cl *) 0 ;
  char *arg3 = (char *) 0 ;
  char *arg4 = (char *) 0 ;
  char *arg5 = (char *) 0 ;
  bool result;
  
  SWIG_check_num_args("SetEffect",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetEffect",1,"VisBaseEntity_cl *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SetEffect",2,"VisSurface_cl *");
  if(!SWIG_lua_isnilstring(L,3)) SWIG_fail_arg("SetEffect",3,"char const *");
  if(!SWIG_lua_isnilstring(L,4)) SWIG_fail_arg("SetEffect",4,"char const *");
  if(!SWIG_lua_isnilstring(L,5)) SWIG_fail_arg("SetEffect",5,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisBaseEntity_cl,0))){
    SWIG_fail_ptr("VisBaseEntity_cl_SetEffect",1,SWIGTYPE_p_VisBaseEntity_cl);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_VisSurface_cl,0))){
    SWIG_fail_ptr("VisBaseEntity_cl_SetEffect",2,SWIGTYPE_p_VisSurface_cl);
  }
  
  arg3 = (char *)lua_tostring(L, 3);
  arg4 = (char *)lua_tostring(L, 4);
  arg5 = (char *)lua_tostring(L, 5);
  result = (bool)VisBaseEntity_cl_SetEffect__SWIG_0(arg1,arg2,(char const *)arg3,(char const *)arg4,(char const *)arg5);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisBaseEntity_cl_SetEffect__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  VisBaseEntity_cl *arg1 = (VisBaseEntity_cl *) 0 ;
  VisSurface_cl *arg2 = (VisSurface_cl *) 0 ;
  char *arg3 = (char *) 0 ;
  char *arg4 = (char *) 0 ;
  bool result;
  
  SWIG_check_num_args("SetEffect",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetEffect",1,"VisBaseEntity_cl *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SetEffect",2,"VisSurface_cl *");
  if(!SWIG_lua_isnilstring(L,3)) SWIG_fail_arg("SetEffect",3,"char const *");
  if(!SWIG_lua_isnilstring(L,4)) SWIG_fail_arg("SetEffect",4,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisBaseEntity_cl,0))){
    SWIG_fail_ptr("VisBaseEntity_cl_SetEffect",1,SWIGTYPE_p_VisBaseEntity_cl);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_VisSurface_cl,0))){
    SWIG_fail_ptr("VisBaseEntity_cl_SetEffect",2,SWIGTYPE_p_VisSurface_cl);
  }
  
  arg3 = (char *)lua_tostring(L, 3);
  arg4 = (char *)lua_tostring(L, 4);
  result = (bool)VisBaseEntity_cl_SetEffect__SWIG_0(arg1,arg2,(char const *)arg3,(char const *)arg4);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisBaseEntity_cl_SetEffect__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  VisBaseEntity_cl *arg1 = (VisBaseEntity_cl *) 0 ;
  int arg2 ;
  char *arg3 = (char *) 0 ;
  char *arg4 = (char *) 0 ;
  char *arg5 = (char *) 0 ;
  bool result;
  
  SWIG_check_num_args("SetEffect",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetEffect",1,"VisBaseEntity_cl *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SetEffect",2,"int");
  if(!SWIG_lua_isnilstring(L,3)) SWIG_fail_arg("SetEffect",3,"char const *");
  if(!SWIG_lua_isnilstring(L,4)) SWIG_fail_arg("SetEffect",4,"char const *");
  if(!SWIG_lua_isnilstring(L,5)) SWIG_fail_arg("SetEffect",5,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisBaseEntity_cl,0))){
    SWIG_fail_ptr("VisBaseEntity_cl_SetEffect",1,SWIGTYPE_p_VisBaseEntity_cl);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (char *)lua_tostring(L, 3);
  arg4 = (char *)lua_tostring(L, 4);
  arg5 = (char *)lua_tostring(L, 5);
  result = (bool)VisBaseEntity_cl_SetEffect__SWIG_2(arg1,arg2,(char const *)arg3,(char const *)arg4,(char const *)arg5);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisBaseEntity_cl_SetEffect__SWIG_3(lua_State* L) {
  int SWIG_arg = 0;
  VisBaseEntity_cl *arg1 = (VisBaseEntity_cl *) 0 ;
  int arg2 ;
  char *arg3 = (char *) 0 ;
  char *arg4 = (char *) 0 ;
  bool result;
  
  SWIG_check_num_args("SetEffect",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetEffect",1,"VisBaseEntity_cl *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SetEffect",2,"int");
  if(!SWIG_lua_isnilstring(L,3)) SWIG_fail_arg("SetEffect",3,"char const *");
  if(!SWIG_lua_isnilstring(L,4)) SWIG_fail_arg("SetEffect",4,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisBaseEntity_cl,0))){
    SWIG_fail_ptr("VisBaseEntity_cl_SetEffect",1,SWIGTYPE_p_VisBaseEntity_cl);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (char *)lua_tostring(L, 3);
  arg4 = (char *)lua_tostring(L, 4);
  result = (bool)VisBaseEntity_cl_SetEffect__SWIG_2(arg1,arg2,(char const *)arg3,(char const *)arg4);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisBaseEntity_cl_SetEffect__SWIG_4(lua_State* L) {
  int SWIG_arg = 0;
  VisBaseEntity_cl *arg1 = (VisBaseEntity_cl *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  char *arg4 = (char *) 0 ;
  char *arg5 = (char *) 0 ;
  bool result;
  
  SWIG_check_num_args("SetEffect",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetEffect",1,"VisBaseEntity_cl *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("SetEffect",2,"char const *");
  if(!SWIG_lua_isnilstring(L,3)) SWIG_fail_arg("SetEffect",3,"char const *");
  if(!SWIG_lua_isnilstring(L,4)) SWIG_fail_arg("SetEffect",4,"char const *");
  if(!SWIG_lua_isnilstring(L,5)) SWIG_fail_arg("SetEffect",5,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisBaseEntity_cl,0))){
    SWIG_fail_ptr("VisBaseEntity_cl_SetEffect",1,SWIGTYPE_p_VisBaseEntity_cl);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  arg3 = (char *)lua_tostring(L, 3);
  arg4 = (char *)lua_tostring(L, 4);
  arg5 = (char *)lua_tostring(L, 5);
  result = (bool)VisBaseEntity_cl_SetEffect__SWIG_4(arg1,(char const *)arg2,(char const *)arg3,(char const *)arg4,(char const *)arg5);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisBaseEntity_cl_SetEffect__SWIG_5(lua_State* L) {
  int SWIG_arg = 0;
  VisBaseEntity_cl *arg1 = (VisBaseEntity_cl *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  char *arg4 = (char *) 0 ;
  bool result;
  
  SWIG_check_num_args("SetEffect",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetEffect",1,"VisBaseEntity_cl *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("SetEffect",2,"char const *");
  if(!SWIG_lua_isnilstring(L,3)) SWIG_fail_arg("SetEffect",3,"char const *");
  if(!SWIG_lua_isnilstring(L,4)) SWIG_fail_arg("SetEffect",4,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisBaseEntity_cl,0))){
    SWIG_fail_ptr("VisBaseEntity_cl_SetEffect",1,SWIGTYPE_p_VisBaseEntity_cl);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  arg3 = (char *)lua_tostring(L, 3);
  arg4 = (char *)lua_tostring(L, 4);
  result = (bool)VisBaseEntity_cl_SetEffect__SWIG_4(arg1,(char const *)arg2,(char const *)arg3,(char const *)arg4);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisBaseEntity_cl_SetEffect(lua_State* L) {
  int argc;
  int argv[6]={
    1,2,3,4,5,6
  };
  
  argc = lua_gettop(L);
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VisBaseEntity_cl, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_VisSurface_cl, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          _v = SWIG_lua_isnilstring(L,argv[2]);
        }
        if (_v) {
          {
            _v = SWIG_lua_isnilstring(L,argv[3]);
          }
          if (_v) {
            return _wrap_VisBaseEntity_cl_SetEffect__SWIG_1(L);
          }
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VisBaseEntity_cl, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = SWIG_lua_isnilstring(L,argv[2]);
        }
        if (_v) {
          {
            _v = SWIG_lua_isnilstring(L,argv[3]);
          }
          if (_v) {
            return _wrap_VisBaseEntity_cl_SetEffect__SWIG_3(L);
          }
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VisBaseEntity_cl, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = SWIG_lua_isnilstring(L,argv[1]);
      }
      if (_v) {
        {
          _v = SWIG_lua_isnilstring(L,argv[2]);
        }
        if (_v) {
          {
            _v = SWIG_lua_isnilstring(L,argv[3]);
          }
          if (_v) {
            return _wrap_VisBaseEntity_cl_SetEffect__SWIG_5(L);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VisBaseEntity_cl, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_VisSurface_cl, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          _v = SWIG_lua_isnilstring(L,argv[2]);
        }
        if (_v) {
          {
            _v = SWIG_lua_isnilstring(L,argv[3]);
          }
          if (_v) {
            {
              _v = SWIG_lua_isnilstring(L,argv[4]);
            }
            if (_v) {
              return _wrap_VisBaseEntity_cl_SetEffect__SWIG_0(L);
            }
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VisBaseEntity_cl, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = SWIG_lua_isnilstring(L,argv[2]);
        }
        if (_v) {
          {
            _v = SWIG_lua_isnilstring(L,argv[3]);
          }
          if (_v) {
            {
              _v = SWIG_lua_isnilstring(L,argv[4]);
            }
            if (_v) {
              return _wrap_VisBaseEntity_cl_SetEffect__SWIG_2(L);
            }
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VisBaseEntity_cl, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = SWIG_lua_isnilstring(L,argv[1]);
      }
      if (_v) {
        {
          _v = SWIG_lua_isnilstring(L,argv[2]);
        }
        if (_v) {
          {
            _v = SWIG_lua_isnilstring(L,argv[3]);
          }
          if (_v) {
            {
              _v = SWIG_lua_isnilstring(L,argv[4]);
            }
            if (_v) {
              return _wrap_VisBaseEntity_cl_SetEffect__SWIG_4(L);
            }
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'VisBaseEntity_cl_SetEffect'\n"
    "  Possible C/C++ prototypes are:\n"
    "    SetEffect(VisBaseEntity_cl *,VisSurface_cl *,char const *,char const *,char const *)\n"
    "    SetEffect(VisBaseEntity_cl *,VisSurface_cl *,char const *,char const *)\n"
    "    SetEffect(VisBaseEntity_cl *,int,char const *,char const *,char const *)\n"
    "    SetEffect(VisBaseEntity_cl *,int,char const *,char const *)\n"
    "    SetEffect(VisBaseEntity_cl *,char const *,char const *,char const *,char const *)\n"
    "    SetEffect(VisBaseEntity_cl *,char const *,char const *,char const *)\n");
  lua_error(L);return 0;
}


static int _wrap_VisBaseEntity_cl_AddEffect__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  VisBaseEntity_cl *arg1 = (VisBaseEntity_cl *) 0 ;
  VisSurface_cl *arg2 = (VisSurface_cl *) 0 ;
  char *arg3 = (char *) 0 ;
  char *arg4 = (char *) 0 ;
  char *arg5 = (char *) 0 ;
  bool result;
  
  SWIG_check_num_args("AddEffect",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("AddEffect",1,"VisBaseEntity_cl *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("AddEffect",2,"VisSurface_cl *");
  if(!SWIG_lua_isnilstring(L,3)) SWIG_fail_arg("AddEffect",3,"char const *");
  if(!SWIG_lua_isnilstring(L,4)) SWIG_fail_arg("AddEffect",4,"char const *");
  if(!SWIG_lua_isnilstring(L,5)) SWIG_fail_arg("AddEffect",5,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisBaseEntity_cl,0))){
    SWIG_fail_ptr("VisBaseEntity_cl_AddEffect",1,SWIGTYPE_p_VisBaseEntity_cl);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_VisSurface_cl,0))){
    SWIG_fail_ptr("VisBaseEntity_cl_AddEffect",2,SWIGTYPE_p_VisSurface_cl);
  }
  
  arg3 = (char *)lua_tostring(L, 3);
  arg4 = (char *)lua_tostring(L, 4);
  arg5 = (char *)lua_tostring(L, 5);
  result = (bool)VisBaseEntity_cl_AddEffect__SWIG_0(arg1,arg2,(char const *)arg3,(char const *)arg4,(char const *)arg5);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisBaseEntity_cl_AddEffect__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  VisBaseEntity_cl *arg1 = (VisBaseEntity_cl *) 0 ;
  VisSurface_cl *arg2 = (VisSurface_cl *) 0 ;
  char *arg3 = (char *) 0 ;
  char *arg4 = (char *) 0 ;
  bool result;
  
  SWIG_check_num_args("AddEffect",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("AddEffect",1,"VisBaseEntity_cl *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("AddEffect",2,"VisSurface_cl *");
  if(!SWIG_lua_isnilstring(L,3)) SWIG_fail_arg("AddEffect",3,"char const *");
  if(!SWIG_lua_isnilstring(L,4)) SWIG_fail_arg("AddEffect",4,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisBaseEntity_cl,0))){
    SWIG_fail_ptr("VisBaseEntity_cl_AddEffect",1,SWIGTYPE_p_VisBaseEntity_cl);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_VisSurface_cl,0))){
    SWIG_fail_ptr("VisBaseEntity_cl_AddEffect",2,SWIGTYPE_p_VisSurface_cl);
  }
  
  arg3 = (char *)lua_tostring(L, 3);
  arg4 = (char *)lua_tostring(L, 4);
  result = (bool)VisBaseEntity_cl_AddEffect__SWIG_0(arg1,arg2,(char const *)arg3,(char const *)arg4);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisBaseEntity_cl_AddEffect__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  VisBaseEntity_cl *arg1 = (VisBaseEntity_cl *) 0 ;
  int arg2 ;
  char *arg3 = (char *) 0 ;
  char *arg4 = (char *) 0 ;
  char *arg5 = (char *) 0 ;
  bool result;
  
  SWIG_check_num_args("AddEffect",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("AddEffect",1,"VisBaseEntity_cl *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("AddEffect",2,"int");
  if(!SWIG_lua_isnilstring(L,3)) SWIG_fail_arg("AddEffect",3,"char const *");
  if(!SWIG_lua_isnilstring(L,4)) SWIG_fail_arg("AddEffect",4,"char const *");
  if(!SWIG_lua_isnilstring(L,5)) SWIG_fail_arg("AddEffect",5,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisBaseEntity_cl,0))){
    SWIG_fail_ptr("VisBaseEntity_cl_AddEffect",1,SWIGTYPE_p_VisBaseEntity_cl);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (char *)lua_tostring(L, 3);
  arg4 = (char *)lua_tostring(L, 4);
  arg5 = (char *)lua_tostring(L, 5);
  result = (bool)VisBaseEntity_cl_AddEffect__SWIG_2(arg1,arg2,(char const *)arg3,(char const *)arg4,(char const *)arg5);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisBaseEntity_cl_AddEffect__SWIG_3(lua_State* L) {
  int SWIG_arg = 0;
  VisBaseEntity_cl *arg1 = (VisBaseEntity_cl *) 0 ;
  int arg2 ;
  char *arg3 = (char *) 0 ;
  char *arg4 = (char *) 0 ;
  bool result;
  
  SWIG_check_num_args("AddEffect",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("AddEffect",1,"VisBaseEntity_cl *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("AddEffect",2,"int");
  if(!SWIG_lua_isnilstring(L,3)) SWIG_fail_arg("AddEffect",3,"char const *");
  if(!SWIG_lua_isnilstring(L,4)) SWIG_fail_arg("AddEffect",4,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisBaseEntity_cl,0))){
    SWIG_fail_ptr("VisBaseEntity_cl_AddEffect",1,SWIGTYPE_p_VisBaseEntity_cl);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (char *)lua_tostring(L, 3);
  arg4 = (char *)lua_tostring(L, 4);
  result = (bool)VisBaseEntity_cl_AddEffect__SWIG_2(arg1,arg2,(char const *)arg3,(char const *)arg4);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisBaseEntity_cl_AddEffect__SWIG_4(lua_State* L) {
  int SWIG_arg = 0;
  VisBaseEntity_cl *arg1 = (VisBaseEntity_cl *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  char *arg4 = (char *) 0 ;
  char *arg5 = (char *) 0 ;
  bool result;
  
  SWIG_check_num_args("AddEffect",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("AddEffect",1,"VisBaseEntity_cl *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("AddEffect",2,"char const *");
  if(!SWIG_lua_isnilstring(L,3)) SWIG_fail_arg("AddEffect",3,"char const *");
  if(!SWIG_lua_isnilstring(L,4)) SWIG_fail_arg("AddEffect",4,"char const *");
  if(!SWIG_lua_isnilstring(L,5)) SWIG_fail_arg("AddEffect",5,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisBaseEntity_cl,0))){
    SWIG_fail_ptr("VisBaseEntity_cl_AddEffect",1,SWIGTYPE_p_VisBaseEntity_cl);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  arg3 = (char *)lua_tostring(L, 3);
  arg4 = (char *)lua_tostring(L, 4);
  arg5 = (char *)lua_tostring(L, 5);
  result = (bool)VisBaseEntity_cl_AddEffect__SWIG_4(arg1,(char const *)arg2,(char const *)arg3,(char const *)arg4,(char const *)arg5);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisBaseEntity_cl_AddEffect__SWIG_5(lua_State* L) {
  int SWIG_arg = 0;
  VisBaseEntity_cl *arg1 = (VisBaseEntity_cl *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  char *arg4 = (char *) 0 ;
  bool result;
  
  SWIG_check_num_args("AddEffect",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("AddEffect",1,"VisBaseEntity_cl *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("AddEffect",2,"char const *");
  if(!SWIG_lua_isnilstring(L,3)) SWIG_fail_arg("AddEffect",3,"char const *");
  if(!SWIG_lua_isnilstring(L,4)) SWIG_fail_arg("AddEffect",4,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisBaseEntity_cl,0))){
    SWIG_fail_ptr("VisBaseEntity_cl_AddEffect",1,SWIGTYPE_p_VisBaseEntity_cl);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  arg3 = (char *)lua_tostring(L, 3);
  arg4 = (char *)lua_tostring(L, 4);
  result = (bool)VisBaseEntity_cl_AddEffect__SWIG_4(arg1,(char const *)arg2,(char const *)arg3,(char const *)arg4);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisBaseEntity_cl_AddEffect(lua_State* L) {
  int argc;
  int argv[6]={
    1,2,3,4,5,6
  };
  
  argc = lua_gettop(L);
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VisBaseEntity_cl, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_VisSurface_cl, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          _v = SWIG_lua_isnilstring(L,argv[2]);
        }
        if (_v) {
          {
            _v = SWIG_lua_isnilstring(L,argv[3]);
          }
          if (_v) {
            return _wrap_VisBaseEntity_cl_AddEffect__SWIG_1(L);
          }
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VisBaseEntity_cl, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = SWIG_lua_isnilstring(L,argv[2]);
        }
        if (_v) {
          {
            _v = SWIG_lua_isnilstring(L,argv[3]);
          }
          if (_v) {
            return _wrap_VisBaseEntity_cl_AddEffect__SWIG_3(L);
          }
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VisBaseEntity_cl, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = SWIG_lua_isnilstring(L,argv[1]);
      }
      if (_v) {
        {
          _v = SWIG_lua_isnilstring(L,argv[2]);
        }
        if (_v) {
          {
            _v = SWIG_lua_isnilstring(L,argv[3]);
          }
          if (_v) {
            return _wrap_VisBaseEntity_cl_AddEffect__SWIG_5(L);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VisBaseEntity_cl, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_VisSurface_cl, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          _v = SWIG_lua_isnilstring(L,argv[2]);
        }
        if (_v) {
          {
            _v = SWIG_lua_isnilstring(L,argv[3]);
          }
          if (_v) {
            {
              _v = SWIG_lua_isnilstring(L,argv[4]);
            }
            if (_v) {
              return _wrap_VisBaseEntity_cl_AddEffect__SWIG_0(L);
            }
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VisBaseEntity_cl, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = SWIG_lua_isnilstring(L,argv[2]);
        }
        if (_v) {
          {
            _v = SWIG_lua_isnilstring(L,argv[3]);
          }
          if (_v) {
            {
              _v = SWIG_lua_isnilstring(L,argv[4]);
            }
            if (_v) {
              return _wrap_VisBaseEntity_cl_AddEffect__SWIG_2(L);
            }
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VisBaseEntity_cl, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = SWIG_lua_isnilstring(L,argv[1]);
      }
      if (_v) {
        {
          _v = SWIG_lua_isnilstring(L,argv[2]);
        }
        if (_v) {
          {
            _v = SWIG_lua_isnilstring(L,argv[3]);
          }
          if (_v) {
            {
              _v = SWIG_lua_isnilstring(L,argv[4]);
            }
            if (_v) {
              return _wrap_VisBaseEntity_cl_AddEffect__SWIG_4(L);
            }
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'VisBaseEntity_cl_AddEffect'\n"
    "  Possible C/C++ prototypes are:\n"
    "    AddEffect(VisBaseEntity_cl *,VisSurface_cl *,char const *,char const *,char const *)\n"
    "    AddEffect(VisBaseEntity_cl *,VisSurface_cl *,char const *,char const *)\n"
    "    AddEffect(VisBaseEntity_cl *,int,char const *,char const *,char const *)\n"
    "    AddEffect(VisBaseEntity_cl *,int,char const *,char const *)\n"
    "    AddEffect(VisBaseEntity_cl *,char const *,char const *,char const *,char const *)\n"
    "    AddEffect(VisBaseEntity_cl *,char const *,char const *,char const *)\n");
  lua_error(L);return 0;
}


static int _wrap_VisBaseEntity_cl_SetTextureForSurface__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  VisBaseEntity_cl *arg1 = (VisBaseEntity_cl *) 0 ;
  VTextureObject *arg2 = (VTextureObject *) 0 ;
  VisSurface_cl *arg3 = (VisSurface_cl *) 0 ;
  int arg4 ;
  bool result;
  
  SWIG_check_num_args("SetTextureForSurface",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetTextureForSurface",1,"VisBaseEntity_cl *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SetTextureForSurface",2,"VTextureObject *");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("SetTextureForSurface",3,"VisSurface_cl *");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("SetTextureForSurface",4,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisBaseEntity_cl,0))){
    SWIG_fail_ptr("VisBaseEntity_cl_SetTextureForSurface",1,SWIGTYPE_p_VisBaseEntity_cl);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_VTextureObject,0))){
    SWIG_fail_ptr("VisBaseEntity_cl_SetTextureForSurface",2,SWIGTYPE_p_VTextureObject);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_VisSurface_cl,0))){
    SWIG_fail_ptr("VisBaseEntity_cl_SetTextureForSurface",3,SWIGTYPE_p_VisSurface_cl);
  }
  
  arg4 = (int)lua_tonumber(L, 4);
  result = (bool)VisBaseEntity_cl_SetTextureForSurface__SWIG_0(arg1,arg2,arg3,arg4);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisBaseEntity_cl_SetTextureForSurface__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  VisBaseEntity_cl *arg1 = (VisBaseEntity_cl *) 0 ;
  VTextureObject *arg2 = (VTextureObject *) 0 ;
  VisSurface_cl *arg3 = (VisSurface_cl *) 0 ;
  bool result;
  
  SWIG_check_num_args("SetTextureForSurface",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetTextureForSurface",1,"VisBaseEntity_cl *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SetTextureForSurface",2,"VTextureObject *");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("SetTextureForSurface",3,"VisSurface_cl *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisBaseEntity_cl,0))){
    SWIG_fail_ptr("VisBaseEntity_cl_SetTextureForSurface",1,SWIGTYPE_p_VisBaseEntity_cl);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_VTextureObject,0))){
    SWIG_fail_ptr("VisBaseEntity_cl_SetTextureForSurface",2,SWIGTYPE_p_VTextureObject);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_VisSurface_cl,0))){
    SWIG_fail_ptr("VisBaseEntity_cl_SetTextureForSurface",3,SWIGTYPE_p_VisSurface_cl);
  }
  
  result = (bool)VisBaseEntity_cl_SetTextureForSurface__SWIG_0(arg1,arg2,arg3);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisBaseEntity_cl_SetTextureForSurface__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  VisBaseEntity_cl *arg1 = (VisBaseEntity_cl *) 0 ;
  VTextureObject *arg2 = (VTextureObject *) 0 ;
  char *arg3 = (char *) 0 ;
  int arg4 ;
  bool result;
  
  SWIG_check_num_args("SetTextureForSurface",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetTextureForSurface",1,"VisBaseEntity_cl *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SetTextureForSurface",2,"VTextureObject *");
  if(!SWIG_lua_isnilstring(L,3)) SWIG_fail_arg("SetTextureForSurface",3,"char const *");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("SetTextureForSurface",4,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisBaseEntity_cl,0))){
    SWIG_fail_ptr("VisBaseEntity_cl_SetTextureForSurface",1,SWIGTYPE_p_VisBaseEntity_cl);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_VTextureObject,0))){
    SWIG_fail_ptr("VisBaseEntity_cl_SetTextureForSurface",2,SWIGTYPE_p_VTextureObject);
  }
  
  arg3 = (char *)lua_tostring(L, 3);
  arg4 = (int)lua_tonumber(L, 4);
  result = (bool)VisBaseEntity_cl_SetTextureForSurface__SWIG_2(arg1,arg2,(char const *)arg3,arg4);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisBaseEntity_cl_SetTextureForSurface__SWIG_3(lua_State* L) {
  int SWIG_arg = 0;
  VisBaseEntity_cl *arg1 = (VisBaseEntity_cl *) 0 ;
  VTextureObject *arg2 = (VTextureObject *) 0 ;
  char *arg3 = (char *) 0 ;
  bool result;
  
  SWIG_check_num_args("SetTextureForSurface",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetTextureForSurface",1,"VisBaseEntity_cl *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SetTextureForSurface",2,"VTextureObject *");
  if(!SWIG_lua_isnilstring(L,3)) SWIG_fail_arg("SetTextureForSurface",3,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisBaseEntity_cl,0))){
    SWIG_fail_ptr("VisBaseEntity_cl_SetTextureForSurface",1,SWIGTYPE_p_VisBaseEntity_cl);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_VTextureObject,0))){
    SWIG_fail_ptr("VisBaseEntity_cl_SetTextureForSurface",2,SWIGTYPE_p_VTextureObject);
  }
  
  arg3 = (char *)lua_tostring(L, 3);
  result = (bool)VisBaseEntity_cl_SetTextureForSurface__SWIG_2(arg1,arg2,(char const *)arg3);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisBaseEntity_cl_SetTextureForSurface__SWIG_4(lua_State* L) {
  int SWIG_arg = 0;
  VisBaseEntity_cl *arg1 = (VisBaseEntity_cl *) 0 ;
  VTextureObject *arg2 = (VTextureObject *) 0 ;
  int arg3 ;
  int arg4 ;
  bool result;
  
  SWIG_check_num_args("SetTextureForSurface",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetTextureForSurface",1,"VisBaseEntity_cl *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SetTextureForSurface",2,"VTextureObject *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("SetTextureForSurface",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("SetTextureForSurface",4,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisBaseEntity_cl,0))){
    SWIG_fail_ptr("VisBaseEntity_cl_SetTextureForSurface",1,SWIGTYPE_p_VisBaseEntity_cl);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_VTextureObject,0))){
    SWIG_fail_ptr("VisBaseEntity_cl_SetTextureForSurface",2,SWIGTYPE_p_VTextureObject);
  }
  
  arg3 = (int)lua_tonumber(L, 3);
  arg4 = (int)lua_tonumber(L, 4);
  result = (bool)VisBaseEntity_cl_SetTextureForSurface__SWIG_4(arg1,arg2,arg3,arg4);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisBaseEntity_cl_SetTextureForSurface__SWIG_5(lua_State* L) {
  int SWIG_arg = 0;
  VisBaseEntity_cl *arg1 = (VisBaseEntity_cl *) 0 ;
  VTextureObject *arg2 = (VTextureObject *) 0 ;
  int arg3 ;
  bool result;
  
  SWIG_check_num_args("SetTextureForSurface",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetTextureForSurface",1,"VisBaseEntity_cl *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SetTextureForSurface",2,"VTextureObject *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("SetTextureForSurface",3,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisBaseEntity_cl,0))){
    SWIG_fail_ptr("VisBaseEntity_cl_SetTextureForSurface",1,SWIGTYPE_p_VisBaseEntity_cl);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_VTextureObject,0))){
    SWIG_fail_ptr("VisBaseEntity_cl_SetTextureForSurface",2,SWIGTYPE_p_VTextureObject);
  }
  
  arg3 = (int)lua_tonumber(L, 3);
  result = (bool)VisBaseEntity_cl_SetTextureForSurface__SWIG_4(arg1,arg2,arg3);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisBaseEntity_cl_SetTextureForSurface__SWIG_6(lua_State* L) {
  int SWIG_arg = 0;
  VisBaseEntity_cl *arg1 = (VisBaseEntity_cl *) 0 ;
  char *arg2 = (char *) 0 ;
  VisSurface_cl *arg3 = (VisSurface_cl *) 0 ;
  int arg4 ;
  bool result;
  
  SWIG_check_num_args("SetTextureForSurface",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetTextureForSurface",1,"VisBaseEntity_cl *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("SetTextureForSurface",2,"char const *");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("SetTextureForSurface",3,"VisSurface_cl *");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("SetTextureForSurface",4,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisBaseEntity_cl,0))){
    SWIG_fail_ptr("VisBaseEntity_cl_SetTextureForSurface",1,SWIGTYPE_p_VisBaseEntity_cl);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_VisSurface_cl,0))){
    SWIG_fail_ptr("VisBaseEntity_cl_SetTextureForSurface",3,SWIGTYPE_p_VisSurface_cl);
  }
  
  arg4 = (int)lua_tonumber(L, 4);
  result = (bool)VisBaseEntity_cl_SetTextureForSurface__SWIG_6(arg1,(char const *)arg2,arg3,arg4);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisBaseEntity_cl_SetTextureForSurface__SWIG_7(lua_State* L) {
  int SWIG_arg = 0;
  VisBaseEntity_cl *arg1 = (VisBaseEntity_cl *) 0 ;
  char *arg2 = (char *) 0 ;
  VisSurface_cl *arg3 = (VisSurface_cl *) 0 ;
  bool result;
  
  SWIG_check_num_args("SetTextureForSurface",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetTextureForSurface",1,"VisBaseEntity_cl *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("SetTextureForSurface",2,"char const *");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("SetTextureForSurface",3,"VisSurface_cl *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisBaseEntity_cl,0))){
    SWIG_fail_ptr("VisBaseEntity_cl_SetTextureForSurface",1,SWIGTYPE_p_VisBaseEntity_cl);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_VisSurface_cl,0))){
    SWIG_fail_ptr("VisBaseEntity_cl_SetTextureForSurface",3,SWIGTYPE_p_VisSurface_cl);
  }
  
  result = (bool)VisBaseEntity_cl_SetTextureForSurface__SWIG_6(arg1,(char const *)arg2,arg3);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisBaseEntity_cl_SetTextureForSurface__SWIG_8(lua_State* L) {
  int SWIG_arg = 0;
  VisBaseEntity_cl *arg1 = (VisBaseEntity_cl *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  int arg4 ;
  bool result;
  
  SWIG_check_num_args("SetTextureForSurface",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetTextureForSurface",1,"VisBaseEntity_cl *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("SetTextureForSurface",2,"char const *");
  if(!SWIG_lua_isnilstring(L,3)) SWIG_fail_arg("SetTextureForSurface",3,"char const *");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("SetTextureForSurface",4,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisBaseEntity_cl,0))){
    SWIG_fail_ptr("VisBaseEntity_cl_SetTextureForSurface",1,SWIGTYPE_p_VisBaseEntity_cl);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  arg3 = (char *)lua_tostring(L, 3);
  arg4 = (int)lua_tonumber(L, 4);
  result = (bool)VisBaseEntity_cl_SetTextureForSurface__SWIG_8(arg1,(char const *)arg2,(char const *)arg3,arg4);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisBaseEntity_cl_SetTextureForSurface__SWIG_9(lua_State* L) {
  int SWIG_arg = 0;
  VisBaseEntity_cl *arg1 = (VisBaseEntity_cl *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  bool result;
  
  SWIG_check_num_args("SetTextureForSurface",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetTextureForSurface",1,"VisBaseEntity_cl *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("SetTextureForSurface",2,"char const *");
  if(!SWIG_lua_isnilstring(L,3)) SWIG_fail_arg("SetTextureForSurface",3,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisBaseEntity_cl,0))){
    SWIG_fail_ptr("VisBaseEntity_cl_SetTextureForSurface",1,SWIGTYPE_p_VisBaseEntity_cl);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  arg3 = (char *)lua_tostring(L, 3);
  result = (bool)VisBaseEntity_cl_SetTextureForSurface__SWIG_8(arg1,(char const *)arg2,(char const *)arg3);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisBaseEntity_cl_SetTextureForSurface__SWIG_10(lua_State* L) {
  int SWIG_arg = 0;
  VisBaseEntity_cl *arg1 = (VisBaseEntity_cl *) 0 ;
  char *arg2 = (char *) 0 ;
  int arg3 ;
  int arg4 ;
  bool result;
  
  SWIG_check_num_args("SetTextureForSurface",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetTextureForSurface",1,"VisBaseEntity_cl *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("SetTextureForSurface",2,"char const *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("SetTextureForSurface",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("SetTextureForSurface",4,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisBaseEntity_cl,0))){
    SWIG_fail_ptr("VisBaseEntity_cl_SetTextureForSurface",1,SWIGTYPE_p_VisBaseEntity_cl);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  arg3 = (int)lua_tonumber(L, 3);
  arg4 = (int)lua_tonumber(L, 4);
  result = (bool)VisBaseEntity_cl_SetTextureForSurface__SWIG_10(arg1,(char const *)arg2,arg3,arg4);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisBaseEntity_cl_SetTextureForSurface__SWIG_11(lua_State* L) {
  int SWIG_arg = 0;
  VisBaseEntity_cl *arg1 = (VisBaseEntity_cl *) 0 ;
  char *arg2 = (char *) 0 ;
  int arg3 ;
  bool result;
  
  SWIG_check_num_args("SetTextureForSurface",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetTextureForSurface",1,"VisBaseEntity_cl *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("SetTextureForSurface",2,"char const *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("SetTextureForSurface",3,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisBaseEntity_cl,0))){
    SWIG_fail_ptr("VisBaseEntity_cl_SetTextureForSurface",1,SWIGTYPE_p_VisBaseEntity_cl);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  arg3 = (int)lua_tonumber(L, 3);
  result = (bool)VisBaseEntity_cl_SetTextureForSurface__SWIG_10(arg1,(char const *)arg2,arg3);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisBaseEntity_cl_SetTextureForSurface(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VisBaseEntity_cl, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_VTextureObject, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          void *ptr;
          if (SWIG_isptrtype(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_VisSurface_cl, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          return _wrap_VisBaseEntity_cl_SetTextureForSurface__SWIG_1(L);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VisBaseEntity_cl, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_VTextureObject, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          return _wrap_VisBaseEntity_cl_SetTextureForSurface__SWIG_5(L);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VisBaseEntity_cl, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_VTextureObject, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          _v = SWIG_lua_isnilstring(L,argv[2]);
        }
        if (_v) {
          return _wrap_VisBaseEntity_cl_SetTextureForSurface__SWIG_3(L);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VisBaseEntity_cl, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = SWIG_lua_isnilstring(L,argv[1]);
      }
      if (_v) {
        {
          void *ptr;
          if (SWIG_isptrtype(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_VisSurface_cl, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          return _wrap_VisBaseEntity_cl_SetTextureForSurface__SWIG_7(L);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VisBaseEntity_cl, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = SWIG_lua_isnilstring(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          return _wrap_VisBaseEntity_cl_SetTextureForSurface__SWIG_11(L);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VisBaseEntity_cl, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = SWIG_lua_isnilstring(L,argv[1]);
      }
      if (_v) {
        {
          _v = SWIG_lua_isnilstring(L,argv[2]);
        }
        if (_v) {
          return _wrap_VisBaseEntity_cl_SetTextureForSurface__SWIG_9(L);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VisBaseEntity_cl, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_VTextureObject, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          void *ptr;
          if (SWIG_isptrtype(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_VisSurface_cl, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_VisBaseEntity_cl_SetTextureForSurface__SWIG_0(L);
          }
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VisBaseEntity_cl, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_VTextureObject, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_VisBaseEntity_cl_SetTextureForSurface__SWIG_4(L);
          }
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VisBaseEntity_cl, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_VTextureObject, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          _v = SWIG_lua_isnilstring(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_VisBaseEntity_cl_SetTextureForSurface__SWIG_2(L);
          }
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VisBaseEntity_cl, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = SWIG_lua_isnilstring(L,argv[1]);
      }
      if (_v) {
        {
          void *ptr;
          if (SWIG_isptrtype(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_VisSurface_cl, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_VisBaseEntity_cl_SetTextureForSurface__SWIG_6(L);
          }
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VisBaseEntity_cl, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = SWIG_lua_isnilstring(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_VisBaseEntity_cl_SetTextureForSurface__SWIG_10(L);
          }
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VisBaseEntity_cl, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = SWIG_lua_isnilstring(L,argv[1]);
      }
      if (_v) {
        {
          _v = SWIG_lua_isnilstring(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_VisBaseEntity_cl_SetTextureForSurface__SWIG_8(L);
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'VisBaseEntity_cl_SetTextureForSurface'\n"
    "  Possible C/C++ prototypes are:\n"
    "    SetTextureForSurface(VisBaseEntity_cl *,VTextureObject *,VisSurface_cl *,int)\n"
    "    SetTextureForSurface(VisBaseEntity_cl *,VTextureObject *,VisSurface_cl *)\n"
    "    SetTextureForSurface(VisBaseEntity_cl *,VTextureObject *,char const *,int)\n"
    "    SetTextureForSurface(VisBaseEntity_cl *,VTextureObject *,char const *)\n"
    "    SetTextureForSurface(VisBaseEntity_cl *,VTextureObject *,int,int)\n"
    "    SetTextureForSurface(VisBaseEntity_cl *,VTextureObject *,int)\n"
    "    SetTextureForSurface(VisBaseEntity_cl *,char const *,VisSurface_cl *,int)\n"
    "    SetTextureForSurface(VisBaseEntity_cl *,char const *,VisSurface_cl *)\n"
    "    SetTextureForSurface(VisBaseEntity_cl *,char const *,char const *,int)\n"
    "    SetTextureForSurface(VisBaseEntity_cl *,char const *,char const *)\n"
    "    SetTextureForSurface(VisBaseEntity_cl *,char const *,int,int)\n"
    "    SetTextureForSurface(VisBaseEntity_cl *,char const *,int)\n");
  lua_error(L);return 0;
}


static int _wrap_VisBaseEntity_cl_ClearShaderSet(lua_State* L) {
  int SWIG_arg = 0;
  VisBaseEntity_cl *arg1 = (VisBaseEntity_cl *) 0 ;
  
  SWIG_check_num_args("ClearShaderSet",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ClearShaderSet",1,"VisBaseEntity_cl *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisBaseEntity_cl,0))){
    SWIG_fail_ptr("VisBaseEntity_cl_ClearShaderSet",1,SWIGTYPE_p_VisBaseEntity_cl);
  }
  
  VisBaseEntity_cl_ClearShaderSet(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisBaseEntity_cl_SetPrimarySortingKey(lua_State* L) {
  int SWIG_arg = 0;
  VisBaseEntity_cl *arg1 = (VisBaseEntity_cl *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("SetPrimarySortingKey",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetPrimarySortingKey",1,"VisBaseEntity_cl *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SetPrimarySortingKey",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisBaseEntity_cl,0))){
    SWIG_fail_ptr("VisBaseEntity_cl_SetPrimarySortingKey",1,SWIGTYPE_p_VisBaseEntity_cl);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  VisBaseEntity_cl_SetPrimarySortingKey(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisBaseEntity_cl_GetPrimarySortingKey(lua_State* L) {
  int SWIG_arg = 0;
  VisBaseEntity_cl *arg1 = (VisBaseEntity_cl *) 0 ;
  int result;
  
  SWIG_check_num_args("GetPrimarySortingKey",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetPrimarySortingKey",1,"VisBaseEntity_cl *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisBaseEntity_cl,0))){
    SWIG_fail_ptr("VisBaseEntity_cl_GetPrimarySortingKey",1,SWIGTYPE_p_VisBaseEntity_cl);
  }
  
  result = (int)VisBaseEntity_cl_GetPrimarySortingKey(arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisBaseEntity_cl_SetFarClipDistance(lua_State* L) {
  int SWIG_arg = 0;
  VisBaseEntity_cl *arg1 = (VisBaseEntity_cl *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("SetFarClipDistance",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetFarClipDistance",1,"VisBaseEntity_cl *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SetFarClipDistance",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisBaseEntity_cl,0))){
    SWIG_fail_ptr("VisBaseEntity_cl_SetFarClipDistance",1,SWIGTYPE_p_VisBaseEntity_cl);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->SetFarClipDistance(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisBaseEntity_cl_GetFarClipDistance(lua_State* L) {
  int SWIG_arg = 0;
  VisBaseEntity_cl *arg1 = (VisBaseEntity_cl *) 0 ;
  float result;
  
  SWIG_check_num_args("GetFarClipDistance",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetFarClipDistance",1,"VisBaseEntity_cl const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisBaseEntity_cl,0))){
    SWIG_fail_ptr("VisBaseEntity_cl_GetFarClipDistance",1,SWIGTYPE_p_VisBaseEntity_cl);
  }
  
  result = (float)((VisBaseEntity_cl const *)arg1)->GetFarClipDistance();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static swig_lua_method swig_VisBaseEntity_cl_methods[] = {
    { "__tostring",VisBaseEntity_cl_ToString},
    { "__concat",VisBaseEntity_cl_Concat},
    {"Remove", _wrap_VisBaseEntity_cl_Remove}, 
    {"InitFunction", _wrap_VisBaseEntity_cl_InitFunction}, 
    {"DeInitFunction", _wrap_VisBaseEntity_cl_DeInitFunction}, 
    {"GetMesh", _wrap_VisBaseEntity_cl_GetMesh}, 
    {"SetMesh", _wrap_VisBaseEntity_cl_SetMesh}, 
    {"SetThinkFunctionStatus", _wrap_VisBaseEntity_cl_SetThinkFunctionStatus}, 
    {"GetThinkFunctionStatus", _wrap_VisBaseEntity_cl_GetThinkFunctionStatus}, 
    {"HasMesh", _wrap_VisBaseEntity_cl_HasMesh}, 
    {"SetCastShadows", _wrap_VisBaseEntity_cl_SetCastShadows}, 
    {"GetCastShadows", _wrap_VisBaseEntity_cl_GetCastShadows}, 
    {"SetScaling", _wrap_VisBaseEntity_cl_SetScaling}, 
    {"GetScaling", _wrap_VisBaseEntity_cl_GetScaling}, 
    {"SetAlwaysInForeGround", _wrap_VisBaseEntity_cl_SetAlwaysInForeGround}, 
    {"IsObjectAlwaysInForegroundEnabled", _wrap_VisBaseEntity_cl_IsObjectAlwaysInForegroundEnabled}, 
    {"SetCastStaticShadows", _wrap_VisBaseEntity_cl_SetCastStaticShadows}, 
    {"GetCastStaticShadows", _wrap_VisBaseEntity_cl_GetCastStaticShadows}, 
    {"SetCustomTraceBBox", _wrap_VisBaseEntity_cl_SetCustomTraceBBox}, 
    {"GetCustomTraceBBox", _wrap_VisBaseEntity_cl_GetCustomTraceBBox}, 
    {"SetTraceAccuracy", _wrap_VisBaseEntity_cl_SetTraceAccuracy}, 
    {"WasVisibleInLastFrame", _wrap_VisBaseEntity_cl_WasVisibleInLastFrame}, 
    {"WasVisibleInAnyLastFrame", _wrap_VisBaseEntity_cl_WasVisibleInAnyLastFrame}, 
    {"GetBoundingBox", _wrap_VisBaseEntity_cl_GetBoundingBox}, 
    {"GetCollisionBoundingBox", _wrap_VisBaseEntity_cl_GetCollisionBoundingBox}, 
    {"SetVisible", _wrap_VisBaseEntity_cl_SetVisible}, 
    {"IsVisible", _wrap_VisBaseEntity_cl_IsVisible}, 
    {"SetVisibleBitmask", _wrap_VisBaseEntity_cl_SetVisibleBitmask}, 
    {"GetVisibleBitmask", _wrap_VisBaseEntity_cl_GetVisibleBitmask}, 
    {"SetLightInfluenceBitmask", _wrap_VisBaseEntity_cl_SetLightInfluenceBitmask}, 
    {"GetLightInfluenceBitmask", _wrap_VisBaseEntity_cl_GetLightInfluenceBitmask}, 
    {"SetTechnique", _wrap_VisBaseEntity_cl_SetTechnique}, 
    {"AddTechnique", _wrap_VisBaseEntity_cl_AddTechnique}, 
    {"SetEffect", _wrap_VisBaseEntity_cl_SetEffect}, 
    {"AddEffect", _wrap_VisBaseEntity_cl_AddEffect}, 
    {"SetTextureForSurface", _wrap_VisBaseEntity_cl_SetTextureForSurface}, 
    {"ClearShaderSet", _wrap_VisBaseEntity_cl_ClearShaderSet}, 
    {"SetPrimarySortingKey", _wrap_VisBaseEntity_cl_SetPrimarySortingKey}, 
    {"GetPrimarySortingKey", _wrap_VisBaseEntity_cl_GetPrimarySortingKey}, 
    {"SetFarClipDistance", _wrap_VisBaseEntity_cl_SetFarClipDistance}, 
    {"GetFarClipDistance", _wrap_VisBaseEntity_cl_GetFarClipDistance}, 
    {0,0}
};
static swig_lua_attribute swig_VisBaseEntity_cl_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_VisBaseEntity_cl_bases[] = {0,0};
static const char *swig_VisBaseEntity_cl_base_names[] = {"VisObject3D_cl *",0};
static swig_lua_class _wrap_class_VisBaseEntity_cl = { "VisBaseEntity_cl", &SWIGTYPE_p_VisBaseEntity_cl,0,0, swig_VisBaseEntity_cl_methods, swig_VisBaseEntity_cl_attributes, swig_VisBaseEntity_cl_bases, swig_VisBaseEntity_cl_base_names };

static int _wrap_VisParticleEffect_cl_Remove(lua_State* L) {
  int SWIG_arg = 0;
  VisParticleEffect_cl *arg1 = (VisParticleEffect_cl *) 0 ;
  
  SWIG_check_num_args("Dispose",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Dispose",1,"VisParticleEffect_cl *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisParticleEffect_cl,0))){
    SWIG_fail_ptr("VisParticleEffect_cl_Remove",1,SWIGTYPE_p_VisParticleEffect_cl);
  }
  
  (arg1)->Dispose();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisParticleEffect_cl_SetVisibleBitmask(lua_State* L) {
  int SWIG_arg = 0;
  VisParticleEffect_cl *arg1 = (VisParticleEffect_cl *) 0 ;
  VBitmask *arg2 = (VBitmask *) 0 ;
  
  SWIG_check_num_args("SetVisibleBitmask",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetVisibleBitmask",1,"VisParticleEffect_cl *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SetVisibleBitmask",2,"VBitmask *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisParticleEffect_cl,0))){
    SWIG_fail_ptr("VisParticleEffect_cl_SetVisibleBitmask",1,SWIGTYPE_p_VisParticleEffect_cl);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_VBitmask,0))){
    SWIG_fail_ptr("VisParticleEffect_cl_SetVisibleBitmask",2,SWIGTYPE_p_VBitmask);
  }
  
  VisParticleEffect_cl_SetVisibleBitmask(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisParticleEffect_cl_GetName(lua_State* L) {
  int SWIG_arg = 0;
  VisParticleEffect_cl *arg1 = (VisParticleEffect_cl *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("GetName",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetName",1,"VisParticleEffect_cl *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisParticleEffect_cl,0))){
    SWIG_fail_ptr("VisParticleEffect_cl_GetName",1,SWIGTYPE_p_VisParticleEffect_cl);
  }
  
  result = (char *)VisParticleEffect_cl_GetName(arg1);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisParticleEffect_cl_IncPosition__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  VisParticleEffect_cl *arg1 = (VisParticleEffect_cl *) 0 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  bool arg5 ;
  
  SWIG_check_num_args("IncPosition",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("IncPosition",1,"VisParticleEffect_cl *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("IncPosition",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("IncPosition",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("IncPosition",4,"float");
  if(!lua_isboolean(L,5)) SWIG_fail_arg("IncPosition",5,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisParticleEffect_cl,0))){
    SWIG_fail_ptr("VisParticleEffect_cl_IncPosition",1,SWIGTYPE_p_VisParticleEffect_cl);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4);
  arg5 = (lua_toboolean(L, 5)!=0);
  VisParticleEffect_cl_IncPosition__SWIG_0(arg1,arg2,arg3,arg4,arg5);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisParticleEffect_cl_IncPosition__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  VisParticleEffect_cl *arg1 = (VisParticleEffect_cl *) 0 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  
  SWIG_check_num_args("IncPosition",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("IncPosition",1,"VisParticleEffect_cl *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("IncPosition",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("IncPosition",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("IncPosition",4,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisParticleEffect_cl,0))){
    SWIG_fail_ptr("VisParticleEffect_cl_IncPosition",1,SWIGTYPE_p_VisParticleEffect_cl);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4);
  VisParticleEffect_cl_IncPosition__SWIG_0(arg1,arg2,arg3,arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisParticleEffect_cl_ContinueSimulationWhenInvisible(lua_State* L) {
  int SWIG_arg = 0;
  VisParticleEffect_cl *arg1 = (VisParticleEffect_cl *) 0 ;
  bool arg2 ;
  
  SWIG_check_num_args("ContinueSimulationWhenInvisible",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ContinueSimulationWhenInvisible",1,"VisParticleEffect_cl *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("ContinueSimulationWhenInvisible",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisParticleEffect_cl,0))){
    SWIG_fail_ptr("VisParticleEffect_cl_ContinueSimulationWhenInvisible",1,SWIGTYPE_p_VisParticleEffect_cl);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  VisParticleEffect_cl_ContinueSimulationWhenInvisible(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisParticleEffect_cl_GetLocalBoundingBox(lua_State* L) {
  int SWIG_arg = 0;
  VisParticleEffect_cl *arg1 = (VisParticleEffect_cl *) 0 ;
  SwigValueWrapper< hkvAlignedBBox > result;
  
  SWIG_check_num_args("GetLocalBoundingBox",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetLocalBoundingBox",1,"VisParticleEffect_cl *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisParticleEffect_cl,0))){
    SWIG_fail_ptr("VisParticleEffect_cl_GetLocalBoundingBox",1,SWIGTYPE_p_VisParticleEffect_cl);
  }
  
  result = VisParticleEffect_cl_GetLocalBoundingBox(arg1);
  {
    hkvAlignedBBox * resultptr = new hkvAlignedBBox((const hkvAlignedBBox &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_hkvAlignedBBox,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisParticleEffect_cl_SetVisible(lua_State* L) {
  int SWIG_arg = 0;
  VisParticleEffect_cl *arg1 = (VisParticleEffect_cl *) 0 ;
  bool arg2 ;
  
  SWIG_check_num_args("SetVisible",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetVisible",1,"VisParticleEffect_cl *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("SetVisible",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisParticleEffect_cl,0))){
    SWIG_fail_ptr("VisParticleEffect_cl_SetVisible",1,SWIGTYPE_p_VisParticleEffect_cl);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  (arg1)->SetVisible(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisParticleEffect_cl_IsVisible(lua_State* L) {
  int SWIG_arg = 0;
  VisParticleEffect_cl *arg1 = (VisParticleEffect_cl *) 0 ;
  bool result;
  
  SWIG_check_num_args("IsVisible",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("IsVisible",1,"VisParticleEffect_cl const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisParticleEffect_cl,0))){
    SWIG_fail_ptr("VisParticleEffect_cl_IsVisible",1,SWIGTYPE_p_VisParticleEffect_cl);
  }
  
  result = (bool)((VisParticleEffect_cl const *)arg1)->IsVisible();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisParticleEffect_cl_IncPosition__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  VisParticleEffect_cl *arg1 = (VisParticleEffect_cl *) 0 ;
  hkvVec3 *arg2 = 0 ;
  bool arg3 ;
  
  SWIG_check_num_args("IncPosition",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("IncPosition",1,"VisParticleEffect_cl *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("IncPosition",2,"hkvVec3 const &");
  if(!lua_isboolean(L,3)) SWIG_fail_arg("IncPosition",3,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisParticleEffect_cl,0))){
    SWIG_fail_ptr("VisParticleEffect_cl_IncPosition",1,SWIGTYPE_p_VisParticleEffect_cl);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("VisParticleEffect_cl_IncPosition",2,SWIGTYPE_p_hkvVec3);
  }
  
  arg3 = (lua_toboolean(L, 3)!=0);
  (arg1)->IncPosition((hkvVec3 const &)*arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisParticleEffect_cl_IncPosition__SWIG_3(lua_State* L) {
  int SWIG_arg = 0;
  VisParticleEffect_cl *arg1 = (VisParticleEffect_cl *) 0 ;
  hkvVec3 *arg2 = 0 ;
  
  SWIG_check_num_args("IncPosition",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("IncPosition",1,"VisParticleEffect_cl *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("IncPosition",2,"hkvVec3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisParticleEffect_cl,0))){
    SWIG_fail_ptr("VisParticleEffect_cl_IncPosition",1,SWIGTYPE_p_VisParticleEffect_cl);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("VisParticleEffect_cl_IncPosition",2,SWIGTYPE_p_hkvVec3);
  }
  
  (arg1)->IncPosition((hkvVec3 const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisParticleEffect_cl_IncPosition(lua_State* L) {
  int argc;
  int argv[6]={
    1,2,3,4,5,6
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VisParticleEffect_cl, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_hkvVec3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_VisParticleEffect_cl_IncPosition__SWIG_3(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VisParticleEffect_cl, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_hkvVec3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          _v = lua_isboolean(L,argv[2]);
        }
        if (_v) {
          return _wrap_VisParticleEffect_cl_IncPosition__SWIG_2(L);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VisParticleEffect_cl, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_VisParticleEffect_cl_IncPosition__SWIG_1(L);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VisParticleEffect_cl, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isboolean(L,argv[4]);
            }
            if (_v) {
              return _wrap_VisParticleEffect_cl_IncPosition__SWIG_0(L);
            }
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'VisParticleEffect_cl_IncPosition'\n"
    "  Possible C/C++ prototypes are:\n"
    "    IncPosition(VisParticleEffect_cl *,float,float,float,bool)\n"
    "    IncPosition(VisParticleEffect_cl *,float,float,float)\n"
    "    IncPosition(VisParticleEffect_cl *,hkvVec3 const &,bool)\n"
    "    IncPosition(VisParticleEffect_cl *,hkvVec3 const &)\n");
  lua_error(L);return 0;
}


static int _wrap_VisParticleEffect_cl_SetScaling(lua_State* L) {
  int SWIG_arg = 0;
  VisParticleEffect_cl *arg1 = (VisParticleEffect_cl *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("SetScaling",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetScaling",1,"VisParticleEffect_cl *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SetScaling",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisParticleEffect_cl,0))){
    SWIG_fail_ptr("VisParticleEffect_cl_SetScaling",1,SWIGTYPE_p_VisParticleEffect_cl);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->SetScaling(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisParticleEffect_cl_SetPaused(lua_State* L) {
  int SWIG_arg = 0;
  VisParticleEffect_cl *arg1 = (VisParticleEffect_cl *) 0 ;
  bool arg2 ;
  
  SWIG_check_num_args("SetPause",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetPause",1,"VisParticleEffect_cl *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("SetPause",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisParticleEffect_cl,0))){
    SWIG_fail_ptr("VisParticleEffect_cl_SetPaused",1,SWIGTYPE_p_VisParticleEffect_cl);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  (arg1)->SetPause(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisParticleEffect_cl_IsPaused(lua_State* L) {
  int SWIG_arg = 0;
  VisParticleEffect_cl *arg1 = (VisParticleEffect_cl *) 0 ;
  bool result;
  
  SWIG_check_num_args("IsPaused",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("IsPaused",1,"VisParticleEffect_cl const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisParticleEffect_cl,0))){
    SWIG_fail_ptr("VisParticleEffect_cl_IsPaused",1,SWIGTYPE_p_VisParticleEffect_cl);
  }
  
  result = (bool)((VisParticleEffect_cl const *)arg1)->IsPaused();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisParticleEffect_cl_SetHalted(lua_State* L) {
  int SWIG_arg = 0;
  VisParticleEffect_cl *arg1 = (VisParticleEffect_cl *) 0 ;
  bool arg2 ;
  
  SWIG_check_num_args("SetHalted",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetHalted",1,"VisParticleEffect_cl *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("SetHalted",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisParticleEffect_cl,0))){
    SWIG_fail_ptr("VisParticleEffect_cl_SetHalted",1,SWIGTYPE_p_VisParticleEffect_cl);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  (arg1)->SetHalted(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisParticleEffect_cl_IsHalted(lua_State* L) {
  int SWIG_arg = 0;
  VisParticleEffect_cl *arg1 = (VisParticleEffect_cl *) 0 ;
  bool result;
  
  SWIG_check_num_args("IsHalted",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("IsHalted",1,"VisParticleEffect_cl const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisParticleEffect_cl,0))){
    SWIG_fail_ptr("VisParticleEffect_cl_IsHalted",1,SWIGTYPE_p_VisParticleEffect_cl);
  }
  
  result = (bool)((VisParticleEffect_cl const *)arg1)->IsHalted();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisParticleEffect_cl_GetRemainingLifeTime(lua_State* L) {
  int SWIG_arg = 0;
  VisParticleEffect_cl *arg1 = (VisParticleEffect_cl *) 0 ;
  float result;
  
  SWIG_check_num_args("GetRemainingLifeTime",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetRemainingLifeTime",1,"VisParticleEffect_cl *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisParticleEffect_cl,0))){
    SWIG_fail_ptr("VisParticleEffect_cl_GetRemainingLifeTime",1,SWIGTYPE_p_VisParticleEffect_cl);
  }
  
  result = (float)(arg1)->GetRemainingLifeTime();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisParticleEffect_cl_IsLifeTimeOver(lua_State* L) {
  int SWIG_arg = 0;
  VisParticleEffect_cl *arg1 = (VisParticleEffect_cl *) 0 ;
  bool result;
  
  SWIG_check_num_args("IsLifeTimeOver",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("IsLifeTimeOver",1,"VisParticleEffect_cl *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisParticleEffect_cl,0))){
    SWIG_fail_ptr("VisParticleEffect_cl_IsLifeTimeOver",1,SWIGTYPE_p_VisParticleEffect_cl);
  }
  
  result = (bool)(arg1)->IsLifeTimeOver();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisParticleEffect_cl_IsDead(lua_State* L) {
  int SWIG_arg = 0;
  VisParticleEffect_cl *arg1 = (VisParticleEffect_cl *) 0 ;
  bool result;
  
  SWIG_check_num_args("IsDead",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("IsDead",1,"VisParticleEffect_cl *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisParticleEffect_cl,0))){
    SWIG_fail_ptr("VisParticleEffect_cl_IsDead",1,SWIGTYPE_p_VisParticleEffect_cl);
  }
  
  result = (bool)(arg1)->IsDead();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisParticleEffect_cl_SetFinished(lua_State* L) {
  int SWIG_arg = 0;
  VisParticleEffect_cl *arg1 = (VisParticleEffect_cl *) 0 ;
  
  SWIG_check_num_args("SetFinished",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetFinished",1,"VisParticleEffect_cl *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisParticleEffect_cl,0))){
    SWIG_fail_ptr("VisParticleEffect_cl_SetFinished",1,SWIGTYPE_p_VisParticleEffect_cl);
  }
  
  (arg1)->SetFinished();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisParticleEffect_cl_SetApplyTimeOfDayLight(lua_State* L) {
  int SWIG_arg = 0;
  VisParticleEffect_cl *arg1 = (VisParticleEffect_cl *) 0 ;
  bool arg2 ;
  
  SWIG_check_num_args("SetApplyTimeOfDayLight",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetApplyTimeOfDayLight",1,"VisParticleEffect_cl *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("SetApplyTimeOfDayLight",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisParticleEffect_cl,0))){
    SWIG_fail_ptr("VisParticleEffect_cl_SetApplyTimeOfDayLight",1,SWIGTYPE_p_VisParticleEffect_cl);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  (arg1)->SetApplyTimeOfDayLight(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisParticleEffect_cl_GetApplyTimeOfDayLight(lua_State* L) {
  int SWIG_arg = 0;
  VisParticleEffect_cl *arg1 = (VisParticleEffect_cl *) 0 ;
  bool result;
  
  SWIG_check_num_args("GetApplyTimeOfDayLight",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetApplyTimeOfDayLight",1,"VisParticleEffect_cl const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisParticleEffect_cl,0))){
    SWIG_fail_ptr("VisParticleEffect_cl_GetApplyTimeOfDayLight",1,SWIGTYPE_p_VisParticleEffect_cl);
  }
  
  result = (bool)((VisParticleEffect_cl const *)arg1)->GetApplyTimeOfDayLight();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisParticleEffect_cl_Restart(lua_State* L) {
  int SWIG_arg = 0;
  VisParticleEffect_cl *arg1 = (VisParticleEffect_cl *) 0 ;
  
  SWIG_check_num_args("Restart",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Restart",1,"VisParticleEffect_cl *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisParticleEffect_cl,0))){
    SWIG_fail_ptr("VisParticleEffect_cl_Restart",1,SWIGTYPE_p_VisParticleEffect_cl);
  }
  
  (arg1)->Restart();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisParticleEffect_cl_SetRemoveWhenFinished(lua_State* L) {
  int SWIG_arg = 0;
  VisParticleEffect_cl *arg1 = (VisParticleEffect_cl *) 0 ;
  bool arg2 ;
  
  SWIG_check_num_args("SetRemoveWhenFinished",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetRemoveWhenFinished",1,"VisParticleEffect_cl *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("SetRemoveWhenFinished",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisParticleEffect_cl,0))){
    SWIG_fail_ptr("VisParticleEffect_cl_SetRemoveWhenFinished",1,SWIGTYPE_p_VisParticleEffect_cl);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  (arg1)->SetRemoveWhenFinished(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisParticleEffect_cl_SetIntensity(lua_State* L) {
  int SWIG_arg = 0;
  VisParticleEffect_cl *arg1 = (VisParticleEffect_cl *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("SetIntensity",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetIntensity",1,"VisParticleEffect_cl *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SetIntensity",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisParticleEffect_cl,0))){
    SWIG_fail_ptr("VisParticleEffect_cl_SetIntensity",1,SWIGTYPE_p_VisParticleEffect_cl);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->SetIntensity(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisParticleEffect_cl_RemoveAllConstraints(lua_State* L) {
  int SWIG_arg = 0;
  VisParticleEffect_cl *arg1 = (VisParticleEffect_cl *) 0 ;
  
  SWIG_check_num_args("RemoveAllConstraints",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("RemoveAllConstraints",1,"VisParticleEffect_cl *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisParticleEffect_cl,0))){
    SWIG_fail_ptr("VisParticleEffect_cl_RemoveAllConstraints",1,SWIGTYPE_p_VisParticleEffect_cl);
  }
  
  (arg1)->RemoveAllConstraints();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisParticleEffect_cl_SetWindSpeed__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  VisParticleEffect_cl *arg1 = (VisParticleEffect_cl *) 0 ;
  hkvVec3 *arg2 = 0 ;
  bool arg3 ;
  
  SWIG_check_num_args("SetWindSpeed",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetWindSpeed",1,"VisParticleEffect_cl *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("SetWindSpeed",2,"hkvVec3 const &");
  if(!lua_isboolean(L,3)) SWIG_fail_arg("SetWindSpeed",3,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisParticleEffect_cl,0))){
    SWIG_fail_ptr("VisParticleEffect_cl_SetWindSpeed",1,SWIGTYPE_p_VisParticleEffect_cl);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("VisParticleEffect_cl_SetWindSpeed",2,SWIGTYPE_p_hkvVec3);
  }
  
  arg3 = (lua_toboolean(L, 3)!=0);
  (arg1)->SetWindSpeed((hkvVec3 const &)*arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisParticleEffect_cl_SetWindSpeed__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  VisParticleEffect_cl *arg1 = (VisParticleEffect_cl *) 0 ;
  hkvVec3 *arg2 = 0 ;
  
  SWIG_check_num_args("SetWindSpeed",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetWindSpeed",1,"VisParticleEffect_cl *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("SetWindSpeed",2,"hkvVec3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisParticleEffect_cl,0))){
    SWIG_fail_ptr("VisParticleEffect_cl_SetWindSpeed",1,SWIGTYPE_p_VisParticleEffect_cl);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("VisParticleEffect_cl_SetWindSpeed",2,SWIGTYPE_p_hkvVec3);
  }
  
  (arg1)->SetWindSpeed((hkvVec3 const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisParticleEffect_cl_SetWindSpeed(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VisParticleEffect_cl, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_hkvVec3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_VisParticleEffect_cl_SetWindSpeed__SWIG_1(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VisParticleEffect_cl, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_hkvVec3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          _v = lua_isboolean(L,argv[2]);
        }
        if (_v) {
          return _wrap_VisParticleEffect_cl_SetWindSpeed__SWIG_0(L);
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'VisParticleEffect_cl_SetWindSpeed'\n"
    "  Possible C/C++ prototypes are:\n"
    "    SetWindSpeed(VisParticleEffect_cl *,hkvVec3 const &,bool)\n"
    "    SetWindSpeed(VisParticleEffect_cl *,hkvVec3 const &)\n");
  lua_error(L);return 0;
}


static int _wrap_VisParticleEffect_cl_SetMeshEmitterEntity(lua_State* L) {
  int SWIG_arg = 0;
  VisParticleEffect_cl *arg1 = (VisParticleEffect_cl *) 0 ;
  VisBaseEntity_cl *arg2 = (VisBaseEntity_cl *) 0 ;
  
  SWIG_check_num_args("SetMeshEmitterEntity",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetMeshEmitterEntity",1,"VisParticleEffect_cl *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SetMeshEmitterEntity",2,"VisBaseEntity_cl *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisParticleEffect_cl,0))){
    SWIG_fail_ptr("VisParticleEffect_cl_SetMeshEmitterEntity",1,SWIGTYPE_p_VisParticleEffect_cl);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_VisBaseEntity_cl,0))){
    SWIG_fail_ptr("VisParticleEffect_cl_SetMeshEmitterEntity",2,SWIGTYPE_p_VisBaseEntity_cl);
  }
  
  (arg1)->SetMeshEmitterEntity(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static swig_lua_method swig_VisParticleEffect_cl_methods[] = {
    { "__tostring",VisParticleEffect_cl_ToString},
    { "__concat",VisParticleEffect_cl_Concat},
    {"Remove", _wrap_VisParticleEffect_cl_Remove}, 
    {"SetVisibleBitmask", _wrap_VisParticleEffect_cl_SetVisibleBitmask}, 
    {"GetName", _wrap_VisParticleEffect_cl_GetName}, 
    {"ContinueSimulationWhenInvisible", _wrap_VisParticleEffect_cl_ContinueSimulationWhenInvisible}, 
    {"GetLocalBoundingBox", _wrap_VisParticleEffect_cl_GetLocalBoundingBox}, 
    {"SetVisible", _wrap_VisParticleEffect_cl_SetVisible}, 
    {"IsVisible", _wrap_VisParticleEffect_cl_IsVisible}, 
    {"IncPosition", _wrap_VisParticleEffect_cl_IncPosition}, 
    {"SetScaling", _wrap_VisParticleEffect_cl_SetScaling}, 
    {"SetPaused", _wrap_VisParticleEffect_cl_SetPaused}, 
    {"IsPaused", _wrap_VisParticleEffect_cl_IsPaused}, 
    {"SetHalted", _wrap_VisParticleEffect_cl_SetHalted}, 
    {"IsHalted", _wrap_VisParticleEffect_cl_IsHalted}, 
    {"GetRemainingLifeTime", _wrap_VisParticleEffect_cl_GetRemainingLifeTime}, 
    {"IsLifeTimeOver", _wrap_VisParticleEffect_cl_IsLifeTimeOver}, 
    {"IsDead", _wrap_VisParticleEffect_cl_IsDead}, 
    {"SetFinished", _wrap_VisParticleEffect_cl_SetFinished}, 
    {"SetApplyTimeOfDayLight", _wrap_VisParticleEffect_cl_SetApplyTimeOfDayLight}, 
    {"GetApplyTimeOfDayLight", _wrap_VisParticleEffect_cl_GetApplyTimeOfDayLight}, 
    {"Restart", _wrap_VisParticleEffect_cl_Restart}, 
    {"SetRemoveWhenFinished", _wrap_VisParticleEffect_cl_SetRemoveWhenFinished}, 
    {"SetIntensity", _wrap_VisParticleEffect_cl_SetIntensity}, 
    {"RemoveAllConstraints", _wrap_VisParticleEffect_cl_RemoveAllConstraints}, 
    {"SetWindSpeed", _wrap_VisParticleEffect_cl_SetWindSpeed}, 
    {"SetMeshEmitterEntity", _wrap_VisParticleEffect_cl_SetMeshEmitterEntity}, 
    {0,0}
};
static swig_lua_attribute swig_VisParticleEffect_cl_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_VisParticleEffect_cl_bases[] = {0,0};
static const char *swig_VisParticleEffect_cl_base_names[] = {"VisObject3D_cl *",0};
static swig_lua_class _wrap_class_VisParticleEffect_cl = { "VisParticleEffect_cl", &SWIGTYPE_p_VisParticleEffect_cl,0,0, swig_VisParticleEffect_cl_methods, swig_VisParticleEffect_cl_attributes, swig_VisParticleEffect_cl_bases, swig_VisParticleEffect_cl_base_names };

static int _wrap_VDynamicMesh_GetSubmeshCount(lua_State* L) {
  int SWIG_arg = 0;
  VDynamicMesh *arg1 = (VDynamicMesh *) 0 ;
  int result;
  
  SWIG_check_num_args("GetSubmeshCount",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetSubmeshCount",1,"VDynamicMesh const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VDynamicMesh,0))){
    SWIG_fail_ptr("VDynamicMesh_GetSubmeshCount",1,SWIGTYPE_p_VDynamicMesh);
  }
  
  result = (int)((VDynamicMesh const *)arg1)->GetSubmeshCount();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VDynamicMesh_GetSurfaceCount(lua_State* L) {
  int SWIG_arg = 0;
  VDynamicMesh *arg1 = (VDynamicMesh *) 0 ;
  int result;
  
  SWIG_check_num_args("GetSurfaceCount",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetSurfaceCount",1,"VDynamicMesh const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VDynamicMesh,0))){
    SWIG_fail_ptr("VDynamicMesh_GetSurfaceCount",1,SWIGTYPE_p_VDynamicMesh);
  }
  
  result = (int)((VDynamicMesh const *)arg1)->GetSurfaceCount();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VDynamicMesh_GetBoundingBox(lua_State* L) {
  int SWIG_arg = 0;
  VDynamicMesh *arg1 = (VDynamicMesh *) 0 ;
  SwigValueWrapper< hkvAlignedBBox > result;
  
  SWIG_check_num_args("GetBoundingBox",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetBoundingBox",1,"VDynamicMesh const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VDynamicMesh,0))){
    SWIG_fail_ptr("VDynamicMesh_GetBoundingBox",1,SWIGTYPE_p_VDynamicMesh);
  }
  
  result = VDynamicMesh_GetBoundingBox((VDynamicMesh const *)arg1);
  {
    hkvAlignedBBox * resultptr = new hkvAlignedBBox((const hkvAlignedBBox &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_hkvAlignedBBox,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VDynamicMesh_ReloadShaderAssignment(lua_State* L) {
  int SWIG_arg = 0;
  VDynamicMesh *arg1 = (VDynamicMesh *) 0 ;
  char *arg2 = (char *) 0 ;
  bool result;
  
  SWIG_check_num_args("ReloadShaderAssignment",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ReloadShaderAssignment",1,"VDynamicMesh *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("ReloadShaderAssignment",2,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VDynamicMesh,0))){
    SWIG_fail_ptr("VDynamicMesh_ReloadShaderAssignment",1,SWIGTYPE_p_VDynamicMesh);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  result = (bool)VDynamicMesh_ReloadShaderAssignment(arg1,(char const *)arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VDynamicMesh_SetTechnique__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  VDynamicMesh *arg1 = (VDynamicMesh *) 0 ;
  VisSurface_cl *arg2 = (VisSurface_cl *) 0 ;
  char *arg3 = (char *) 0 ;
  char *arg4 = (char *) 0 ;
  char *arg5 = (char *) 0 ;
  bool result;
  
  SWIG_check_num_args("SetTechnique",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetTechnique",1,"VDynamicMesh *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SetTechnique",2,"VisSurface_cl *");
  if(!SWIG_lua_isnilstring(L,3)) SWIG_fail_arg("SetTechnique",3,"char const *");
  if(!SWIG_lua_isnilstring(L,4)) SWIG_fail_arg("SetTechnique",4,"char const *");
  if(!SWIG_lua_isnilstring(L,5)) SWIG_fail_arg("SetTechnique",5,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VDynamicMesh,0))){
    SWIG_fail_ptr("VDynamicMesh_SetTechnique",1,SWIGTYPE_p_VDynamicMesh);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_VisSurface_cl,0))){
    SWIG_fail_ptr("VDynamicMesh_SetTechnique",2,SWIGTYPE_p_VisSurface_cl);
  }
  
  arg3 = (char *)lua_tostring(L, 3);
  arg4 = (char *)lua_tostring(L, 4);
  arg5 = (char *)lua_tostring(L, 5);
  result = (bool)VDynamicMesh_SetTechnique__SWIG_0(arg1,arg2,(char const *)arg3,(char const *)arg4,(char const *)arg5);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VDynamicMesh_SetTechnique__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  VDynamicMesh *arg1 = (VDynamicMesh *) 0 ;
  VisSurface_cl *arg2 = (VisSurface_cl *) 0 ;
  char *arg3 = (char *) 0 ;
  char *arg4 = (char *) 0 ;
  bool result;
  
  SWIG_check_num_args("SetTechnique",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetTechnique",1,"VDynamicMesh *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SetTechnique",2,"VisSurface_cl *");
  if(!SWIG_lua_isnilstring(L,3)) SWIG_fail_arg("SetTechnique",3,"char const *");
  if(!SWIG_lua_isnilstring(L,4)) SWIG_fail_arg("SetTechnique",4,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VDynamicMesh,0))){
    SWIG_fail_ptr("VDynamicMesh_SetTechnique",1,SWIGTYPE_p_VDynamicMesh);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_VisSurface_cl,0))){
    SWIG_fail_ptr("VDynamicMesh_SetTechnique",2,SWIGTYPE_p_VisSurface_cl);
  }
  
  arg3 = (char *)lua_tostring(L, 3);
  arg4 = (char *)lua_tostring(L, 4);
  result = (bool)VDynamicMesh_SetTechnique__SWIG_0(arg1,arg2,(char const *)arg3,(char const *)arg4);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VDynamicMesh_SetTechnique__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  VDynamicMesh *arg1 = (VDynamicMesh *) 0 ;
  int arg2 ;
  char *arg3 = (char *) 0 ;
  char *arg4 = (char *) 0 ;
  char *arg5 = (char *) 0 ;
  bool result;
  
  SWIG_check_num_args("SetTechnique",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetTechnique",1,"VDynamicMesh *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SetTechnique",2,"int");
  if(!SWIG_lua_isnilstring(L,3)) SWIG_fail_arg("SetTechnique",3,"char const *");
  if(!SWIG_lua_isnilstring(L,4)) SWIG_fail_arg("SetTechnique",4,"char const *");
  if(!SWIG_lua_isnilstring(L,5)) SWIG_fail_arg("SetTechnique",5,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VDynamicMesh,0))){
    SWIG_fail_ptr("VDynamicMesh_SetTechnique",1,SWIGTYPE_p_VDynamicMesh);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (char *)lua_tostring(L, 3);
  arg4 = (char *)lua_tostring(L, 4);
  arg5 = (char *)lua_tostring(L, 5);
  result = (bool)VDynamicMesh_SetTechnique__SWIG_2(arg1,arg2,(char const *)arg3,(char const *)arg4,(char const *)arg5);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VDynamicMesh_SetTechnique__SWIG_3(lua_State* L) {
  int SWIG_arg = 0;
  VDynamicMesh *arg1 = (VDynamicMesh *) 0 ;
  int arg2 ;
  char *arg3 = (char *) 0 ;
  char *arg4 = (char *) 0 ;
  bool result;
  
  SWIG_check_num_args("SetTechnique",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetTechnique",1,"VDynamicMesh *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SetTechnique",2,"int");
  if(!SWIG_lua_isnilstring(L,3)) SWIG_fail_arg("SetTechnique",3,"char const *");
  if(!SWIG_lua_isnilstring(L,4)) SWIG_fail_arg("SetTechnique",4,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VDynamicMesh,0))){
    SWIG_fail_ptr("VDynamicMesh_SetTechnique",1,SWIGTYPE_p_VDynamicMesh);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (char *)lua_tostring(L, 3);
  arg4 = (char *)lua_tostring(L, 4);
  result = (bool)VDynamicMesh_SetTechnique__SWIG_2(arg1,arg2,(char const *)arg3,(char const *)arg4);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VDynamicMesh_SetTechnique__SWIG_4(lua_State* L) {
  int SWIG_arg = 0;
  VDynamicMesh *arg1 = (VDynamicMesh *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  char *arg4 = (char *) 0 ;
  char *arg5 = (char *) 0 ;
  bool result;
  
  SWIG_check_num_args("SetTechnique",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetTechnique",1,"VDynamicMesh *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("SetTechnique",2,"char const *");
  if(!SWIG_lua_isnilstring(L,3)) SWIG_fail_arg("SetTechnique",3,"char const *");
  if(!SWIG_lua_isnilstring(L,4)) SWIG_fail_arg("SetTechnique",4,"char const *");
  if(!SWIG_lua_isnilstring(L,5)) SWIG_fail_arg("SetTechnique",5,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VDynamicMesh,0))){
    SWIG_fail_ptr("VDynamicMesh_SetTechnique",1,SWIGTYPE_p_VDynamicMesh);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  arg3 = (char *)lua_tostring(L, 3);
  arg4 = (char *)lua_tostring(L, 4);
  arg5 = (char *)lua_tostring(L, 5);
  result = (bool)VDynamicMesh_SetTechnique__SWIG_4(arg1,(char const *)arg2,(char const *)arg3,(char const *)arg4,(char const *)arg5);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VDynamicMesh_SetTechnique__SWIG_5(lua_State* L) {
  int SWIG_arg = 0;
  VDynamicMesh *arg1 = (VDynamicMesh *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  char *arg4 = (char *) 0 ;
  bool result;
  
  SWIG_check_num_args("SetTechnique",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetTechnique",1,"VDynamicMesh *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("SetTechnique",2,"char const *");
  if(!SWIG_lua_isnilstring(L,3)) SWIG_fail_arg("SetTechnique",3,"char const *");
  if(!SWIG_lua_isnilstring(L,4)) SWIG_fail_arg("SetTechnique",4,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VDynamicMesh,0))){
    SWIG_fail_ptr("VDynamicMesh_SetTechnique",1,SWIGTYPE_p_VDynamicMesh);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  arg3 = (char *)lua_tostring(L, 3);
  arg4 = (char *)lua_tostring(L, 4);
  result = (bool)VDynamicMesh_SetTechnique__SWIG_4(arg1,(char const *)arg2,(char const *)arg3,(char const *)arg4);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VDynamicMesh_SetTechnique(lua_State* L) {
  int argc;
  int argv[6]={
    1,2,3,4,5,6
  };
  
  argc = lua_gettop(L);
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VDynamicMesh, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_VisSurface_cl, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          _v = SWIG_lua_isnilstring(L,argv[2]);
        }
        if (_v) {
          {
            _v = SWIG_lua_isnilstring(L,argv[3]);
          }
          if (_v) {
            return _wrap_VDynamicMesh_SetTechnique__SWIG_1(L);
          }
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VDynamicMesh, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = SWIG_lua_isnilstring(L,argv[2]);
        }
        if (_v) {
          {
            _v = SWIG_lua_isnilstring(L,argv[3]);
          }
          if (_v) {
            return _wrap_VDynamicMesh_SetTechnique__SWIG_3(L);
          }
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VDynamicMesh, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = SWIG_lua_isnilstring(L,argv[1]);
      }
      if (_v) {
        {
          _v = SWIG_lua_isnilstring(L,argv[2]);
        }
        if (_v) {
          {
            _v = SWIG_lua_isnilstring(L,argv[3]);
          }
          if (_v) {
            return _wrap_VDynamicMesh_SetTechnique__SWIG_5(L);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VDynamicMesh, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_VisSurface_cl, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          _v = SWIG_lua_isnilstring(L,argv[2]);
        }
        if (_v) {
          {
            _v = SWIG_lua_isnilstring(L,argv[3]);
          }
          if (_v) {
            {
              _v = SWIG_lua_isnilstring(L,argv[4]);
            }
            if (_v) {
              return _wrap_VDynamicMesh_SetTechnique__SWIG_0(L);
            }
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VDynamicMesh, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = SWIG_lua_isnilstring(L,argv[2]);
        }
        if (_v) {
          {
            _v = SWIG_lua_isnilstring(L,argv[3]);
          }
          if (_v) {
            {
              _v = SWIG_lua_isnilstring(L,argv[4]);
            }
            if (_v) {
              return _wrap_VDynamicMesh_SetTechnique__SWIG_2(L);
            }
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VDynamicMesh, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = SWIG_lua_isnilstring(L,argv[1]);
      }
      if (_v) {
        {
          _v = SWIG_lua_isnilstring(L,argv[2]);
        }
        if (_v) {
          {
            _v = SWIG_lua_isnilstring(L,argv[3]);
          }
          if (_v) {
            {
              _v = SWIG_lua_isnilstring(L,argv[4]);
            }
            if (_v) {
              return _wrap_VDynamicMesh_SetTechnique__SWIG_4(L);
            }
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'VDynamicMesh_SetTechnique'\n"
    "  Possible C/C++ prototypes are:\n"
    "    SetTechnique(VDynamicMesh *,VisSurface_cl *,char const *,char const *,char const *)\n"
    "    SetTechnique(VDynamicMesh *,VisSurface_cl *,char const *,char const *)\n"
    "    SetTechnique(VDynamicMesh *,int,char const *,char const *,char const *)\n"
    "    SetTechnique(VDynamicMesh *,int,char const *,char const *)\n"
    "    SetTechnique(VDynamicMesh *,char const *,char const *,char const *,char const *)\n"
    "    SetTechnique(VDynamicMesh *,char const *,char const *,char const *)\n");
  lua_error(L);return 0;
}


static int _wrap_VDynamicMesh_AddTechnique__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  VDynamicMesh *arg1 = (VDynamicMesh *) 0 ;
  VisSurface_cl *arg2 = (VisSurface_cl *) 0 ;
  char *arg3 = (char *) 0 ;
  char *arg4 = (char *) 0 ;
  char *arg5 = (char *) 0 ;
  bool result;
  
  SWIG_check_num_args("AddTechnique",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("AddTechnique",1,"VDynamicMesh *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("AddTechnique",2,"VisSurface_cl *");
  if(!SWIG_lua_isnilstring(L,3)) SWIG_fail_arg("AddTechnique",3,"char const *");
  if(!SWIG_lua_isnilstring(L,4)) SWIG_fail_arg("AddTechnique",4,"char const *");
  if(!SWIG_lua_isnilstring(L,5)) SWIG_fail_arg("AddTechnique",5,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VDynamicMesh,0))){
    SWIG_fail_ptr("VDynamicMesh_AddTechnique",1,SWIGTYPE_p_VDynamicMesh);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_VisSurface_cl,0))){
    SWIG_fail_ptr("VDynamicMesh_AddTechnique",2,SWIGTYPE_p_VisSurface_cl);
  }
  
  arg3 = (char *)lua_tostring(L, 3);
  arg4 = (char *)lua_tostring(L, 4);
  arg5 = (char *)lua_tostring(L, 5);
  result = (bool)VDynamicMesh_AddTechnique__SWIG_0(arg1,arg2,(char const *)arg3,(char const *)arg4,(char const *)arg5);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VDynamicMesh_AddTechnique__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  VDynamicMesh *arg1 = (VDynamicMesh *) 0 ;
  VisSurface_cl *arg2 = (VisSurface_cl *) 0 ;
  char *arg3 = (char *) 0 ;
  char *arg4 = (char *) 0 ;
  bool result;
  
  SWIG_check_num_args("AddTechnique",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("AddTechnique",1,"VDynamicMesh *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("AddTechnique",2,"VisSurface_cl *");
  if(!SWIG_lua_isnilstring(L,3)) SWIG_fail_arg("AddTechnique",3,"char const *");
  if(!SWIG_lua_isnilstring(L,4)) SWIG_fail_arg("AddTechnique",4,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VDynamicMesh,0))){
    SWIG_fail_ptr("VDynamicMesh_AddTechnique",1,SWIGTYPE_p_VDynamicMesh);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_VisSurface_cl,0))){
    SWIG_fail_ptr("VDynamicMesh_AddTechnique",2,SWIGTYPE_p_VisSurface_cl);
  }
  
  arg3 = (char *)lua_tostring(L, 3);
  arg4 = (char *)lua_tostring(L, 4);
  result = (bool)VDynamicMesh_AddTechnique__SWIG_0(arg1,arg2,(char const *)arg3,(char const *)arg4);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VDynamicMesh_AddTechnique__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  VDynamicMesh *arg1 = (VDynamicMesh *) 0 ;
  int arg2 ;
  char *arg3 = (char *) 0 ;
  char *arg4 = (char *) 0 ;
  char *arg5 = (char *) 0 ;
  bool result;
  
  SWIG_check_num_args("AddTechnique",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("AddTechnique",1,"VDynamicMesh *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("AddTechnique",2,"int");
  if(!SWIG_lua_isnilstring(L,3)) SWIG_fail_arg("AddTechnique",3,"char const *");
  if(!SWIG_lua_isnilstring(L,4)) SWIG_fail_arg("AddTechnique",4,"char const *");
  if(!SWIG_lua_isnilstring(L,5)) SWIG_fail_arg("AddTechnique",5,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VDynamicMesh,0))){
    SWIG_fail_ptr("VDynamicMesh_AddTechnique",1,SWIGTYPE_p_VDynamicMesh);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (char *)lua_tostring(L, 3);
  arg4 = (char *)lua_tostring(L, 4);
  arg5 = (char *)lua_tostring(L, 5);
  result = (bool)VDynamicMesh_AddTechnique__SWIG_2(arg1,arg2,(char const *)arg3,(char const *)arg4,(char const *)arg5);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VDynamicMesh_AddTechnique__SWIG_3(lua_State* L) {
  int SWIG_arg = 0;
  VDynamicMesh *arg1 = (VDynamicMesh *) 0 ;
  int arg2 ;
  char *arg3 = (char *) 0 ;
  char *arg4 = (char *) 0 ;
  bool result;
  
  SWIG_check_num_args("AddTechnique",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("AddTechnique",1,"VDynamicMesh *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("AddTechnique",2,"int");
  if(!SWIG_lua_isnilstring(L,3)) SWIG_fail_arg("AddTechnique",3,"char const *");
  if(!SWIG_lua_isnilstring(L,4)) SWIG_fail_arg("AddTechnique",4,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VDynamicMesh,0))){
    SWIG_fail_ptr("VDynamicMesh_AddTechnique",1,SWIGTYPE_p_VDynamicMesh);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (char *)lua_tostring(L, 3);
  arg4 = (char *)lua_tostring(L, 4);
  result = (bool)VDynamicMesh_AddTechnique__SWIG_2(arg1,arg2,(char const *)arg3,(char const *)arg4);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VDynamicMesh_AddTechnique__SWIG_4(lua_State* L) {
  int SWIG_arg = 0;
  VDynamicMesh *arg1 = (VDynamicMesh *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  char *arg4 = (char *) 0 ;
  char *arg5 = (char *) 0 ;
  bool result;
  
  SWIG_check_num_args("AddTechnique",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("AddTechnique",1,"VDynamicMesh *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("AddTechnique",2,"char const *");
  if(!SWIG_lua_isnilstring(L,3)) SWIG_fail_arg("AddTechnique",3,"char const *");
  if(!SWIG_lua_isnilstring(L,4)) SWIG_fail_arg("AddTechnique",4,"char const *");
  if(!SWIG_lua_isnilstring(L,5)) SWIG_fail_arg("AddTechnique",5,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VDynamicMesh,0))){
    SWIG_fail_ptr("VDynamicMesh_AddTechnique",1,SWIGTYPE_p_VDynamicMesh);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  arg3 = (char *)lua_tostring(L, 3);
  arg4 = (char *)lua_tostring(L, 4);
  arg5 = (char *)lua_tostring(L, 5);
  result = (bool)VDynamicMesh_AddTechnique__SWIG_4(arg1,(char const *)arg2,(char const *)arg3,(char const *)arg4,(char const *)arg5);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VDynamicMesh_AddTechnique__SWIG_5(lua_State* L) {
  int SWIG_arg = 0;
  VDynamicMesh *arg1 = (VDynamicMesh *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  char *arg4 = (char *) 0 ;
  bool result;
  
  SWIG_check_num_args("AddTechnique",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("AddTechnique",1,"VDynamicMesh *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("AddTechnique",2,"char const *");
  if(!SWIG_lua_isnilstring(L,3)) SWIG_fail_arg("AddTechnique",3,"char const *");
  if(!SWIG_lua_isnilstring(L,4)) SWIG_fail_arg("AddTechnique",4,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VDynamicMesh,0))){
    SWIG_fail_ptr("VDynamicMesh_AddTechnique",1,SWIGTYPE_p_VDynamicMesh);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  arg3 = (char *)lua_tostring(L, 3);
  arg4 = (char *)lua_tostring(L, 4);
  result = (bool)VDynamicMesh_AddTechnique__SWIG_4(arg1,(char const *)arg2,(char const *)arg3,(char const *)arg4);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VDynamicMesh_AddTechnique(lua_State* L) {
  int argc;
  int argv[6]={
    1,2,3,4,5,6
  };
  
  argc = lua_gettop(L);
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VDynamicMesh, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_VisSurface_cl, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          _v = SWIG_lua_isnilstring(L,argv[2]);
        }
        if (_v) {
          {
            _v = SWIG_lua_isnilstring(L,argv[3]);
          }
          if (_v) {
            return _wrap_VDynamicMesh_AddTechnique__SWIG_1(L);
          }
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VDynamicMesh, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = SWIG_lua_isnilstring(L,argv[2]);
        }
        if (_v) {
          {
            _v = SWIG_lua_isnilstring(L,argv[3]);
          }
          if (_v) {
            return _wrap_VDynamicMesh_AddTechnique__SWIG_3(L);
          }
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VDynamicMesh, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = SWIG_lua_isnilstring(L,argv[1]);
      }
      if (_v) {
        {
          _v = SWIG_lua_isnilstring(L,argv[2]);
        }
        if (_v) {
          {
            _v = SWIG_lua_isnilstring(L,argv[3]);
          }
          if (_v) {
            return _wrap_VDynamicMesh_AddTechnique__SWIG_5(L);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VDynamicMesh, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_VisSurface_cl, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          _v = SWIG_lua_isnilstring(L,argv[2]);
        }
        if (_v) {
          {
            _v = SWIG_lua_isnilstring(L,argv[3]);
          }
          if (_v) {
            {
              _v = SWIG_lua_isnilstring(L,argv[4]);
            }
            if (_v) {
              return _wrap_VDynamicMesh_AddTechnique__SWIG_0(L);
            }
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VDynamicMesh, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = SWIG_lua_isnilstring(L,argv[2]);
        }
        if (_v) {
          {
            _v = SWIG_lua_isnilstring(L,argv[3]);
          }
          if (_v) {
            {
              _v = SWIG_lua_isnilstring(L,argv[4]);
            }
            if (_v) {
              return _wrap_VDynamicMesh_AddTechnique__SWIG_2(L);
            }
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VDynamicMesh, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = SWIG_lua_isnilstring(L,argv[1]);
      }
      if (_v) {
        {
          _v = SWIG_lua_isnilstring(L,argv[2]);
        }
        if (_v) {
          {
            _v = SWIG_lua_isnilstring(L,argv[3]);
          }
          if (_v) {
            {
              _v = SWIG_lua_isnilstring(L,argv[4]);
            }
            if (_v) {
              return _wrap_VDynamicMesh_AddTechnique__SWIG_4(L);
            }
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'VDynamicMesh_AddTechnique'\n"
    "  Possible C/C++ prototypes are:\n"
    "    AddTechnique(VDynamicMesh *,VisSurface_cl *,char const *,char const *,char const *)\n"
    "    AddTechnique(VDynamicMesh *,VisSurface_cl *,char const *,char const *)\n"
    "    AddTechnique(VDynamicMesh *,int,char const *,char const *,char const *)\n"
    "    AddTechnique(VDynamicMesh *,int,char const *,char const *)\n"
    "    AddTechnique(VDynamicMesh *,char const *,char const *,char const *,char const *)\n"
    "    AddTechnique(VDynamicMesh *,char const *,char const *,char const *)\n");
  lua_error(L);return 0;
}


static int _wrap_VDynamicMesh_SetEffect__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  VDynamicMesh *arg1 = (VDynamicMesh *) 0 ;
  VisSurface_cl *arg2 = (VisSurface_cl *) 0 ;
  char *arg3 = (char *) 0 ;
  char *arg4 = (char *) 0 ;
  char *arg5 = (char *) 0 ;
  bool result;
  
  SWIG_check_num_args("SetEffect",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetEffect",1,"VDynamicMesh *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SetEffect",2,"VisSurface_cl *");
  if(!SWIG_lua_isnilstring(L,3)) SWIG_fail_arg("SetEffect",3,"char const *");
  if(!SWIG_lua_isnilstring(L,4)) SWIG_fail_arg("SetEffect",4,"char const *");
  if(!SWIG_lua_isnilstring(L,5)) SWIG_fail_arg("SetEffect",5,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VDynamicMesh,0))){
    SWIG_fail_ptr("VDynamicMesh_SetEffect",1,SWIGTYPE_p_VDynamicMesh);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_VisSurface_cl,0))){
    SWIG_fail_ptr("VDynamicMesh_SetEffect",2,SWIGTYPE_p_VisSurface_cl);
  }
  
  arg3 = (char *)lua_tostring(L, 3);
  arg4 = (char *)lua_tostring(L, 4);
  arg5 = (char *)lua_tostring(L, 5);
  result = (bool)VDynamicMesh_SetEffect__SWIG_0(arg1,arg2,(char const *)arg3,(char const *)arg4,(char const *)arg5);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VDynamicMesh_SetEffect__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  VDynamicMesh *arg1 = (VDynamicMesh *) 0 ;
  VisSurface_cl *arg2 = (VisSurface_cl *) 0 ;
  char *arg3 = (char *) 0 ;
  char *arg4 = (char *) 0 ;
  bool result;
  
  SWIG_check_num_args("SetEffect",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetEffect",1,"VDynamicMesh *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SetEffect",2,"VisSurface_cl *");
  if(!SWIG_lua_isnilstring(L,3)) SWIG_fail_arg("SetEffect",3,"char const *");
  if(!SWIG_lua_isnilstring(L,4)) SWIG_fail_arg("SetEffect",4,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VDynamicMesh,0))){
    SWIG_fail_ptr("VDynamicMesh_SetEffect",1,SWIGTYPE_p_VDynamicMesh);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_VisSurface_cl,0))){
    SWIG_fail_ptr("VDynamicMesh_SetEffect",2,SWIGTYPE_p_VisSurface_cl);
  }
  
  arg3 = (char *)lua_tostring(L, 3);
  arg4 = (char *)lua_tostring(L, 4);
  result = (bool)VDynamicMesh_SetEffect__SWIG_0(arg1,arg2,(char const *)arg3,(char const *)arg4);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VDynamicMesh_SetEffect__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  VDynamicMesh *arg1 = (VDynamicMesh *) 0 ;
  int arg2 ;
  char *arg3 = (char *) 0 ;
  char *arg4 = (char *) 0 ;
  char *arg5 = (char *) 0 ;
  bool result;
  
  SWIG_check_num_args("SetEffect",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetEffect",1,"VDynamicMesh *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SetEffect",2,"int");
  if(!SWIG_lua_isnilstring(L,3)) SWIG_fail_arg("SetEffect",3,"char const *");
  if(!SWIG_lua_isnilstring(L,4)) SWIG_fail_arg("SetEffect",4,"char const *");
  if(!SWIG_lua_isnilstring(L,5)) SWIG_fail_arg("SetEffect",5,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VDynamicMesh,0))){
    SWIG_fail_ptr("VDynamicMesh_SetEffect",1,SWIGTYPE_p_VDynamicMesh);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (char *)lua_tostring(L, 3);
  arg4 = (char *)lua_tostring(L, 4);
  arg5 = (char *)lua_tostring(L, 5);
  result = (bool)VDynamicMesh_SetEffect__SWIG_2(arg1,arg2,(char const *)arg3,(char const *)arg4,(char const *)arg5);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VDynamicMesh_SetEffect__SWIG_3(lua_State* L) {
  int SWIG_arg = 0;
  VDynamicMesh *arg1 = (VDynamicMesh *) 0 ;
  int arg2 ;
  char *arg3 = (char *) 0 ;
  char *arg4 = (char *) 0 ;
  bool result;
  
  SWIG_check_num_args("SetEffect",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetEffect",1,"VDynamicMesh *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SetEffect",2,"int");
  if(!SWIG_lua_isnilstring(L,3)) SWIG_fail_arg("SetEffect",3,"char const *");
  if(!SWIG_lua_isnilstring(L,4)) SWIG_fail_arg("SetEffect",4,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VDynamicMesh,0))){
    SWIG_fail_ptr("VDynamicMesh_SetEffect",1,SWIGTYPE_p_VDynamicMesh);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (char *)lua_tostring(L, 3);
  arg4 = (char *)lua_tostring(L, 4);
  result = (bool)VDynamicMesh_SetEffect__SWIG_2(arg1,arg2,(char const *)arg3,(char const *)arg4);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VDynamicMesh_SetEffect__SWIG_4(lua_State* L) {
  int SWIG_arg = 0;
  VDynamicMesh *arg1 = (VDynamicMesh *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  char *arg4 = (char *) 0 ;
  char *arg5 = (char *) 0 ;
  bool result;
  
  SWIG_check_num_args("SetEffect",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetEffect",1,"VDynamicMesh *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("SetEffect",2,"char const *");
  if(!SWIG_lua_isnilstring(L,3)) SWIG_fail_arg("SetEffect",3,"char const *");
  if(!SWIG_lua_isnilstring(L,4)) SWIG_fail_arg("SetEffect",4,"char const *");
  if(!SWIG_lua_isnilstring(L,5)) SWIG_fail_arg("SetEffect",5,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VDynamicMesh,0))){
    SWIG_fail_ptr("VDynamicMesh_SetEffect",1,SWIGTYPE_p_VDynamicMesh);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  arg3 = (char *)lua_tostring(L, 3);
  arg4 = (char *)lua_tostring(L, 4);
  arg5 = (char *)lua_tostring(L, 5);
  result = (bool)VDynamicMesh_SetEffect__SWIG_4(arg1,(char const *)arg2,(char const *)arg3,(char const *)arg4,(char const *)arg5);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VDynamicMesh_SetEffect__SWIG_5(lua_State* L) {
  int SWIG_arg = 0;
  VDynamicMesh *arg1 = (VDynamicMesh *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  char *arg4 = (char *) 0 ;
  bool result;
  
  SWIG_check_num_args("SetEffect",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetEffect",1,"VDynamicMesh *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("SetEffect",2,"char const *");
  if(!SWIG_lua_isnilstring(L,3)) SWIG_fail_arg("SetEffect",3,"char const *");
  if(!SWIG_lua_isnilstring(L,4)) SWIG_fail_arg("SetEffect",4,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VDynamicMesh,0))){
    SWIG_fail_ptr("VDynamicMesh_SetEffect",1,SWIGTYPE_p_VDynamicMesh);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  arg3 = (char *)lua_tostring(L, 3);
  arg4 = (char *)lua_tostring(L, 4);
  result = (bool)VDynamicMesh_SetEffect__SWIG_4(arg1,(char const *)arg2,(char const *)arg3,(char const *)arg4);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VDynamicMesh_SetEffect(lua_State* L) {
  int argc;
  int argv[6]={
    1,2,3,4,5,6
  };
  
  argc = lua_gettop(L);
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VDynamicMesh, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_VisSurface_cl, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          _v = SWIG_lua_isnilstring(L,argv[2]);
        }
        if (_v) {
          {
            _v = SWIG_lua_isnilstring(L,argv[3]);
          }
          if (_v) {
            return _wrap_VDynamicMesh_SetEffect__SWIG_1(L);
          }
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VDynamicMesh, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = SWIG_lua_isnilstring(L,argv[2]);
        }
        if (_v) {
          {
            _v = SWIG_lua_isnilstring(L,argv[3]);
          }
          if (_v) {
            return _wrap_VDynamicMesh_SetEffect__SWIG_3(L);
          }
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VDynamicMesh, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = SWIG_lua_isnilstring(L,argv[1]);
      }
      if (_v) {
        {
          _v = SWIG_lua_isnilstring(L,argv[2]);
        }
        if (_v) {
          {
            _v = SWIG_lua_isnilstring(L,argv[3]);
          }
          if (_v) {
            return _wrap_VDynamicMesh_SetEffect__SWIG_5(L);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VDynamicMesh, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_VisSurface_cl, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          _v = SWIG_lua_isnilstring(L,argv[2]);
        }
        if (_v) {
          {
            _v = SWIG_lua_isnilstring(L,argv[3]);
          }
          if (_v) {
            {
              _v = SWIG_lua_isnilstring(L,argv[4]);
            }
            if (_v) {
              return _wrap_VDynamicMesh_SetEffect__SWIG_0(L);
            }
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VDynamicMesh, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = SWIG_lua_isnilstring(L,argv[2]);
        }
        if (_v) {
          {
            _v = SWIG_lua_isnilstring(L,argv[3]);
          }
          if (_v) {
            {
              _v = SWIG_lua_isnilstring(L,argv[4]);
            }
            if (_v) {
              return _wrap_VDynamicMesh_SetEffect__SWIG_2(L);
            }
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VDynamicMesh, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = SWIG_lua_isnilstring(L,argv[1]);
      }
      if (_v) {
        {
          _v = SWIG_lua_isnilstring(L,argv[2]);
        }
        if (_v) {
          {
            _v = SWIG_lua_isnilstring(L,argv[3]);
          }
          if (_v) {
            {
              _v = SWIG_lua_isnilstring(L,argv[4]);
            }
            if (_v) {
              return _wrap_VDynamicMesh_SetEffect__SWIG_4(L);
            }
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'VDynamicMesh_SetEffect'\n"
    "  Possible C/C++ prototypes are:\n"
    "    SetEffect(VDynamicMesh *,VisSurface_cl *,char const *,char const *,char const *)\n"
    "    SetEffect(VDynamicMesh *,VisSurface_cl *,char const *,char const *)\n"
    "    SetEffect(VDynamicMesh *,int,char const *,char const *,char const *)\n"
    "    SetEffect(VDynamicMesh *,int,char const *,char const *)\n"
    "    SetEffect(VDynamicMesh *,char const *,char const *,char const *,char const *)\n"
    "    SetEffect(VDynamicMesh *,char const *,char const *,char const *)\n");
  lua_error(L);return 0;
}


static int _wrap_VDynamicMesh_AddEffect__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  VDynamicMesh *arg1 = (VDynamicMesh *) 0 ;
  VisSurface_cl *arg2 = (VisSurface_cl *) 0 ;
  char *arg3 = (char *) 0 ;
  char *arg4 = (char *) 0 ;
  char *arg5 = (char *) 0 ;
  bool result;
  
  SWIG_check_num_args("AddEffect",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("AddEffect",1,"VDynamicMesh *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("AddEffect",2,"VisSurface_cl *");
  if(!SWIG_lua_isnilstring(L,3)) SWIG_fail_arg("AddEffect",3,"char const *");
  if(!SWIG_lua_isnilstring(L,4)) SWIG_fail_arg("AddEffect",4,"char const *");
  if(!SWIG_lua_isnilstring(L,5)) SWIG_fail_arg("AddEffect",5,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VDynamicMesh,0))){
    SWIG_fail_ptr("VDynamicMesh_AddEffect",1,SWIGTYPE_p_VDynamicMesh);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_VisSurface_cl,0))){
    SWIG_fail_ptr("VDynamicMesh_AddEffect",2,SWIGTYPE_p_VisSurface_cl);
  }
  
  arg3 = (char *)lua_tostring(L, 3);
  arg4 = (char *)lua_tostring(L, 4);
  arg5 = (char *)lua_tostring(L, 5);
  result = (bool)VDynamicMesh_AddEffect__SWIG_0(arg1,arg2,(char const *)arg3,(char const *)arg4,(char const *)arg5);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VDynamicMesh_AddEffect__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  VDynamicMesh *arg1 = (VDynamicMesh *) 0 ;
  VisSurface_cl *arg2 = (VisSurface_cl *) 0 ;
  char *arg3 = (char *) 0 ;
  char *arg4 = (char *) 0 ;
  bool result;
  
  SWIG_check_num_args("AddEffect",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("AddEffect",1,"VDynamicMesh *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("AddEffect",2,"VisSurface_cl *");
  if(!SWIG_lua_isnilstring(L,3)) SWIG_fail_arg("AddEffect",3,"char const *");
  if(!SWIG_lua_isnilstring(L,4)) SWIG_fail_arg("AddEffect",4,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VDynamicMesh,0))){
    SWIG_fail_ptr("VDynamicMesh_AddEffect",1,SWIGTYPE_p_VDynamicMesh);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_VisSurface_cl,0))){
    SWIG_fail_ptr("VDynamicMesh_AddEffect",2,SWIGTYPE_p_VisSurface_cl);
  }
  
  arg3 = (char *)lua_tostring(L, 3);
  arg4 = (char *)lua_tostring(L, 4);
  result = (bool)VDynamicMesh_AddEffect__SWIG_0(arg1,arg2,(char const *)arg3,(char const *)arg4);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VDynamicMesh_AddEffect__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  VDynamicMesh *arg1 = (VDynamicMesh *) 0 ;
  int arg2 ;
  char *arg3 = (char *) 0 ;
  char *arg4 = (char *) 0 ;
  char *arg5 = (char *) 0 ;
  bool result;
  
  SWIG_check_num_args("AddEffect",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("AddEffect",1,"VDynamicMesh *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("AddEffect",2,"int");
  if(!SWIG_lua_isnilstring(L,3)) SWIG_fail_arg("AddEffect",3,"char const *");
  if(!SWIG_lua_isnilstring(L,4)) SWIG_fail_arg("AddEffect",4,"char const *");
  if(!SWIG_lua_isnilstring(L,5)) SWIG_fail_arg("AddEffect",5,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VDynamicMesh,0))){
    SWIG_fail_ptr("VDynamicMesh_AddEffect",1,SWIGTYPE_p_VDynamicMesh);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (char *)lua_tostring(L, 3);
  arg4 = (char *)lua_tostring(L, 4);
  arg5 = (char *)lua_tostring(L, 5);
  result = (bool)VDynamicMesh_AddEffect__SWIG_2(arg1,arg2,(char const *)arg3,(char const *)arg4,(char const *)arg5);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VDynamicMesh_AddEffect__SWIG_3(lua_State* L) {
  int SWIG_arg = 0;
  VDynamicMesh *arg1 = (VDynamicMesh *) 0 ;
  int arg2 ;
  char *arg3 = (char *) 0 ;
  char *arg4 = (char *) 0 ;
  bool result;
  
  SWIG_check_num_args("AddEffect",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("AddEffect",1,"VDynamicMesh *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("AddEffect",2,"int");
  if(!SWIG_lua_isnilstring(L,3)) SWIG_fail_arg("AddEffect",3,"char const *");
  if(!SWIG_lua_isnilstring(L,4)) SWIG_fail_arg("AddEffect",4,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VDynamicMesh,0))){
    SWIG_fail_ptr("VDynamicMesh_AddEffect",1,SWIGTYPE_p_VDynamicMesh);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (char *)lua_tostring(L, 3);
  arg4 = (char *)lua_tostring(L, 4);
  result = (bool)VDynamicMesh_AddEffect__SWIG_2(arg1,arg2,(char const *)arg3,(char const *)arg4);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VDynamicMesh_AddEffect__SWIG_4(lua_State* L) {
  int SWIG_arg = 0;
  VDynamicMesh *arg1 = (VDynamicMesh *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  char *arg4 = (char *) 0 ;
  char *arg5 = (char *) 0 ;
  bool result;
  
  SWIG_check_num_args("AddEffect",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("AddEffect",1,"VDynamicMesh *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("AddEffect",2,"char const *");
  if(!SWIG_lua_isnilstring(L,3)) SWIG_fail_arg("AddEffect",3,"char const *");
  if(!SWIG_lua_isnilstring(L,4)) SWIG_fail_arg("AddEffect",4,"char const *");
  if(!SWIG_lua_isnilstring(L,5)) SWIG_fail_arg("AddEffect",5,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VDynamicMesh,0))){
    SWIG_fail_ptr("VDynamicMesh_AddEffect",1,SWIGTYPE_p_VDynamicMesh);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  arg3 = (char *)lua_tostring(L, 3);
  arg4 = (char *)lua_tostring(L, 4);
  arg5 = (char *)lua_tostring(L, 5);
  result = (bool)VDynamicMesh_AddEffect__SWIG_4(arg1,(char const *)arg2,(char const *)arg3,(char const *)arg4,(char const *)arg5);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VDynamicMesh_AddEffect__SWIG_5(lua_State* L) {
  int SWIG_arg = 0;
  VDynamicMesh *arg1 = (VDynamicMesh *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  char *arg4 = (char *) 0 ;
  bool result;
  
  SWIG_check_num_args("AddEffect",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("AddEffect",1,"VDynamicMesh *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("AddEffect",2,"char const *");
  if(!SWIG_lua_isnilstring(L,3)) SWIG_fail_arg("AddEffect",3,"char const *");
  if(!SWIG_lua_isnilstring(L,4)) SWIG_fail_arg("AddEffect",4,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VDynamicMesh,0))){
    SWIG_fail_ptr("VDynamicMesh_AddEffect",1,SWIGTYPE_p_VDynamicMesh);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  arg3 = (char *)lua_tostring(L, 3);
  arg4 = (char *)lua_tostring(L, 4);
  result = (bool)VDynamicMesh_AddEffect__SWIG_4(arg1,(char const *)arg2,(char const *)arg3,(char const *)arg4);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VDynamicMesh_AddEffect(lua_State* L) {
  int argc;
  int argv[6]={
    1,2,3,4,5,6
  };
  
  argc = lua_gettop(L);
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VDynamicMesh, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_VisSurface_cl, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          _v = SWIG_lua_isnilstring(L,argv[2]);
        }
        if (_v) {
          {
            _v = SWIG_lua_isnilstring(L,argv[3]);
          }
          if (_v) {
            return _wrap_VDynamicMesh_AddEffect__SWIG_1(L);
          }
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VDynamicMesh, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = SWIG_lua_isnilstring(L,argv[2]);
        }
        if (_v) {
          {
            _v = SWIG_lua_isnilstring(L,argv[3]);
          }
          if (_v) {
            return _wrap_VDynamicMesh_AddEffect__SWIG_3(L);
          }
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VDynamicMesh, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = SWIG_lua_isnilstring(L,argv[1]);
      }
      if (_v) {
        {
          _v = SWIG_lua_isnilstring(L,argv[2]);
        }
        if (_v) {
          {
            _v = SWIG_lua_isnilstring(L,argv[3]);
          }
          if (_v) {
            return _wrap_VDynamicMesh_AddEffect__SWIG_5(L);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VDynamicMesh, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_VisSurface_cl, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          _v = SWIG_lua_isnilstring(L,argv[2]);
        }
        if (_v) {
          {
            _v = SWIG_lua_isnilstring(L,argv[3]);
          }
          if (_v) {
            {
              _v = SWIG_lua_isnilstring(L,argv[4]);
            }
            if (_v) {
              return _wrap_VDynamicMesh_AddEffect__SWIG_0(L);
            }
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VDynamicMesh, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = SWIG_lua_isnilstring(L,argv[2]);
        }
        if (_v) {
          {
            _v = SWIG_lua_isnilstring(L,argv[3]);
          }
          if (_v) {
            {
              _v = SWIG_lua_isnilstring(L,argv[4]);
            }
            if (_v) {
              return _wrap_VDynamicMesh_AddEffect__SWIG_2(L);
            }
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VDynamicMesh, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = SWIG_lua_isnilstring(L,argv[1]);
      }
      if (_v) {
        {
          _v = SWIG_lua_isnilstring(L,argv[2]);
        }
        if (_v) {
          {
            _v = SWIG_lua_isnilstring(L,argv[3]);
          }
          if (_v) {
            {
              _v = SWIG_lua_isnilstring(L,argv[4]);
            }
            if (_v) {
              return _wrap_VDynamicMesh_AddEffect__SWIG_4(L);
            }
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'VDynamicMesh_AddEffect'\n"
    "  Possible C/C++ prototypes are:\n"
    "    AddEffect(VDynamicMesh *,VisSurface_cl *,char const *,char const *,char const *)\n"
    "    AddEffect(VDynamicMesh *,VisSurface_cl *,char const *,char const *)\n"
    "    AddEffect(VDynamicMesh *,int,char const *,char const *,char const *)\n"
    "    AddEffect(VDynamicMesh *,int,char const *,char const *)\n"
    "    AddEffect(VDynamicMesh *,char const *,char const *,char const *,char const *)\n"
    "    AddEffect(VDynamicMesh *,char const *,char const *,char const *)\n");
  lua_error(L);return 0;
}


static int _wrap_VDynamicMesh_GetSurface__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  VDynamicMesh *arg1 = (VDynamicMesh *) 0 ;
  char *arg2 = (char *) 0 ;
  VisSurface_cl *result = 0 ;
  
  SWIG_check_num_args("GetSurfaceByName",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetSurfaceByName",1,"VDynamicMesh const *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("GetSurfaceByName",2,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VDynamicMesh,0))){
    SWIG_fail_ptr("VDynamicMesh_GetSurface",1,SWIGTYPE_p_VDynamicMesh);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  result = (VisSurface_cl *)((VDynamicMesh const *)arg1)->GetSurfaceByName((char const *)arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_VisSurface_cl,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VDynamicMesh_GetSurface__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  VDynamicMesh *arg1 = (VDynamicMesh *) 0 ;
  int arg2 ;
  VisSurface_cl *result = 0 ;
  
  SWIG_check_num_args("GetSurface",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetSurface",1,"VDynamicMesh const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("GetSurface",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VDynamicMesh,0))){
    SWIG_fail_ptr("VDynamicMesh_GetSurface",1,SWIGTYPE_p_VDynamicMesh);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  result = (VisSurface_cl *)((VDynamicMesh const *)arg1)->GetSurface(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_VisSurface_cl,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VDynamicMesh_GetSurface(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VDynamicMesh, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_VDynamicMesh_GetSurface__SWIG_1(L);
      }
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VDynamicMesh, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = SWIG_lua_isnilstring(L,argv[1]);
      }
      if (_v) {
        return _wrap_VDynamicMesh_GetSurface__SWIG_0(L);
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'VDynamicMesh_GetSurface'\n"
    "  Possible C/C++ prototypes are:\n"
    "    GetSurfaceByName(VDynamicMesh const *,char const *)\n"
    "    GetSurface(VDynamicMesh const *,int)\n");
  lua_error(L);return 0;
}


static int _wrap_VDynamicMesh_GetSurfaceIndex(lua_State* L) {
  int SWIG_arg = 0;
  VDynamicMesh *arg1 = (VDynamicMesh *) 0 ;
  VisSurface_cl *arg2 = (VisSurface_cl *) 0 ;
  int result;
  
  SWIG_check_num_args("GetSurfaceIndex",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetSurfaceIndex",1,"VDynamicMesh *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("GetSurfaceIndex",2,"VisSurface_cl *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VDynamicMesh,0))){
    SWIG_fail_ptr("VDynamicMesh_GetSurfaceIndex",1,SWIGTYPE_p_VDynamicMesh);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_VisSurface_cl,0))){
    SWIG_fail_ptr("VDynamicMesh_GetSurfaceIndex",2,SWIGTYPE_p_VisSurface_cl);
  }
  
  result = (int)(arg1)->GetSurfaceIndex(arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VDynamicMesh_GetName(lua_State* L) {
  int SWIG_arg = 0;
  VDynamicMesh *arg1 = (VDynamicMesh *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("GetFilename",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetFilename",1,"VDynamicMesh const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VDynamicMesh,0))){
    SWIG_fail_ptr("VDynamicMesh_GetName",1,SWIGTYPE_p_VDynamicMesh);
  }
  
  result = (char *)((VDynamicMesh const *)arg1)->GetFilename();
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VDynamicMesh___eq(lua_State* L) {
  int SWIG_arg = 0;
  VDynamicMesh *arg1 = (VDynamicMesh *) 0 ;
  VDynamicMesh *arg2 = 0 ;
  bool result;
  
  SWIG_check_num_args("operator ==",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("operator ==",1,"VDynamicMesh *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("operator ==",2,"VDynamicMesh const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VDynamicMesh,0))){
    SWIG_fail_ptr("VDynamicMesh___eq",1,SWIGTYPE_p_VDynamicMesh);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_VDynamicMesh,0))){
    SWIG_fail_ptr("VDynamicMesh___eq",2,SWIGTYPE_p_VDynamicMesh);
  }
  
  result = (bool)VDynamicMesh_operator_Se__Se_(arg1,(VDynamicMesh const &)*arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static swig_lua_method swig_VDynamicMesh_methods[] = {
    { "__tostring",VDynamicMesh_ToString},
    { "GetAllSurfaces",VDynamicMesh_GetAllSurfaces},
    { "__concat",VDynamicMesh_Concat},
    {"GetSubmeshCount", _wrap_VDynamicMesh_GetSubmeshCount}, 
    {"GetSurfaceCount", _wrap_VDynamicMesh_GetSurfaceCount}, 
    {"GetBoundingBox", _wrap_VDynamicMesh_GetBoundingBox}, 
    {"ReloadShaderAssignment", _wrap_VDynamicMesh_ReloadShaderAssignment}, 
    {"SetTechnique", _wrap_VDynamicMesh_SetTechnique}, 
    {"AddTechnique", _wrap_VDynamicMesh_AddTechnique}, 
    {"SetEffect", _wrap_VDynamicMesh_SetEffect}, 
    {"AddEffect", _wrap_VDynamicMesh_AddEffect}, 
    {"GetSurface", _wrap_VDynamicMesh_GetSurface}, 
    {"GetSurfaceIndex", _wrap_VDynamicMesh_GetSurfaceIndex}, 
    {"GetName", _wrap_VDynamicMesh_GetName}, 
    {"__eq", _wrap_VDynamicMesh___eq}, 
    {0,0}
};
static swig_lua_attribute swig_VDynamicMesh_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_VDynamicMesh_bases[] = {0};
static const char *swig_VDynamicMesh_base_names[] = {0};
static swig_lua_class _wrap_class_VDynamicMesh = { "VDynamicMesh", &SWIGTYPE_p_VDynamicMesh,0,0, swig_VDynamicMesh_methods, swig_VDynamicMesh_attributes, swig_VDynamicMesh_bases, swig_VDynamicMesh_base_names };

static int _wrap_VisLightSource_cl_Remove(lua_State* L) {
  int SWIG_arg = 0;
  VisLightSource_cl *arg1 = (VisLightSource_cl *) 0 ;
  
  SWIG_check_num_args("Remove",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Remove",1,"VisLightSource_cl *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisLightSource_cl,0))){
    SWIG_fail_ptr("VisLightSource_cl_Remove",1,SWIGTYPE_p_VisLightSource_cl);
  }
  
  (arg1)->Remove();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisLightSource_cl_SetColor(lua_State* L) {
  int SWIG_arg = 0;
  VisLightSource_cl *arg1 = (VisLightSource_cl *) 0 ;
  VColorRef arg2 ;
  VColorRef *argp2 ;
  
  SWIG_check_num_args("SetColor",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetColor",1,"VisLightSource_cl *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("SetColor",2,"VColorRef");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisLightSource_cl,0))){
    SWIG_fail_ptr("VisLightSource_cl_SetColor",1,SWIGTYPE_p_VisLightSource_cl);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_VColorRef,0))){
    SWIG_fail_ptr("VisLightSource_cl_SetColor",2,SWIGTYPE_p_VColorRef);
  }
  arg2 = *argp2;
  
  (arg1)->SetColor(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisLightSource_cl_GetColor(lua_State* L) {
  int SWIG_arg = 0;
  VisLightSource_cl *arg1 = (VisLightSource_cl *) 0 ;
  VColorRef result;
  
  SWIG_check_num_args("GetColor",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetColor",1,"VisLightSource_cl const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisLightSource_cl,0))){
    SWIG_fail_ptr("VisLightSource_cl_GetColor",1,SWIGTYPE_p_VisLightSource_cl);
  }
  
  result = ((VisLightSource_cl const *)arg1)->GetColor();
  {
    VColorRef * resultptr = new VColorRef((const VColorRef &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_VColorRef,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisLightSource_cl_SetIntensity(lua_State* L) {
  int SWIG_arg = 0;
  VisLightSource_cl *arg1 = (VisLightSource_cl *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("SetIntensity",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetIntensity",1,"VisLightSource_cl *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SetIntensity",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisLightSource_cl,0))){
    SWIG_fail_ptr("VisLightSource_cl_SetIntensity",1,SWIGTYPE_p_VisLightSource_cl);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->SetIntensity(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisLightSource_cl_GetIntensity(lua_State* L) {
  int SWIG_arg = 0;
  VisLightSource_cl *arg1 = (VisLightSource_cl *) 0 ;
  float result;
  
  SWIG_check_num_args("GetIntensity",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetIntensity",1,"VisLightSource_cl const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisLightSource_cl,0))){
    SWIG_fail_ptr("VisLightSource_cl_GetIntensity",1,SWIGTYPE_p_VisLightSource_cl);
  }
  
  result = (float)((VisLightSource_cl const *)arg1)->GetIntensity();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisLightSource_cl_SetMultiplier(lua_State* L) {
  int SWIG_arg = 0;
  VisLightSource_cl *arg1 = (VisLightSource_cl *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("SetMultiplier",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetMultiplier",1,"VisLightSource_cl *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SetMultiplier",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisLightSource_cl,0))){
    SWIG_fail_ptr("VisLightSource_cl_SetMultiplier",1,SWIGTYPE_p_VisLightSource_cl);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->SetMultiplier(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisLightSource_cl_GetMultiplier(lua_State* L) {
  int SWIG_arg = 0;
  VisLightSource_cl *arg1 = (VisLightSource_cl *) 0 ;
  float result;
  
  SWIG_check_num_args("GetMultiplier",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetMultiplier",1,"VisLightSource_cl const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisLightSource_cl,0))){
    SWIG_fail_ptr("VisLightSource_cl_GetMultiplier",1,SWIGTYPE_p_VisLightSource_cl);
  }
  
  result = (float)((VisLightSource_cl const *)arg1)->GetMultiplier();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisLightSource_cl_SetProjectionAngle(lua_State* L) {
  int SWIG_arg = 0;
  VisLightSource_cl *arg1 = (VisLightSource_cl *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("SetProjectionAngle",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetProjectionAngle",1,"VisLightSource_cl *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SetProjectionAngle",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisLightSource_cl,0))){
    SWIG_fail_ptr("VisLightSource_cl_SetProjectionAngle",1,SWIGTYPE_p_VisLightSource_cl);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->SetProjectionAngle(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisLightSource_cl_GetProjectionAngle(lua_State* L) {
  int SWIG_arg = 0;
  VisLightSource_cl *arg1 = (VisLightSource_cl *) 0 ;
  float result;
  
  SWIG_check_num_args("GetProjectionAngle",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetProjectionAngle",1,"VisLightSource_cl const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisLightSource_cl,0))){
    SWIG_fail_ptr("VisLightSource_cl_GetProjectionAngle",1,SWIGTYPE_p_VisLightSource_cl);
  }
  
  result = (float)((VisLightSource_cl const *)arg1)->GetProjectionAngle();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisLightSource_cl_SetCoronaTexture(lua_State* L) {
  int SWIG_arg = 0;
  VisLightSource_cl *arg1 = (VisLightSource_cl *) 0 ;
  char *arg2 = (char *) 0 ;
  
  SWIG_check_num_args("SetCoronaTexture",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetCoronaTexture",1,"VisLightSource_cl *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("SetCoronaTexture",2,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisLightSource_cl,0))){
    SWIG_fail_ptr("VisLightSource_cl_SetCoronaTexture",1,SWIGTYPE_p_VisLightSource_cl);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  VisLightSource_cl_SetCoronaTexture(arg1,(char const *)arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisLightSource_cl_SetupAppearance(lua_State* L) {
  int SWIG_arg = 0;
  VisLightSource_cl *arg1 = (VisLightSource_cl *) 0 ;
  bool arg2 ;
  bool arg3 ;
  
  SWIG_check_num_args("SetupAppearance",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetupAppearance",1,"VisLightSource_cl *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("SetupAppearance",2,"bool");
  if(!lua_isboolean(L,3)) SWIG_fail_arg("SetupAppearance",3,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisLightSource_cl,0))){
    SWIG_fail_ptr("VisLightSource_cl_SetupAppearance",1,SWIGTYPE_p_VisLightSource_cl);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  arg3 = (lua_toboolean(L, 3)!=0);
  VisLightSource_cl_SetupAppearance(arg1,arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisLightSource_cl_GetTriggered(lua_State* L) {
  int SWIG_arg = 0;
  VisLightSource_cl *arg1 = (VisLightSource_cl *) 0 ;
  bool result;
  
  SWIG_check_num_args("GetTriggered",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetTriggered",1,"VisLightSource_cl const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisLightSource_cl,0))){
    SWIG_fail_ptr("VisLightSource_cl_GetTriggered",1,SWIGTYPE_p_VisLightSource_cl);
  }
  
  result = (bool)VisLightSource_cl_GetTriggered((VisLightSource_cl const *)arg1);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisLightSource_cl_GetType(lua_State* L) {
  int SWIG_arg = 0;
  VisLightSource_cl *arg1 = (VisLightSource_cl *) 0 ;
  int result;
  
  SWIG_check_num_args("GetType",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetType",1,"VisLightSource_cl const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisLightSource_cl,0))){
    SWIG_fail_ptr("VisLightSource_cl_GetType",1,SWIGTYPE_p_VisLightSource_cl);
  }
  
  result = (int)VisLightSource_cl_GetType((VisLightSource_cl const *)arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisLightSource_cl_SetType(lua_State* L) {
  int SWIG_arg = 0;
  VisLightSource_cl *arg1 = (VisLightSource_cl *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("SetType",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetType",1,"VisLightSource_cl *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SetType",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisLightSource_cl,0))){
    SWIG_fail_ptr("VisLightSource_cl_SetType",1,SWIGTYPE_p_VisLightSource_cl);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  VisLightSource_cl_SetType(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisLightSource_cl_SetCoronaScaleMode(lua_State* L) {
  int SWIG_arg = 0;
  VisLightSource_cl *arg1 = (VisLightSource_cl *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("SetCoronaScaleMode",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetCoronaScaleMode",1,"VisLightSource_cl *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SetCoronaScaleMode",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisLightSource_cl,0))){
    SWIG_fail_ptr("VisLightSource_cl_SetCoronaScaleMode",1,SWIGTYPE_p_VisLightSource_cl);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  VisLightSource_cl_SetCoronaScaleMode(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisLightSource_cl_GetCoronaScaleMode(lua_State* L) {
  int SWIG_arg = 0;
  VisLightSource_cl *arg1 = (VisLightSource_cl *) 0 ;
  int result;
  
  SWIG_check_num_args("GetCoronaScaleMode",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetCoronaScaleMode",1,"VisLightSource_cl *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisLightSource_cl,0))){
    SWIG_fail_ptr("VisLightSource_cl_GetCoronaScaleMode",1,SWIGTYPE_p_VisLightSource_cl);
  }
  
  result = (int)VisLightSource_cl_GetCoronaScaleMode(arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisLightSource_cl_SetCoronaScale(lua_State* L) {
  int SWIG_arg = 0;
  VisLightSource_cl *arg1 = (VisLightSource_cl *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("SetCoronaScale",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetCoronaScale",1,"VisLightSource_cl *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SetCoronaScale",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisLightSource_cl,0))){
    SWIG_fail_ptr("VisLightSource_cl_SetCoronaScale",1,SWIGTYPE_p_VisLightSource_cl);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  VisLightSource_cl_SetCoronaScale(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisLightSource_cl_GetCoronaScale(lua_State* L) {
  int SWIG_arg = 0;
  VisLightSource_cl *arg1 = (VisLightSource_cl *) 0 ;
  float result;
  
  SWIG_check_num_args("GetCoronaScale",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetCoronaScale",1,"VisLightSource_cl *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisLightSource_cl,0))){
    SWIG_fail_ptr("VisLightSource_cl_GetCoronaScale",1,SWIGTYPE_p_VisLightSource_cl);
  }
  
  result = (float)VisLightSource_cl_GetCoronaScale(arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisLightSource_cl_Trigger(lua_State* L) {
  int SWIG_arg = 0;
  VisLightSource_cl *arg1 = (VisLightSource_cl *) 0 ;
  
  SWIG_check_num_args("Trigger",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Trigger",1,"VisLightSource_cl *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisLightSource_cl,0))){
    SWIG_fail_ptr("VisLightSource_cl_Trigger",1,SWIGTYPE_p_VisLightSource_cl);
  }
  
  (arg1)->Trigger();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisLightSource_cl_GetRadius(lua_State* L) {
  int SWIG_arg = 0;
  VisLightSource_cl *arg1 = (VisLightSource_cl *) 0 ;
  float result;
  
  SWIG_check_num_args("GetRadius",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetRadius",1,"VisLightSource_cl const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisLightSource_cl,0))){
    SWIG_fail_ptr("VisLightSource_cl_GetRadius",1,SWIGTYPE_p_VisLightSource_cl);
  }
  
  result = (float)((VisLightSource_cl const *)arg1)->GetRadius();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisLightSource_cl_SetRadius(lua_State* L) {
  int SWIG_arg = 0;
  VisLightSource_cl *arg1 = (VisLightSource_cl *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("SetRadius",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetRadius",1,"VisLightSource_cl *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SetRadius",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisLightSource_cl,0))){
    SWIG_fail_ptr("VisLightSource_cl_SetRadius",1,SWIGTYPE_p_VisLightSource_cl);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->SetRadius(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisLightSource_cl_SetProjectionTexture(lua_State* L) {
  int SWIG_arg = 0;
  VisLightSource_cl *arg1 = (VisLightSource_cl *) 0 ;
  char *arg2 = (char *) 0 ;
  
  SWIG_check_num_args("SetProjectionTexture",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetProjectionTexture",1,"VisLightSource_cl *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("SetProjectionTexture",2,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisLightSource_cl,0))){
    SWIG_fail_ptr("VisLightSource_cl_SetProjectionTexture",1,SWIGTYPE_p_VisLightSource_cl);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  (arg1)->SetProjectionTexture((char const *)arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisLightSource_cl_GetProjectedTextureFileName(lua_State* L) {
  int SWIG_arg = 0;
  VisLightSource_cl *arg1 = (VisLightSource_cl *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("GetProjectedTextureFileName",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetProjectedTextureFileName",1,"VisLightSource_cl const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisLightSource_cl,0))){
    SWIG_fail_ptr("VisLightSource_cl_GetProjectedTextureFileName",1,SWIGTYPE_p_VisLightSource_cl);
  }
  
  result = (char *)((VisLightSource_cl const *)arg1)->GetProjectedTextureFileName();
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisLightSource_cl_WasVisibleInLastFrame(lua_State* L) {
  int SWIG_arg = 0;
  VisLightSource_cl *arg1 = (VisLightSource_cl *) 0 ;
  bool result;
  
  SWIG_check_num_args("WasVisibleInLastFrame",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("WasVisibleInLastFrame",1,"VisLightSource_cl const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisLightSource_cl,0))){
    SWIG_fail_ptr("VisLightSource_cl_WasVisibleInLastFrame",1,SWIGTYPE_p_VisLightSource_cl);
  }
  
  result = (bool)VisLightSource_cl_WasVisibleInLastFrame((VisLightSource_cl const *)arg1);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisLightSource_cl_WasVisibleInAnyLastFrame(lua_State* L) {
  int SWIG_arg = 0;
  VisLightSource_cl *arg1 = (VisLightSource_cl *) 0 ;
  bool result;
  
  SWIG_check_num_args("WasVisibleInAnyLastFrame",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("WasVisibleInAnyLastFrame",1,"VisLightSource_cl const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisLightSource_cl,0))){
    SWIG_fail_ptr("VisLightSource_cl_WasVisibleInAnyLastFrame",1,SWIGTYPE_p_VisLightSource_cl);
  }
  
  result = (bool)VisLightSource_cl_WasVisibleInAnyLastFrame((VisLightSource_cl const *)arg1);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisLightSource_cl_SetVisible(lua_State* L) {
  int SWIG_arg = 0;
  VisLightSource_cl *arg1 = (VisLightSource_cl *) 0 ;
  bool arg2 ;
  
  SWIG_check_num_args("SetVisible",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetVisible",1,"VisLightSource_cl *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("SetVisible",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisLightSource_cl,0))){
    SWIG_fail_ptr("VisLightSource_cl_SetVisible",1,SWIGTYPE_p_VisLightSource_cl);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  VisLightSource_cl_SetVisible(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisLightSource_cl_IsVisible(lua_State* L) {
  int SWIG_arg = 0;
  VisLightSource_cl *arg1 = (VisLightSource_cl *) 0 ;
  bool result;
  
  SWIG_check_num_args("IsVisible",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("IsVisible",1,"VisLightSource_cl *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisLightSource_cl,0))){
    SWIG_fail_ptr("VisLightSource_cl_IsVisible",1,SWIGTYPE_p_VisLightSource_cl);
  }
  
  result = (bool)VisLightSource_cl_IsVisible(arg1);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisLightSource_cl_SetVisibleBitmask(lua_State* L) {
  int SWIG_arg = 0;
  VisLightSource_cl *arg1 = (VisLightSource_cl *) 0 ;
  VBitmask *arg2 = (VBitmask *) 0 ;
  
  SWIG_check_num_args("SetVisibleBitmask",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetVisibleBitmask",1,"VisLightSource_cl *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SetVisibleBitmask",2,"VBitmask *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisLightSource_cl,0))){
    SWIG_fail_ptr("VisLightSource_cl_SetVisibleBitmask",1,SWIGTYPE_p_VisLightSource_cl);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_VBitmask,0))){
    SWIG_fail_ptr("VisLightSource_cl_SetVisibleBitmask",2,SWIGTYPE_p_VBitmask);
  }
  
  VisLightSource_cl_SetVisibleBitmask(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisLightSource_cl_GetVisibleBitmask(lua_State* L) {
  int SWIG_arg = 0;
  VisLightSource_cl *arg1 = (VisLightSource_cl *) 0 ;
  VBitmask result;
  
  SWIG_check_num_args("GetVisibleBitmask",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetVisibleBitmask",1,"VisLightSource_cl const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisLightSource_cl,0))){
    SWIG_fail_ptr("VisLightSource_cl_GetVisibleBitmask",1,SWIGTYPE_p_VisLightSource_cl);
  }
  
  result = VisLightSource_cl_GetVisibleBitmask((VisLightSource_cl const *)arg1);
  {
    VBitmask * resultptr = new VBitmask((const VBitmask &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_VBitmask,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisLightSource_cl_SetLightInfluenceBitmasks(lua_State* L) {
  int SWIG_arg = 0;
  VisLightSource_cl *arg1 = (VisLightSource_cl *) 0 ;
  VBitmask *arg2 = (VBitmask *) 0 ;
  VBitmask *arg3 = (VBitmask *) 0 ;
  
  SWIG_check_num_args("SetLightInfluenceBitmasks",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetLightInfluenceBitmasks",1,"VisLightSource_cl *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SetLightInfluenceBitmasks",2,"VBitmask *");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("SetLightInfluenceBitmasks",3,"VBitmask *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisLightSource_cl,0))){
    SWIG_fail_ptr("VisLightSource_cl_SetLightInfluenceBitmasks",1,SWIGTYPE_p_VisLightSource_cl);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_VBitmask,0))){
    SWIG_fail_ptr("VisLightSource_cl_SetLightInfluenceBitmasks",2,SWIGTYPE_p_VBitmask);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_VBitmask,0))){
    SWIG_fail_ptr("VisLightSource_cl_SetLightInfluenceBitmasks",3,SWIGTYPE_p_VBitmask);
  }
  
  VisLightSource_cl_SetLightInfluenceBitmasks(arg1,arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisLightSource_cl_GetLightInfluenceBitmask__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  VisLightSource_cl *arg1 = (VisLightSource_cl *) 0 ;
  bool arg2 ;
  VBitmask result;
  
  SWIG_check_num_args("GetLightInfluenceBitmask",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetLightInfluenceBitmask",1,"VisLightSource_cl *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("GetLightInfluenceBitmask",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisLightSource_cl,0))){
    SWIG_fail_ptr("VisLightSource_cl_GetLightInfluenceBitmask",1,SWIGTYPE_p_VisLightSource_cl);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  result = VisLightSource_cl_GetLightInfluenceBitmask__SWIG_0(arg1,arg2);
  {
    VBitmask * resultptr = new VBitmask((const VBitmask &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_VBitmask,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisLightSource_cl_GetLightInfluenceBitmask__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  VisLightSource_cl *arg1 = (VisLightSource_cl *) 0 ;
  VBitmask result;
  
  SWIG_check_num_args("GetLightInfluenceBitmask",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetLightInfluenceBitmask",1,"VisLightSource_cl *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisLightSource_cl,0))){
    SWIG_fail_ptr("VisLightSource_cl_GetLightInfluenceBitmask",1,SWIGTYPE_p_VisLightSource_cl);
  }
  
  result = VisLightSource_cl_GetLightInfluenceBitmask__SWIG_0(arg1);
  {
    VBitmask * resultptr = new VBitmask((const VBitmask &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_VBitmask,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisLightSource_cl_GetLightInfluenceBitmask(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VisLightSource_cl, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_VisLightSource_cl_GetLightInfluenceBitmask__SWIG_1(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VisLightSource_cl, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isboolean(L,argv[1]);
      }
      if (_v) {
        return _wrap_VisLightSource_cl_GetLightInfluenceBitmask__SWIG_0(L);
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'VisLightSource_cl_GetLightInfluenceBitmask'\n"
    "  Possible C/C++ prototypes are:\n"
    "    GetLightInfluenceBitmask(VisLightSource_cl *,bool)\n"
    "    GetLightInfluenceBitmask(VisLightSource_cl *)\n");
  lua_error(L);return 0;
}


static int _wrap_VisLightSource_cl_GetBoundingBox(lua_State* L) {
  int SWIG_arg = 0;
  VisLightSource_cl *arg1 = (VisLightSource_cl *) 0 ;
  SwigValueWrapper< hkvAlignedBBox > result;
  
  SWIG_check_num_args("GetBoundingBox",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetBoundingBox",1,"VisLightSource_cl *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisLightSource_cl,0))){
    SWIG_fail_ptr("VisLightSource_cl_GetBoundingBox",1,SWIGTYPE_p_VisLightSource_cl);
  }
  
  result = VisLightSource_cl_GetBoundingBox(arg1);
  {
    hkvAlignedBBox * resultptr = new hkvAlignedBBox((const hkvAlignedBBox &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_hkvAlignedBBox,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisLightSource_cl_SetColorCurve__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  VisLightSource_cl *arg1 = (VisLightSource_cl *) 0 ;
  char *arg2 = (char *) 0 ;
  float arg3 ;
  float arg4 ;
  
  SWIG_check_num_args("SetColorCurve",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetColorCurve",1,"VisLightSource_cl *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("SetColorCurve",2,"char const *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("SetColorCurve",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("SetColorCurve",4,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisLightSource_cl,0))){
    SWIG_fail_ptr("VisLightSource_cl_SetColorCurve",1,SWIGTYPE_p_VisLightSource_cl);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4);
  VisLightSource_cl_SetColorCurve__SWIG_0(arg1,(char const *)arg2,arg3,arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisLightSource_cl_SetColorCurve__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  VisLightSource_cl *arg1 = (VisLightSource_cl *) 0 ;
  char *arg2 = (char *) 0 ;
  float arg3 ;
  
  SWIG_check_num_args("SetColorCurve",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetColorCurve",1,"VisLightSource_cl *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("SetColorCurve",2,"char const *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("SetColorCurve",3,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisLightSource_cl,0))){
    SWIG_fail_ptr("VisLightSource_cl_SetColorCurve",1,SWIGTYPE_p_VisLightSource_cl);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  VisLightSource_cl_SetColorCurve__SWIG_0(arg1,(char const *)arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisLightSource_cl_SetColorCurve__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  VisLightSource_cl *arg1 = (VisLightSource_cl *) 0 ;
  char *arg2 = (char *) 0 ;
  
  SWIG_check_num_args("SetColorCurve",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetColorCurve",1,"VisLightSource_cl *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("SetColorCurve",2,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisLightSource_cl,0))){
    SWIG_fail_ptr("VisLightSource_cl_SetColorCurve",1,SWIGTYPE_p_VisLightSource_cl);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  VisLightSource_cl_SetColorCurve__SWIG_0(arg1,(char const *)arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisLightSource_cl_SetColorCurve__SWIG_3(lua_State* L) {
  int SWIG_arg = 0;
  VisLightSource_cl *arg1 = (VisLightSource_cl *) 0 ;
  
  SWIG_check_num_args("SetColorCurve",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetColorCurve",1,"VisLightSource_cl *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisLightSource_cl,0))){
    SWIG_fail_ptr("VisLightSource_cl_SetColorCurve",1,SWIGTYPE_p_VisLightSource_cl);
  }
  
  VisLightSource_cl_SetColorCurve__SWIG_0(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisLightSource_cl_SetColorCurve(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VisLightSource_cl, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_VisLightSource_cl_SetColorCurve__SWIG_3(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VisLightSource_cl, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = SWIG_lua_isnilstring(L,argv[1]);
      }
      if (_v) {
        return _wrap_VisLightSource_cl_SetColorCurve__SWIG_2(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VisLightSource_cl, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = SWIG_lua_isnilstring(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          return _wrap_VisLightSource_cl_SetColorCurve__SWIG_1(L);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VisLightSource_cl, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = SWIG_lua_isnilstring(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_VisLightSource_cl_SetColorCurve__SWIG_0(L);
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'VisLightSource_cl_SetColorCurve'\n"
    "  Possible C/C++ prototypes are:\n"
    "    SetColorCurve(VisLightSource_cl *,char const *,float,float)\n"
    "    SetColorCurve(VisLightSource_cl *,char const *,float)\n"
    "    SetColorCurve(VisLightSource_cl *,char const *)\n"
    "    SetColorCurve(VisLightSource_cl *)\n");
  lua_error(L);return 0;
}


static swig_lua_method swig_VisLightSource_cl_methods[] = {
    { "__tostring",VisLightSource_cl_ToString},
    { "__concat",VisLightSource_cl_Concat},
    {"Remove", _wrap_VisLightSource_cl_Remove}, 
    {"SetColor", _wrap_VisLightSource_cl_SetColor}, 
    {"GetColor", _wrap_VisLightSource_cl_GetColor}, 
    {"SetIntensity", _wrap_VisLightSource_cl_SetIntensity}, 
    {"GetIntensity", _wrap_VisLightSource_cl_GetIntensity}, 
    {"SetMultiplier", _wrap_VisLightSource_cl_SetMultiplier}, 
    {"GetMultiplier", _wrap_VisLightSource_cl_GetMultiplier}, 
    {"SetProjectionAngle", _wrap_VisLightSource_cl_SetProjectionAngle}, 
    {"GetProjectionAngle", _wrap_VisLightSource_cl_GetProjectionAngle}, 
    {"SetCoronaTexture", _wrap_VisLightSource_cl_SetCoronaTexture}, 
    {"SetupAppearance", _wrap_VisLightSource_cl_SetupAppearance}, 
    {"GetTriggered", _wrap_VisLightSource_cl_GetTriggered}, 
    {"GetType", _wrap_VisLightSource_cl_GetType}, 
    {"SetType", _wrap_VisLightSource_cl_SetType}, 
    {"SetCoronaScaleMode", _wrap_VisLightSource_cl_SetCoronaScaleMode}, 
    {"GetCoronaScaleMode", _wrap_VisLightSource_cl_GetCoronaScaleMode}, 
    {"SetCoronaScale", _wrap_VisLightSource_cl_SetCoronaScale}, 
    {"GetCoronaScale", _wrap_VisLightSource_cl_GetCoronaScale}, 
    {"Trigger", _wrap_VisLightSource_cl_Trigger}, 
    {"GetRadius", _wrap_VisLightSource_cl_GetRadius}, 
    {"SetRadius", _wrap_VisLightSource_cl_SetRadius}, 
    {"SetProjectionTexture", _wrap_VisLightSource_cl_SetProjectionTexture}, 
    {"GetProjectedTextureFileName", _wrap_VisLightSource_cl_GetProjectedTextureFileName}, 
    {"WasVisibleInLastFrame", _wrap_VisLightSource_cl_WasVisibleInLastFrame}, 
    {"WasVisibleInAnyLastFrame", _wrap_VisLightSource_cl_WasVisibleInAnyLastFrame}, 
    {"SetVisible", _wrap_VisLightSource_cl_SetVisible}, 
    {"IsVisible", _wrap_VisLightSource_cl_IsVisible}, 
    {"SetVisibleBitmask", _wrap_VisLightSource_cl_SetVisibleBitmask}, 
    {"GetVisibleBitmask", _wrap_VisLightSource_cl_GetVisibleBitmask}, 
    {"SetLightInfluenceBitmasks", _wrap_VisLightSource_cl_SetLightInfluenceBitmasks}, 
    {"GetLightInfluenceBitmask", _wrap_VisLightSource_cl_GetLightInfluenceBitmask}, 
    {"GetBoundingBox", _wrap_VisLightSource_cl_GetBoundingBox}, 
    {"SetColorCurve", _wrap_VisLightSource_cl_SetColorCurve}, 
    {0,0}
};
static swig_lua_attribute swig_VisLightSource_cl_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_VisLightSource_cl_bases[] = {0,0};
static const char *swig_VisLightSource_cl_base_names[] = {"VisObject3D_cl *",0};
static swig_lua_class _wrap_class_VisLightSource_cl = { "VisLightSource_cl", &SWIGTYPE_p_VisLightSource_cl,0,0, swig_VisLightSource_cl_methods, swig_VisLightSource_cl_attributes, swig_VisLightSource_cl_bases, swig_VisLightSource_cl_base_names };

static int _wrap_VisStaticMeshInstance_cl_GetBoundingBox(lua_State* L) {
  int SWIG_arg = 0;
  VisStaticMeshInstance_cl *arg1 = (VisStaticMeshInstance_cl *) 0 ;
  SwigValueWrapper< hkvAlignedBBox > result;
  
  SWIG_check_num_args("GetBoundingBox",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetBoundingBox",1,"VisStaticMeshInstance_cl const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisStaticMeshInstance_cl,0))){
    SWIG_fail_ptr("VisStaticMeshInstance_cl_GetBoundingBox",1,SWIGTYPE_p_VisStaticMeshInstance_cl);
  }
  
  result = VisStaticMeshInstance_cl_GetBoundingBox((VisStaticMeshInstance_cl const *)arg1);
  {
    hkvAlignedBBox * resultptr = new hkvAlignedBBox((const hkvAlignedBBox &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_hkvAlignedBBox,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisStaticMeshInstance_cl_GetPosition(lua_State* L) {
  int SWIG_arg = 0;
  VisStaticMeshInstance_cl *arg1 = (VisStaticMeshInstance_cl *) 0 ;
  SwigValueWrapper< hkvVec3 > result;
  
  SWIG_check_num_args("GetPosition",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetPosition",1,"VisStaticMeshInstance_cl *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisStaticMeshInstance_cl,0))){
    SWIG_fail_ptr("VisStaticMeshInstance_cl_GetPosition",1,SWIGTYPE_p_VisStaticMeshInstance_cl);
  }
  
  result = VisStaticMeshInstance_cl_GetPosition(arg1);
  {
    hkvVec3 * resultptr = new hkvVec3((const hkvVec3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_hkvVec3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisStaticMeshInstance_cl_GetRotation(lua_State* L) {
  int SWIG_arg = 0;
  VisStaticMeshInstance_cl *arg1 = (VisStaticMeshInstance_cl *) 0 ;
  SwigValueWrapper< hkvMat3 > result;
  
  SWIG_check_num_args("GetRotation",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetRotation",1,"VisStaticMeshInstance_cl *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisStaticMeshInstance_cl,0))){
    SWIG_fail_ptr("VisStaticMeshInstance_cl_GetRotation",1,SWIGTYPE_p_VisStaticMeshInstance_cl);
  }
  
  result = VisStaticMeshInstance_cl_GetRotation(arg1);
  {
    hkvMat3 * resultptr = new hkvMat3((const hkvMat3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_hkvMat3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisStaticMeshInstance_cl_SetVisibleBitmask(lua_State* L) {
  int SWIG_arg = 0;
  VisStaticMeshInstance_cl *arg1 = (VisStaticMeshInstance_cl *) 0 ;
  VBitmask *arg2 = (VBitmask *) 0 ;
  
  SWIG_check_num_args("SetVisibleBitmask",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetVisibleBitmask",1,"VisStaticMeshInstance_cl *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SetVisibleBitmask",2,"VBitmask *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisStaticMeshInstance_cl,0))){
    SWIG_fail_ptr("VisStaticMeshInstance_cl_SetVisibleBitmask",1,SWIGTYPE_p_VisStaticMeshInstance_cl);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_VBitmask,0))){
    SWIG_fail_ptr("VisStaticMeshInstance_cl_SetVisibleBitmask",2,SWIGTYPE_p_VBitmask);
  }
  
  VisStaticMeshInstance_cl_SetVisibleBitmask(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisStaticMeshInstance_cl_SetCollisionBitmask(lua_State* L) {
  int SWIG_arg = 0;
  VisStaticMeshInstance_cl *arg1 = (VisStaticMeshInstance_cl *) 0 ;
  VBitmask *arg2 = (VBitmask *) 0 ;
  
  SWIG_check_num_args("SetCollisionBitmask",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetCollisionBitmask",1,"VisStaticMeshInstance_cl *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SetCollisionBitmask",2,"VBitmask *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisStaticMeshInstance_cl,0))){
    SWIG_fail_ptr("VisStaticMeshInstance_cl_SetCollisionBitmask",1,SWIGTYPE_p_VisStaticMeshInstance_cl);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_VBitmask,0))){
    SWIG_fail_ptr("VisStaticMeshInstance_cl_SetCollisionBitmask",2,SWIGTYPE_p_VBitmask);
  }
  
  VisStaticMeshInstance_cl_SetCollisionBitmask(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisStaticMeshInstance_cl_GetCollisionBitmask(lua_State* L) {
  int SWIG_arg = 0;
  VisStaticMeshInstance_cl *arg1 = (VisStaticMeshInstance_cl *) 0 ;
  VBitmask result;
  
  SWIG_check_num_args("GetCollisionBitmask",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetCollisionBitmask",1,"VisStaticMeshInstance_cl const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisStaticMeshInstance_cl,0))){
    SWIG_fail_ptr("VisStaticMeshInstance_cl_GetCollisionBitmask",1,SWIGTYPE_p_VisStaticMeshInstance_cl);
  }
  
  result = VisStaticMeshInstance_cl_GetCollisionBitmask((VisStaticMeshInstance_cl const *)arg1);
  {
    VBitmask * resultptr = new VBitmask((const VBitmask &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_VBitmask,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisStaticMeshInstance_cl_Remove(lua_State* L) {
  int SWIG_arg = 0;
  VisStaticMeshInstance_cl *arg1 = (VisStaticMeshInstance_cl *) 0 ;
  
  SWIG_check_num_args("DisposeObject",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("DisposeObject",1,"VisStaticMeshInstance_cl *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisStaticMeshInstance_cl,0))){
    SWIG_fail_ptr("VisStaticMeshInstance_cl_Remove",1,SWIGTYPE_p_VisStaticMeshInstance_cl);
  }
  
  (arg1)->DisposeObject();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisStaticMeshInstance_cl_IsLightmapped(lua_State* L) {
  int SWIG_arg = 0;
  VisStaticMeshInstance_cl *arg1 = (VisStaticMeshInstance_cl *) 0 ;
  bool result;
  
  SWIG_check_num_args("IsLightmapped",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("IsLightmapped",1,"VisStaticMeshInstance_cl const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisStaticMeshInstance_cl,0))){
    SWIG_fail_ptr("VisStaticMeshInstance_cl_IsLightmapped",1,SWIGTYPE_p_VisStaticMeshInstance_cl);
  }
  
  result = (bool)((VisStaticMeshInstance_cl const *)arg1)->IsLightmapped();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static swig_lua_method swig_VisStaticMeshInstance_cl_methods[] = {
    { "__tostring",VisStaticMeshInstance_cl_ToString},
    { "__concat",VisStaticMeshInstance_cl_Concat},
    {"GetBoundingBox", _wrap_VisStaticMeshInstance_cl_GetBoundingBox}, 
    {"GetPosition", _wrap_VisStaticMeshInstance_cl_GetPosition}, 
    {"GetRotation", _wrap_VisStaticMeshInstance_cl_GetRotation}, 
    {"SetVisibleBitmask", _wrap_VisStaticMeshInstance_cl_SetVisibleBitmask}, 
    {"SetCollisionBitmask", _wrap_VisStaticMeshInstance_cl_SetCollisionBitmask}, 
    {"GetCollisionBitmask", _wrap_VisStaticMeshInstance_cl_GetCollisionBitmask}, 
    {"Remove", _wrap_VisStaticMeshInstance_cl_Remove}, 
    {"IsLightmapped", _wrap_VisStaticMeshInstance_cl_IsLightmapped}, 
    {0,0}
};
static swig_lua_attribute swig_VisStaticMeshInstance_cl_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_VisStaticMeshInstance_cl_bases[] = {0,0,0};
static const char *swig_VisStaticMeshInstance_cl_base_names[] = {"VisTypedEngineObject_cl *","VisObjectKey_cl *",0};
static swig_lua_class _wrap_class_VisStaticMeshInstance_cl = { "VisStaticMeshInstance_cl", &SWIGTYPE_p_VisStaticMeshInstance_cl,0,0, swig_VisStaticMeshInstance_cl_methods, swig_VisStaticMeshInstance_cl_attributes, swig_VisStaticMeshInstance_cl_bases, swig_VisStaticMeshInstance_cl_base_names };

static int _wrap_VisSurface_cl_GetDiffuseTexture(lua_State* L) {
  int SWIG_arg = 0;
  VisSurface_cl *arg1 = (VisSurface_cl *) 0 ;
  VTextureObject *result = 0 ;
  
  SWIG_check_num_args("GetBaseTextureObject",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetBaseTextureObject",1,"VisSurface_cl const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisSurface_cl,0))){
    SWIG_fail_ptr("VisSurface_cl_GetDiffuseTexture",1,SWIGTYPE_p_VisSurface_cl);
  }
  
  result = (VTextureObject *)((VisSurface_cl const *)arg1)->GetBaseTextureObject();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_VTextureObject,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisSurface_cl_GetNormalTexture(lua_State* L) {
  int SWIG_arg = 0;
  VisSurface_cl *arg1 = (VisSurface_cl *) 0 ;
  VTextureObject *result = 0 ;
  
  SWIG_check_num_args("GetNormalMapTextureObject",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetNormalMapTextureObject",1,"VisSurface_cl const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisSurface_cl,0))){
    SWIG_fail_ptr("VisSurface_cl_GetNormalTexture",1,SWIGTYPE_p_VisSurface_cl);
  }
  
  result = (VTextureObject *)((VisSurface_cl const *)arg1)->GetNormalMapTextureObject();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_VTextureObject,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisSurface_cl_GetSpecularTexture(lua_State* L) {
  int SWIG_arg = 0;
  VisSurface_cl *arg1 = (VisSurface_cl *) 0 ;
  VTextureObject *result = 0 ;
  
  SWIG_check_num_args("GetSpecularMapTextureObject",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetSpecularMapTextureObject",1,"VisSurface_cl const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisSurface_cl,0))){
    SWIG_fail_ptr("VisSurface_cl_GetSpecularTexture",1,SWIGTYPE_p_VisSurface_cl);
  }
  
  result = (VTextureObject *)((VisSurface_cl const *)arg1)->GetSpecularMapTextureObject();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_VTextureObject,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisSurface_cl_SetDiffuseTexture(lua_State* L) {
  int SWIG_arg = 0;
  VisSurface_cl *arg1 = (VisSurface_cl *) 0 ;
  VTextureObject *arg2 = (VTextureObject *) 0 ;
  
  SWIG_check_num_args("SetBaseTexture",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetBaseTexture",1,"VisSurface_cl *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SetBaseTexture",2,"VTextureObject *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisSurface_cl,0))){
    SWIG_fail_ptr("VisSurface_cl_SetDiffuseTexture",1,SWIGTYPE_p_VisSurface_cl);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_VTextureObject,0))){
    SWIG_fail_ptr("VisSurface_cl_SetDiffuseTexture",2,SWIGTYPE_p_VTextureObject);
  }
  
  (arg1)->SetBaseTexture(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisSurface_cl_GetAuxiliaryTextureCount(lua_State* L) {
  int SWIG_arg = 0;
  VisSurface_cl *arg1 = (VisSurface_cl *) 0 ;
  int result;
  
  SWIG_check_num_args("GetAuxiliaryTextureCount",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetAuxiliaryTextureCount",1,"VisSurface_cl const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisSurface_cl,0))){
    SWIG_fail_ptr("VisSurface_cl_GetAuxiliaryTextureCount",1,SWIGTYPE_p_VisSurface_cl);
  }
  
  result = (int)((VisSurface_cl const *)arg1)->GetAuxiliaryTextureCount();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisSurface_cl_GetAuxiliaryTexture(lua_State* L) {
  int SWIG_arg = 0;
  VisSurface_cl *arg1 = (VisSurface_cl *) 0 ;
  int arg2 ;
  VTextureObject *result = 0 ;
  
  SWIG_check_num_args("GetAuxiliaryTexture",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetAuxiliaryTexture",1,"VisSurface_cl const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("GetAuxiliaryTexture",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisSurface_cl,0))){
    SWIG_fail_ptr("VisSurface_cl_GetAuxiliaryTexture",1,SWIGTYPE_p_VisSurface_cl);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  result = (VTextureObject *)((VisSurface_cl const *)arg1)->GetAuxiliaryTexture(arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_VTextureObject,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisSurface_cl_SetAuxiliaryTexture(lua_State* L) {
  int SWIG_arg = 0;
  VisSurface_cl *arg1 = (VisSurface_cl *) 0 ;
  int arg2 ;
  VTextureObject *arg3 = (VTextureObject *) 0 ;
  
  SWIG_check_num_args("SetAuxiliaryTexture",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetAuxiliaryTexture",1,"VisSurface_cl const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SetAuxiliaryTexture",2,"int");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("SetAuxiliaryTexture",3,"VTextureObject *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisSurface_cl,0))){
    SWIG_fail_ptr("VisSurface_cl_SetAuxiliaryTexture",1,SWIGTYPE_p_VisSurface_cl);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_VTextureObject,0))){
    SWIG_fail_ptr("VisSurface_cl_SetAuxiliaryTexture",3,SWIGTYPE_p_VTextureObject);
  }
  
  ((VisSurface_cl const *)arg1)->SetAuxiliaryTexture(arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisSurface_cl_GetIndex(lua_State* L) {
  int SWIG_arg = 0;
  VisSurface_cl *arg1 = (VisSurface_cl *) 0 ;
  int result;
  
  SWIG_check_num_args("GetIndex",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetIndex",1,"VisSurface_cl const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisSurface_cl,0))){
    SWIG_fail_ptr("VisSurface_cl_GetIndex",1,SWIGTYPE_p_VisSurface_cl);
  }
  
  result = (int)((VisSurface_cl const *)arg1)->GetIndex();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisSurface_cl_GetName(lua_State* L) {
  int SWIG_arg = 0;
  VisSurface_cl *arg1 = (VisSurface_cl *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("GetName",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetName",1,"VisSurface_cl const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisSurface_cl,0))){
    SWIG_fail_ptr("VisSurface_cl_GetName",1,SWIGTYPE_p_VisSurface_cl);
  }
  
  result = (char *)((VisSurface_cl const *)arg1)->GetName();
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisSurface_cl_SetName(lua_State* L) {
  int SWIG_arg = 0;
  VisSurface_cl *arg1 = (VisSurface_cl *) 0 ;
  char *arg2 = (char *) 0 ;
  
  SWIG_check_num_args("SetName",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetName",1,"VisSurface_cl *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("SetName",2,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisSurface_cl,0))){
    SWIG_fail_ptr("VisSurface_cl_SetName",1,SWIGTYPE_p_VisSurface_cl);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  (arg1)->SetName((char const *)arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisSurface_cl_IsTranslucent(lua_State* L) {
  int SWIG_arg = 0;
  VisSurface_cl *arg1 = (VisSurface_cl *) 0 ;
  bool result;
  
  SWIG_check_num_args("IsTranslucent",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("IsTranslucent",1,"VisSurface_cl *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisSurface_cl,0))){
    SWIG_fail_ptr("VisSurface_cl_IsTranslucent",1,SWIGTYPE_p_VisSurface_cl);
  }
  
  result = (bool)(arg1)->IsTranslucent();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisSurface_cl_IsLightMapped(lua_State* L) {
  int SWIG_arg = 0;
  VisSurface_cl *arg1 = (VisSurface_cl *) 0 ;
  bool result;
  
  SWIG_check_num_args("IsLightMapped",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("IsLightMapped",1,"VisSurface_cl const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisSurface_cl,0))){
    SWIG_fail_ptr("VisSurface_cl_IsLightMapped",1,SWIGTYPE_p_VisSurface_cl);
  }
  
  result = (bool)((VisSurface_cl const *)arg1)->IsLightMapped();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisSurface_cl_IsLightmappingSupported(lua_State* L) {
  int SWIG_arg = 0;
  VisSurface_cl *arg1 = (VisSurface_cl *) 0 ;
  bool result;
  
  SWIG_check_num_args("IsLightmappingSupported",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("IsLightmappingSupported",1,"VisSurface_cl const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisSurface_cl,0))){
    SWIG_fail_ptr("VisSurface_cl_IsLightmappingSupported",1,SWIGTYPE_p_VisSurface_cl);
  }
  
  result = (bool)((VisSurface_cl const *)arg1)->IsLightmappingSupported();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisSurface_cl_IsDoubleSided(lua_State* L) {
  int SWIG_arg = 0;
  VisSurface_cl *arg1 = (VisSurface_cl *) 0 ;
  bool result;
  
  SWIG_check_num_args("IsDoubleSided",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("IsDoubleSided",1,"VisSurface_cl const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisSurface_cl,0))){
    SWIG_fail_ptr("VisSurface_cl_IsDoubleSided",1,SWIGTYPE_p_VisSurface_cl);
  }
  
  result = (bool)((VisSurface_cl const *)arg1)->IsDoubleSided();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisSurface_cl_IsFullbright(lua_State* L) {
  int SWIG_arg = 0;
  VisSurface_cl *arg1 = (VisSurface_cl *) 0 ;
  bool result;
  
  SWIG_check_num_args("IsFullbright",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("IsFullbright",1,"VisSurface_cl const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisSurface_cl,0))){
    SWIG_fail_ptr("VisSurface_cl_IsFullbright",1,SWIGTYPE_p_VisSurface_cl);
  }
  
  result = (bool)((VisSurface_cl const *)arg1)->IsFullbright();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisSurface_cl_GetAmbientColor(lua_State* L) {
  int SWIG_arg = 0;
  VisSurface_cl *arg1 = (VisSurface_cl *) 0 ;
  VColorRef result;
  
  SWIG_check_num_args("GetAmbientColor",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetAmbientColor",1,"VisSurface_cl const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisSurface_cl,0))){
    SWIG_fail_ptr("VisSurface_cl_GetAmbientColor",1,SWIGTYPE_p_VisSurface_cl);
  }
  
  result = ((VisSurface_cl const *)arg1)->GetAmbientColor();
  {
    VColorRef * resultptr = new VColorRef((const VColorRef &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_VColorRef,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisSurface_cl_SetAmbientColor(lua_State* L) {
  int SWIG_arg = 0;
  VisSurface_cl *arg1 = (VisSurface_cl *) 0 ;
  VColorRef *arg2 = 0 ;
  
  SWIG_check_num_args("SetAmbientColor",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetAmbientColor",1,"VisSurface_cl *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("SetAmbientColor",2,"VColorRef const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisSurface_cl,0))){
    SWIG_fail_ptr("VisSurface_cl_SetAmbientColor",1,SWIGTYPE_p_VisSurface_cl);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_VColorRef,0))){
    SWIG_fail_ptr("VisSurface_cl_SetAmbientColor",2,SWIGTYPE_p_VColorRef);
  }
  
  (arg1)->SetAmbientColor((VColorRef const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisSurface_cl_GetSpecularMultiplier(lua_State* L) {
  int SWIG_arg = 0;
  VisSurface_cl *arg1 = (VisSurface_cl *) 0 ;
  float result;
  
  SWIG_check_num_args("GetSpecularMultiplier",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetSpecularMultiplier",1,"VisSurface_cl const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisSurface_cl,0))){
    SWIG_fail_ptr("VisSurface_cl_GetSpecularMultiplier",1,SWIGTYPE_p_VisSurface_cl);
  }
  
  result = (float)((VisSurface_cl const *)arg1)->GetSpecularMultiplier();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisSurface_cl_SetSpecularMultiplier(lua_State* L) {
  int SWIG_arg = 0;
  VisSurface_cl *arg1 = (VisSurface_cl *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("SetSpecularMultiplier",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetSpecularMultiplier",1,"VisSurface_cl *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SetSpecularMultiplier",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisSurface_cl,0))){
    SWIG_fail_ptr("VisSurface_cl_SetSpecularMultiplier",1,SWIGTYPE_p_VisSurface_cl);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->SetSpecularMultiplier(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisSurface_cl_GetSpecularExponent(lua_State* L) {
  int SWIG_arg = 0;
  VisSurface_cl *arg1 = (VisSurface_cl *) 0 ;
  float result;
  
  SWIG_check_num_args("GetSpecularExponent",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetSpecularExponent",1,"VisSurface_cl const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisSurface_cl,0))){
    SWIG_fail_ptr("VisSurface_cl_GetSpecularExponent",1,SWIGTYPE_p_VisSurface_cl);
  }
  
  result = (float)((VisSurface_cl const *)arg1)->GetSpecularExponent();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisSurface_cl_SetSpecularExponent(lua_State* L) {
  int SWIG_arg = 0;
  VisSurface_cl *arg1 = (VisSurface_cl *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("SetSpecularExponent",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetSpecularExponent",1,"VisSurface_cl *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SetSpecularExponent",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisSurface_cl,0))){
    SWIG_fail_ptr("VisSurface_cl_SetSpecularExponent",1,SWIGTYPE_p_VisSurface_cl);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->SetSpecularExponent(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisSurface_cl_GetAlphaTestThreshold(lua_State* L) {
  int SWIG_arg = 0;
  VisSurface_cl *arg1 = (VisSurface_cl *) 0 ;
  float result;
  
  SWIG_check_num_args("GetAlphaTestThreshold",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetAlphaTestThreshold",1,"VisSurface_cl const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisSurface_cl,0))){
    SWIG_fail_ptr("VisSurface_cl_GetAlphaTestThreshold",1,SWIGTYPE_p_VisSurface_cl);
  }
  
  result = (float)((VisSurface_cl const *)arg1)->GetAlphaTestThreshold();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisSurface_cl_SetAlphaTestThreshold(lua_State* L) {
  int SWIG_arg = 0;
  VisSurface_cl *arg1 = (VisSurface_cl *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("SetAlphaTestThreshold",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetAlphaTestThreshold",1,"VisSurface_cl *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SetAlphaTestThreshold",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisSurface_cl,0))){
    SWIG_fail_ptr("VisSurface_cl_SetAlphaTestThreshold",1,SWIGTYPE_p_VisSurface_cl);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->SetAlphaTestThreshold(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisSurface_cl_SetAutoShaderMode(lua_State* L) {
  int SWIG_arg = 0;
  VisSurface_cl *arg1 = (VisSurface_cl *) 0 ;
  bool arg2 ;
  
  SWIG_check_num_args("SetAutoShaderMode",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetAutoShaderMode",1,"VisSurface_cl *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("SetAutoShaderMode",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisSurface_cl,0))){
    SWIG_fail_ptr("VisSurface_cl_SetAutoShaderMode",1,SWIGTYPE_p_VisSurface_cl);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  VisSurface_cl_SetAutoShaderMode(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisSurface_cl_HasAutoShaderMode(lua_State* L) {
  int SWIG_arg = 0;
  VisSurface_cl *arg1 = (VisSurface_cl *) 0 ;
  bool result;
  
  SWIG_check_num_args("HasAutoShaderMode",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("HasAutoShaderMode",1,"VisSurface_cl *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisSurface_cl,0))){
    SWIG_fail_ptr("VisSurface_cl_HasAutoShaderMode",1,SWIGTYPE_p_VisSurface_cl);
  }
  
  result = (bool)VisSurface_cl_HasAutoShaderMode(arg1);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisSurface_cl___eq(lua_State* L) {
  int SWIG_arg = 0;
  VisSurface_cl *arg1 = (VisSurface_cl *) 0 ;
  VisSurface_cl *arg2 = 0 ;
  bool result;
  
  SWIG_check_num_args("operator ==",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("operator ==",1,"VisSurface_cl *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("operator ==",2,"VisSurface_cl const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisSurface_cl,0))){
    SWIG_fail_ptr("VisSurface_cl___eq",1,SWIGTYPE_p_VisSurface_cl);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_VisSurface_cl,0))){
    SWIG_fail_ptr("VisSurface_cl___eq",2,SWIGTYPE_p_VisSurface_cl);
  }
  
  result = (bool)VisSurface_cl_operator_Se__Se_(arg1,(VisSurface_cl const &)*arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static swig_lua_method swig_VisSurface_cl_methods[] = {
    { "__tostring",VisSurface_cl_ToString},
    { "GetTextureLocations",VisSurface_cl_GetTextureLocations},
    { "__concat",VisSurface_cl_Concat},
    {"GetDiffuseTexture", _wrap_VisSurface_cl_GetDiffuseTexture}, 
    {"GetNormalTexture", _wrap_VisSurface_cl_GetNormalTexture}, 
    {"GetSpecularTexture", _wrap_VisSurface_cl_GetSpecularTexture}, 
    {"SetDiffuseTexture", _wrap_VisSurface_cl_SetDiffuseTexture}, 
    {"GetAuxiliaryTextureCount", _wrap_VisSurface_cl_GetAuxiliaryTextureCount}, 
    {"GetAuxiliaryTexture", _wrap_VisSurface_cl_GetAuxiliaryTexture}, 
    {"SetAuxiliaryTexture", _wrap_VisSurface_cl_SetAuxiliaryTexture}, 
    {"GetIndex", _wrap_VisSurface_cl_GetIndex}, 
    {"GetName", _wrap_VisSurface_cl_GetName}, 
    {"SetName", _wrap_VisSurface_cl_SetName}, 
    {"IsTranslucent", _wrap_VisSurface_cl_IsTranslucent}, 
    {"IsLightMapped", _wrap_VisSurface_cl_IsLightMapped}, 
    {"IsLightmappingSupported", _wrap_VisSurface_cl_IsLightmappingSupported}, 
    {"IsDoubleSided", _wrap_VisSurface_cl_IsDoubleSided}, 
    {"IsFullbright", _wrap_VisSurface_cl_IsFullbright}, 
    {"GetAmbientColor", _wrap_VisSurface_cl_GetAmbientColor}, 
    {"SetAmbientColor", _wrap_VisSurface_cl_SetAmbientColor}, 
    {"GetSpecularMultiplier", _wrap_VisSurface_cl_GetSpecularMultiplier}, 
    {"SetSpecularMultiplier", _wrap_VisSurface_cl_SetSpecularMultiplier}, 
    {"GetSpecularExponent", _wrap_VisSurface_cl_GetSpecularExponent}, 
    {"SetSpecularExponent", _wrap_VisSurface_cl_SetSpecularExponent}, 
    {"GetAlphaTestThreshold", _wrap_VisSurface_cl_GetAlphaTestThreshold}, 
    {"SetAlphaTestThreshold", _wrap_VisSurface_cl_SetAlphaTestThreshold}, 
    {"SetAutoShaderMode", _wrap_VisSurface_cl_SetAutoShaderMode}, 
    {"HasAutoShaderMode", _wrap_VisSurface_cl_HasAutoShaderMode}, 
    {"__eq", _wrap_VisSurface_cl___eq}, 
    {0,0}
};
static swig_lua_attribute swig_VisSurface_cl_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_VisSurface_cl_bases[] = {0};
static const char *swig_VisSurface_cl_base_names[] = {0};
static swig_lua_class _wrap_class_VisSurface_cl = { "VisSurface_cl", &SWIGTYPE_p_VisSurface_cl,0,0, swig_VisSurface_cl_methods, swig_VisSurface_cl_attributes, swig_VisSurface_cl_bases, swig_VisSurface_cl_base_names };

static int _wrap_VisPath_cl_Remove(lua_State* L) {
  int SWIG_arg = 0;
  VisPath_cl *arg1 = (VisPath_cl *) 0 ;
  
  SWIG_check_num_args("DisposeObject",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("DisposeObject",1,"VisPath_cl *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisPath_cl,0))){
    SWIG_fail_ptr("VisPath_cl_Remove",1,SWIGTYPE_p_VisPath_cl);
  }
  
  (arg1)->DisposeObject();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisPath_cl_AddPathNode__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  VisPath_cl *arg1 = (VisPath_cl *) 0 ;
  VisPathNode_cl *arg2 = (VisPathNode_cl *) 0 ;
  
  SWIG_check_num_args("AddPathNode",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("AddPathNode",1,"VisPath_cl *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("AddPathNode",2,"VisPathNode_cl *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisPath_cl,0))){
    SWIG_fail_ptr("VisPath_cl_AddPathNode",1,SWIGTYPE_p_VisPath_cl);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_VisPathNode_cl,0))){
    SWIG_fail_ptr("VisPath_cl_AddPathNode",2,SWIGTYPE_p_VisPathNode_cl);
  }
  
  (arg1)->AddPathNode(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisPath_cl_DeleteAllPathNodes(lua_State* L) {
  int SWIG_arg = 0;
  VisPath_cl *arg1 = (VisPath_cl *) 0 ;
  
  SWIG_check_num_args("DeleteAllPathNodes",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("DeleteAllPathNodes",1,"VisPath_cl *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisPath_cl,0))){
    SWIG_fail_ptr("VisPath_cl_DeleteAllPathNodes",1,SWIGTYPE_p_VisPath_cl);
  }
  
  (arg1)->DeleteAllPathNodes();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisPath_cl_GetPathNodeCount(lua_State* L) {
  int SWIG_arg = 0;
  VisPath_cl *arg1 = (VisPath_cl *) 0 ;
  int result;
  
  SWIG_check_num_args("GetPathNodeCount",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetPathNodeCount",1,"VisPath_cl const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisPath_cl,0))){
    SWIG_fail_ptr("VisPath_cl_GetPathNodeCount",1,SWIGTYPE_p_VisPath_cl);
  }
  
  result = (int)((VisPath_cl const *)arg1)->GetPathNodeCount();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisPath_cl_DrawPath__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  VisPath_cl *arg1 = (VisPath_cl *) 0 ;
  VColorRef arg2 ;
  float arg3 ;
  VColorRef *argp2 ;
  
  SWIG_check_num_args("DrawPath",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("DrawPath",1,"VisPath_cl *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("DrawPath",2,"VColorRef");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("DrawPath",3,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisPath_cl,0))){
    SWIG_fail_ptr("VisPath_cl_DrawPath",1,SWIGTYPE_p_VisPath_cl);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_VColorRef,0))){
    SWIG_fail_ptr("VisPath_cl_DrawPath",2,SWIGTYPE_p_VColorRef);
  }
  arg2 = *argp2;
  
  arg3 = (float)lua_tonumber(L, 3);
  (arg1)->DrawPath(arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisPath_cl_DrawPath__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  VisPath_cl *arg1 = (VisPath_cl *) 0 ;
  VColorRef arg2 ;
  VColorRef *argp2 ;
  
  SWIG_check_num_args("DrawPath",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("DrawPath",1,"VisPath_cl *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("DrawPath",2,"VColorRef");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisPath_cl,0))){
    SWIG_fail_ptr("VisPath_cl_DrawPath",1,SWIGTYPE_p_VisPath_cl);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_VColorRef,0))){
    SWIG_fail_ptr("VisPath_cl_DrawPath",2,SWIGTYPE_p_VColorRef);
  }
  arg2 = *argp2;
  
  (arg1)->DrawPath(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisPath_cl_DrawPath__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  VisPath_cl *arg1 = (VisPath_cl *) 0 ;
  
  SWIG_check_num_args("DrawPath",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("DrawPath",1,"VisPath_cl *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisPath_cl,0))){
    SWIG_fail_ptr("VisPath_cl_DrawPath",1,SWIGTYPE_p_VisPath_cl);
  }
  
  (arg1)->DrawPath();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisPath_cl_DrawPath(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VisPath_cl, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_VisPath_cl_DrawPath__SWIG_2(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VisPath_cl, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_VColorRef, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_VisPath_cl_DrawPath__SWIG_1(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VisPath_cl, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_VColorRef, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          return _wrap_VisPath_cl_DrawPath__SWIG_0(L);
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'VisPath_cl_DrawPath'\n"
    "  Possible C/C++ prototypes are:\n"
    "    DrawPath(VisPath_cl *,VColorRef,float)\n"
    "    DrawPath(VisPath_cl *,VColorRef)\n"
    "    DrawPath(VisPath_cl *)\n");
  lua_error(L);return 0;
}


static int _wrap_VisPath_cl_AddPathNode__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  VisPath_cl *arg1 = (VisPath_cl *) 0 ;
  hkvVec3 *arg2 = (hkvVec3 *) 0 ;
  char *arg3 = (char *) 0 ;
  VisPathNode_cl *result = 0 ;
  
  SWIG_check_num_args("AddPathNode",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("AddPathNode",1,"VisPath_cl *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("AddPathNode",2,"hkvVec3 const *");
  if(!SWIG_lua_isnilstring(L,3)) SWIG_fail_arg("AddPathNode",3,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisPath_cl,0))){
    SWIG_fail_ptr("VisPath_cl_AddPathNode",1,SWIGTYPE_p_VisPath_cl);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("VisPath_cl_AddPathNode",2,SWIGTYPE_p_hkvVec3);
  }
  
  arg3 = (char *)lua_tostring(L, 3);
  result = (VisPathNode_cl *)VisPath_cl_AddPathNode__SWIG_1(arg1,(hkvVec3 const *)arg2,(char const *)arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_VisPathNode_cl,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisPath_cl_AddPathNode__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  VisPath_cl *arg1 = (VisPath_cl *) 0 ;
  hkvVec3 *arg2 = (hkvVec3 *) 0 ;
  VisPathNode_cl *result = 0 ;
  
  SWIG_check_num_args("AddPathNode",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("AddPathNode",1,"VisPath_cl *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("AddPathNode",2,"hkvVec3 const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisPath_cl,0))){
    SWIG_fail_ptr("VisPath_cl_AddPathNode",1,SWIGTYPE_p_VisPath_cl);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("VisPath_cl_AddPathNode",2,SWIGTYPE_p_hkvVec3);
  }
  
  result = (VisPathNode_cl *)VisPath_cl_AddPathNode__SWIG_1(arg1,(hkvVec3 const *)arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_VisPathNode_cl,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisPath_cl_AddPathNode(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VisPath_cl, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_VisPathNode_cl, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_VisPath_cl_AddPathNode__SWIG_0(L);
      }
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VisPath_cl, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_hkvVec3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_VisPath_cl_AddPathNode__SWIG_2(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VisPath_cl, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_hkvVec3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          _v = SWIG_lua_isnilstring(L,argv[2]);
        }
        if (_v) {
          return _wrap_VisPath_cl_AddPathNode__SWIG_1(L);
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'VisPath_cl_AddPathNode'\n"
    "  Possible C/C++ prototypes are:\n"
    "    AddPathNode(VisPath_cl *,VisPathNode_cl *)\n"
    "    AddPathNode(VisPath_cl *,hkvVec3 const *,char const *)\n"
    "    AddPathNode(VisPath_cl *,hkvVec3 const *)\n");
  lua_error(L);return 0;
}


static int _wrap_VisPath_cl_GetPathNode__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  VisPath_cl *arg1 = (VisPath_cl *) 0 ;
  int arg2 ;
  VisPathNode_cl *result = 0 ;
  
  SWIG_check_num_args("GetPathNode",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetPathNode",1,"VisPath_cl *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("GetPathNode",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisPath_cl,0))){
    SWIG_fail_ptr("VisPath_cl_GetPathNode",1,SWIGTYPE_p_VisPath_cl);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  result = (VisPathNode_cl *)VisPath_cl_GetPathNode__SWIG_0(arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_VisPathNode_cl,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisPath_cl_GetPathNode__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  VisPath_cl *arg1 = (VisPath_cl *) 0 ;
  char *arg2 = (char *) 0 ;
  VisPathNode_cl *result = 0 ;
  
  SWIG_check_num_args("GetPathNode",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetPathNode",1,"VisPath_cl *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("GetPathNode",2,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisPath_cl,0))){
    SWIG_fail_ptr("VisPath_cl_GetPathNode",1,SWIGTYPE_p_VisPath_cl);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  result = (VisPathNode_cl *)VisPath_cl_GetPathNode__SWIG_1(arg1,(char const *)arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_VisPathNode_cl,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisPath_cl_GetPathNode(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VisPath_cl, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_VisPath_cl_GetPathNode__SWIG_0(L);
      }
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VisPath_cl, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = SWIG_lua_isnilstring(L,argv[1]);
      }
      if (_v) {
        return _wrap_VisPath_cl_GetPathNode__SWIG_1(L);
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'VisPath_cl_GetPathNode'\n"
    "  Possible C/C++ prototypes are:\n"
    "    GetPathNode(VisPath_cl *,int)\n"
    "    GetPathNode(VisPath_cl *,char const *)\n");
  lua_error(L);return 0;
}


static int _wrap_VisPath_cl_SetClosed(lua_State* L) {
  int SWIG_arg = 0;
  VisPath_cl *arg1 = (VisPath_cl *) 0 ;
  bool arg2 ;
  
  SWIG_check_num_args("SetClosed",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetClosed",1,"VisPath_cl *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("SetClosed",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisPath_cl,0))){
    SWIG_fail_ptr("VisPath_cl_SetClosed",1,SWIGTYPE_p_VisPath_cl);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  VisPath_cl_SetClosed(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisPath_cl_IsClosed(lua_State* L) {
  int SWIG_arg = 0;
  VisPath_cl *arg1 = (VisPath_cl *) 0 ;
  bool result;
  
  SWIG_check_num_args("IsClosed",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("IsClosed",1,"VisPath_cl const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisPath_cl,0))){
    SWIG_fail_ptr("VisPath_cl_IsClosed",1,SWIGTYPE_p_VisPath_cl);
  }
  
  result = (bool)VisPath_cl_IsClosed((VisPath_cl const *)arg1);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisPath_cl_GetLen(lua_State* L) {
  int SWIG_arg = 0;
  VisPath_cl *arg1 = (VisPath_cl *) 0 ;
  float result;
  
  SWIG_check_num_args("GetLen",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetLen",1,"VisPath_cl *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisPath_cl,0))){
    SWIG_fail_ptr("VisPath_cl_GetLen",1,SWIGTYPE_p_VisPath_cl);
  }
  
  result = (float)(arg1)->GetLen();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static swig_lua_method swig_VisPath_cl_methods[] = {
    { "__tostring",VisPath_cl_ToString},
    { "Evaluate",VisPath_cl_Evaluate},
    { "__concat",VisPath_cl_Concat},
    {"Remove", _wrap_VisPath_cl_Remove}, 
    {"DeleteAllPathNodes", _wrap_VisPath_cl_DeleteAllPathNodes}, 
    {"GetPathNodeCount", _wrap_VisPath_cl_GetPathNodeCount}, 
    {"DrawPath", _wrap_VisPath_cl_DrawPath}, 
    {"AddPathNode", _wrap_VisPath_cl_AddPathNode}, 
    {"GetPathNode", _wrap_VisPath_cl_GetPathNode}, 
    {"SetClosed", _wrap_VisPath_cl_SetClosed}, 
    {"IsClosed", _wrap_VisPath_cl_IsClosed}, 
    {"GetLen", _wrap_VisPath_cl_GetLen}, 
    {0,0}
};
static swig_lua_attribute swig_VisPath_cl_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_VisPath_cl_bases[] = {0,0};
static const char *swig_VisPath_cl_base_names[] = {"VisObject3D_cl *",0};
static swig_lua_class _wrap_class_VisPath_cl = { "VisPath_cl", &SWIGTYPE_p_VisPath_cl,0,0, swig_VisPath_cl_methods, swig_VisPath_cl_attributes, swig_VisPath_cl_bases, swig_VisPath_cl_base_names };

static int _wrap_VisPathNode_cl_SetPosition(lua_State* L) {
  int SWIG_arg = 0;
  VisPathNode_cl *arg1 = (VisPathNode_cl *) 0 ;
  hkvVec3 *arg2 = 0 ;
  
  SWIG_check_num_args("SetPosition",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetPosition",1,"VisPathNode_cl *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("SetPosition",2,"hkvVec3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisPathNode_cl,0))){
    SWIG_fail_ptr("VisPathNode_cl_SetPosition",1,SWIGTYPE_p_VisPathNode_cl);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("VisPathNode_cl_SetPosition",2,SWIGTYPE_p_hkvVec3);
  }
  
  (arg1)->SetPosition((hkvVec3 const &)*arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisPathNode_cl_GetPosition(lua_State* L) {
  int SWIG_arg = 0;
  VisPathNode_cl *arg1 = (VisPathNode_cl *) 0 ;
  SwigValueWrapper< hkvVec3 > result;
  
  SWIG_check_num_args("GetPosition",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetPosition",1,"VisPathNode_cl const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisPathNode_cl,0))){
    SWIG_fail_ptr("VisPathNode_cl_GetPosition",1,SWIGTYPE_p_VisPathNode_cl);
  }
  
  result = VisPathNode_cl_GetPosition((VisPathNode_cl const *)arg1);
  {
    hkvVec3 * resultptr = new hkvVec3((const hkvVec3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_hkvVec3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisPathNode_cl_SetInTypeBezier(lua_State* L) {
  int SWIG_arg = 0;
  VisPathNode_cl *arg1 = (VisPathNode_cl *) 0 ;
  bool arg2 ;
  
  SWIG_check_num_args("SetInTypeBezier",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetInTypeBezier",1,"VisPathNode_cl *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("SetInTypeBezier",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisPathNode_cl,0))){
    SWIG_fail_ptr("VisPathNode_cl_SetInTypeBezier",1,SWIGTYPE_p_VisPathNode_cl);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  VisPathNode_cl_SetInTypeBezier(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisPathNode_cl_SetOutTypeBezier(lua_State* L) {
  int SWIG_arg = 0;
  VisPathNode_cl *arg1 = (VisPathNode_cl *) 0 ;
  bool arg2 ;
  
  SWIG_check_num_args("SetOutTypeBezier",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetOutTypeBezier",1,"VisPathNode_cl *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("SetOutTypeBezier",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisPathNode_cl,0))){
    SWIG_fail_ptr("VisPathNode_cl_SetOutTypeBezier",1,SWIGTYPE_p_VisPathNode_cl);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  VisPathNode_cl_SetOutTypeBezier(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisPathNode_cl_MakeInColinearToOut(lua_State* L) {
  int SWIG_arg = 0;
  VisPathNode_cl *arg1 = (VisPathNode_cl *) 0 ;
  
  SWIG_check_num_args("MakeInColinearToOut",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MakeInColinearToOut",1,"VisPathNode_cl *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisPathNode_cl,0))){
    SWIG_fail_ptr("VisPathNode_cl_MakeInColinearToOut",1,SWIGTYPE_p_VisPathNode_cl);
  }
  
  VisPathNode_cl_MakeInColinearToOut(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisPathNode_cl_MakeOutColinearToIn(lua_State* L) {
  int SWIG_arg = 0;
  VisPathNode_cl *arg1 = (VisPathNode_cl *) 0 ;
  
  SWIG_check_num_args("MakeOutColinearToIn",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MakeOutColinearToIn",1,"VisPathNode_cl *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisPathNode_cl,0))){
    SWIG_fail_ptr("VisPathNode_cl_MakeOutColinearToIn",1,SWIGTYPE_p_VisPathNode_cl);
  }
  
  VisPathNode_cl_MakeOutColinearToIn(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisPathNode_cl_SetControlVertices(lua_State* L) {
  int SWIG_arg = 0;
  VisPathNode_cl *arg1 = (VisPathNode_cl *) 0 ;
  hkvVec3 *arg2 = 0 ;
  hkvVec3 *arg3 = 0 ;
  
  SWIG_check_num_args("SetControlVertices",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetControlVertices",1,"VisPathNode_cl *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("SetControlVertices",2,"hkvVec3 const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("SetControlVertices",3,"hkvVec3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisPathNode_cl,0))){
    SWIG_fail_ptr("VisPathNode_cl_SetControlVertices",1,SWIGTYPE_p_VisPathNode_cl);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("VisPathNode_cl_SetControlVertices",2,SWIGTYPE_p_hkvVec3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("VisPathNode_cl_SetControlVertices",3,SWIGTYPE_p_hkvVec3);
  }
  
  (arg1)->SetControlVertices((hkvVec3 const &)*arg2,(hkvVec3 const &)*arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisPathNode_cl_GetLen(lua_State* L) {
  int SWIG_arg = 0;
  VisPathNode_cl *arg1 = (VisPathNode_cl *) 0 ;
  VisPathNode_cl *arg2 = 0 ;
  float result;
  
  SWIG_check_num_args("GetLen",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetLen",1,"VisPathNode_cl const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("GetLen",2,"VisPathNode_cl const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisPathNode_cl,0))){
    SWIG_fail_ptr("VisPathNode_cl_GetLen",1,SWIGTYPE_p_VisPathNode_cl);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_VisPathNode_cl,0))){
    SWIG_fail_ptr("VisPathNode_cl_GetLen",2,SWIGTYPE_p_VisPathNode_cl);
  }
  
  result = (float)((VisPathNode_cl const *)arg1)->GetLen((VisPathNode_cl const &)*arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static swig_lua_method swig_VisPathNode_cl_methods[] = {
    { "__tostring",VisPathNode_cl_ToString},
    { "__concat",VisPathNode_cl_Concat},
    {"SetPosition", _wrap_VisPathNode_cl_SetPosition}, 
    {"GetPosition", _wrap_VisPathNode_cl_GetPosition}, 
    {"SetInTypeBezier", _wrap_VisPathNode_cl_SetInTypeBezier}, 
    {"SetOutTypeBezier", _wrap_VisPathNode_cl_SetOutTypeBezier}, 
    {"MakeInColinearToOut", _wrap_VisPathNode_cl_MakeInColinearToOut}, 
    {"MakeOutColinearToIn", _wrap_VisPathNode_cl_MakeOutColinearToIn}, 
    {"SetControlVertices", _wrap_VisPathNode_cl_SetControlVertices}, 
    {"GetLen", _wrap_VisPathNode_cl_GetLen}, 
    {0,0}
};
static swig_lua_attribute swig_VisPathNode_cl_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_VisPathNode_cl_bases[] = {0,0};
static const char *swig_VisPathNode_cl_base_names[] = {"VisObjectKey_cl *",0};
static swig_lua_class _wrap_class_VisPathNode_cl = { "VisPathNode_cl", &SWIGTYPE_p_VisPathNode_cl,0,0, swig_VisPathNode_cl_methods, swig_VisPathNode_cl_attributes, swig_VisPathNode_cl_bases, swig_VisPathNode_cl_base_names };

static int _wrap_VTextureObject_GetType(lua_State* L) {
  int SWIG_arg = 0;
  VTextureObject *arg1 = (VTextureObject *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("GetType",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetType",1,"VTextureObject *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VTextureObject,0))){
    SWIG_fail_ptr("VTextureObject_GetType",1,SWIGTYPE_p_VTextureObject);
  }
  
  result = (char *)VTextureObject_GetType(arg1);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VTextureObject___eq(lua_State* L) {
  int SWIG_arg = 0;
  VTextureObject *arg1 = (VTextureObject *) 0 ;
  VTextureObject *arg2 = 0 ;
  bool result;
  
  SWIG_check_num_args("operator ==",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("operator ==",1,"VTextureObject *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("operator ==",2,"VTextureObject const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VTextureObject,0))){
    SWIG_fail_ptr("VTextureObject___eq",1,SWIGTYPE_p_VTextureObject);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_VTextureObject,0))){
    SWIG_fail_ptr("VTextureObject___eq",2,SWIGTYPE_p_VTextureObject);
  }
  
  result = (bool)VTextureObject_operator_Se__Se_(arg1,(VTextureObject const &)*arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VTextureObject_IsRenderable(lua_State* L) {
  int SWIG_arg = 0;
  VTextureObject *arg1 = (VTextureObject *) 0 ;
  bool result;
  
  SWIG_check_num_args("IsRenderable",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("IsRenderable",1,"VTextureObject const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VTextureObject,0))){
    SWIG_fail_ptr("VTextureObject_IsRenderable",1,SWIGTYPE_p_VTextureObject);
  }
  
  result = (bool)((VTextureObject const *)arg1)->IsRenderable();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VTextureObject_GetWidth(lua_State* L) {
  int SWIG_arg = 0;
  VTextureObject *arg1 = (VTextureObject *) 0 ;
  int result;
  
  SWIG_check_num_args("GetTextureWidth",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetTextureWidth",1,"VTextureObject const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VTextureObject,0))){
    SWIG_fail_ptr("VTextureObject_GetWidth",1,SWIGTYPE_p_VTextureObject);
  }
  
  result = (int)((VTextureObject const *)arg1)->GetTextureWidth();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VTextureObject_GetHeight(lua_State* L) {
  int SWIG_arg = 0;
  VTextureObject *arg1 = (VTextureObject *) 0 ;
  int result;
  
  SWIG_check_num_args("GetTextureHeight",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetTextureHeight",1,"VTextureObject const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VTextureObject,0))){
    SWIG_fail_ptr("VTextureObject_GetHeight",1,SWIGTYPE_p_VTextureObject);
  }
  
  result = (int)((VTextureObject const *)arg1)->GetTextureHeight();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VTextureObject_GetColorDepth(lua_State* L) {
  int SWIG_arg = 0;
  VTextureObject *arg1 = (VTextureObject *) 0 ;
  int result;
  
  SWIG_check_num_args("GetTextureColorDepth",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetTextureColorDepth",1,"VTextureObject const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VTextureObject,0))){
    SWIG_fail_ptr("VTextureObject_GetColorDepth",1,SWIGTYPE_p_VTextureObject);
  }
  
  result = (int)((VTextureObject const *)arg1)->GetTextureColorDepth();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VTextureObject_GetColorDepthUncompressed(lua_State* L) {
  int SWIG_arg = 0;
  VTextureObject *arg1 = (VTextureObject *) 0 ;
  int result;
  
  SWIG_check_num_args("GetTextureColorDepthUncompressed",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetTextureColorDepthUncompressed",1,"VTextureObject const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VTextureObject,0))){
    SWIG_fail_ptr("VTextureObject_GetColorDepthUncompressed",1,SWIGTYPE_p_VTextureObject);
  }
  
  result = (int)((VTextureObject const *)arg1)->GetTextureColorDepthUncompressed();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VTextureObject_IsAnimated(lua_State* L) {
  int SWIG_arg = 0;
  VTextureObject *arg1 = (VTextureObject *) 0 ;
  bool result;
  
  SWIG_check_num_args("IsAnimated",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("IsAnimated",1,"VTextureObject const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VTextureObject,0))){
    SWIG_fail_ptr("VTextureObject_IsAnimated",1,SWIGTYPE_p_VTextureObject);
  }
  
  result = (bool)((VTextureObject const *)arg1)->IsAnimated();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VTextureObject_IsCompressed(lua_State* L) {
  int SWIG_arg = 0;
  VTextureObject *arg1 = (VTextureObject *) 0 ;
  bool result;
  
  SWIG_check_num_args("IsCompressed",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("IsCompressed",1,"VTextureObject const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VTextureObject,0))){
    SWIG_fail_ptr("VTextureObject_IsCompressed",1,SWIGTYPE_p_VTextureObject);
  }
  
  result = (bool)((VTextureObject const *)arg1)->IsCompressed();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VTextureObject_GetMipMapLevelCount(lua_State* L) {
  int SWIG_arg = 0;
  VTextureObject *arg1 = (VTextureObject *) 0 ;
  int result;
  
  SWIG_check_num_args("GetMipMapLevelCount",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetMipMapLevelCount",1,"VTextureObject const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VTextureObject,0))){
    SWIG_fail_ptr("VTextureObject_GetMipMapLevelCount",1,SWIGTYPE_p_VTextureObject);
  }
  
  result = (int)((VTextureObject const *)arg1)->GetMipMapLevelCount();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VTextureObject_HasMipMaps(lua_State* L) {
  int SWIG_arg = 0;
  VTextureObject *arg1 = (VTextureObject *) 0 ;
  bool result;
  
  SWIG_check_num_args("HasMipMaps",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("HasMipMaps",1,"VTextureObject const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VTextureObject,0))){
    SWIG_fail_ptr("VTextureObject_HasMipMaps",1,SWIGTYPE_p_VTextureObject);
  }
  
  result = (bool)((VTextureObject const *)arg1)->HasMipMaps();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VTextureObject_HasAlphaChannel(lua_State* L) {
  int SWIG_arg = 0;
  VTextureObject *arg1 = (VTextureObject *) 0 ;
  bool result;
  
  SWIG_check_num_args("HasAlphaChannel",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("HasAlphaChannel",1,"VTextureObject const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VTextureObject,0))){
    SWIG_fail_ptr("VTextureObject_HasAlphaChannel",1,SWIGTYPE_p_VTextureObject);
  }
  
  result = (bool)((VTextureObject const *)arg1)->HasAlphaChannel();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VTextureObject_IsUsed(lua_State* L) {
  int SWIG_arg = 0;
  VTextureObject *arg1 = (VTextureObject *) 0 ;
  bool result;
  
  SWIG_check_num_args("IsUsed",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("IsUsed",1,"VTextureObject const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VTextureObject,0))){
    SWIG_fail_ptr("VTextureObject_IsUsed",1,SWIGTYPE_p_VTextureObject);
  }
  
  result = (bool)((VTextureObject const *)arg1)->IsUsed();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VTextureObject_IsTexturePowerOfTwo(lua_State* L) {
  int SWIG_arg = 0;
  VTextureObject *arg1 = (VTextureObject *) 0 ;
  bool result;
  
  SWIG_check_num_args("IsTexturePowerOfTwo",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("IsTexturePowerOfTwo",1,"VTextureObject const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VTextureObject,0))){
    SWIG_fail_ptr("VTextureObject_IsTexturePowerOfTwo",1,SWIGTYPE_p_VTextureObject);
  }
  
  result = (bool)((VTextureObject const *)arg1)->IsTexturePowerOfTwo();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VTextureObject_GetName(lua_State* L) {
  int SWIG_arg = 0;
  VTextureObject *arg1 = (VTextureObject *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("GetFilename",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetFilename",1,"VTextureObject const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VTextureObject,0))){
    SWIG_fail_ptr("VTextureObject_GetName",1,SWIGTYPE_p_VTextureObject);
  }
  
  result = (char *)((VTextureObject const *)arg1)->GetFilename();
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static swig_lua_method swig_VTextureObject_methods[] = {
    { "__tostring",VTextureObject_ToString},
    { "__concat",VTextureObject_Concat},
    {"GetType", _wrap_VTextureObject_GetType}, 
    {"__eq", _wrap_VTextureObject___eq}, 
    {"IsRenderable", _wrap_VTextureObject_IsRenderable}, 
    {"GetWidth", _wrap_VTextureObject_GetWidth}, 
    {"GetHeight", _wrap_VTextureObject_GetHeight}, 
    {"GetColorDepth", _wrap_VTextureObject_GetColorDepth}, 
    {"GetColorDepthUncompressed", _wrap_VTextureObject_GetColorDepthUncompressed}, 
    {"IsAnimated", _wrap_VTextureObject_IsAnimated}, 
    {"IsCompressed", _wrap_VTextureObject_IsCompressed}, 
    {"GetMipMapLevelCount", _wrap_VTextureObject_GetMipMapLevelCount}, 
    {"HasMipMaps", _wrap_VTextureObject_HasMipMaps}, 
    {"HasAlphaChannel", _wrap_VTextureObject_HasAlphaChannel}, 
    {"IsUsed", _wrap_VTextureObject_IsUsed}, 
    {"IsTexturePowerOfTwo", _wrap_VTextureObject_IsTexturePowerOfTwo}, 
    {"GetName", _wrap_VTextureObject_GetName}, 
    {0,0}
};
static swig_lua_attribute swig_VTextureObject_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_VTextureObject_bases[] = {0};
static const char *swig_VTextureObject_base_names[] = {0};
static swig_lua_class _wrap_class_VTextureObject = { "VTextureObject", &SWIGTYPE_p_VTextureObject,0,0, swig_VTextureObject_methods, swig_VTextureObject_attributes, swig_VTextureObject_bases, swig_VTextureObject_base_names };

static int _wrap_VisContextCamera_cl_Set(lua_State* L) {
  int SWIG_arg = 0;
  VisContextCamera_cl *arg1 = (VisContextCamera_cl *) 0 ;
  hkvMat3 *arg2 = 0 ;
  hkvVec3 *arg3 = 0 ;
  
  SWIG_check_num_args("Set",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Set",1,"VisContextCamera_cl *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("Set",2,"hkvMat3 const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("Set",3,"hkvVec3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisContextCamera_cl,0))){
    SWIG_fail_ptr("VisContextCamera_cl_Set",1,SWIGTYPE_p_VisContextCamera_cl);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_hkvMat3,0))){
    SWIG_fail_ptr("VisContextCamera_cl_Set",2,SWIGTYPE_p_hkvMat3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("VisContextCamera_cl_Set",3,SWIGTYPE_p_hkvVec3);
  }
  
  (arg1)->Set((hkvMat3 const &)*arg2,(hkvVec3 const &)*arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisContextCamera_cl_AttachToEntity__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  VisContextCamera_cl *arg1 = (VisContextCamera_cl *) 0 ;
  VisBaseEntity_cl *arg2 = (VisBaseEntity_cl *) 0 ;
  hkvVec3 *arg3 = 0 ;
  hkvMat3 *arg4 = (hkvMat3 *) 0 ;
  
  SWIG_check_num_args("AttachToEntity",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("AttachToEntity",1,"VisContextCamera_cl *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("AttachToEntity",2,"VisBaseEntity_cl *");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("AttachToEntity",3,"hkvVec3 const &");
  if(!SWIG_isptrtype(L,4)) SWIG_fail_arg("AttachToEntity",4,"hkvMat3 const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisContextCamera_cl,0))){
    SWIG_fail_ptr("VisContextCamera_cl_AttachToEntity",1,SWIGTYPE_p_VisContextCamera_cl);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_VisBaseEntity_cl,0))){
    SWIG_fail_ptr("VisContextCamera_cl_AttachToEntity",2,SWIGTYPE_p_VisBaseEntity_cl);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("VisContextCamera_cl_AttachToEntity",3,SWIGTYPE_p_hkvVec3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_hkvMat3,0))){
    SWIG_fail_ptr("VisContextCamera_cl_AttachToEntity",4,SWIGTYPE_p_hkvMat3);
  }
  
  (arg1)->AttachToEntity(arg2,(hkvVec3 const &)*arg3,(hkvMat3 const *)arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisContextCamera_cl_GetDirection(lua_State* L) {
  int SWIG_arg = 0;
  VisContextCamera_cl *arg1 = (VisContextCamera_cl *) 0 ;
  SwigValueWrapper< hkvVec3 > result;
  
  SWIG_check_num_args("GetDirection",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetDirection",1,"VisContextCamera_cl const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisContextCamera_cl,0))){
    SWIG_fail_ptr("VisContextCamera_cl_GetDirection",1,SWIGTYPE_p_VisContextCamera_cl);
  }
  
  result = ((VisContextCamera_cl const *)arg1)->GetDirection();
  {
    hkvVec3 * resultptr = new hkvVec3((const hkvVec3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_hkvVec3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisContextCamera_cl_IsActive(lua_State* L) {
  int SWIG_arg = 0;
  VisContextCamera_cl *arg1 = (VisContextCamera_cl *) 0 ;
  bool result;
  
  SWIG_check_num_args("IsActive",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("IsActive",1,"VisContextCamera_cl const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisContextCamera_cl,0))){
    SWIG_fail_ptr("VisContextCamera_cl_IsActive",1,SWIGTYPE_p_VisContextCamera_cl);
  }
  
  result = (bool)((VisContextCamera_cl const *)arg1)->IsActive();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisContextCamera_cl_GetWorldRotationMatrix(lua_State* L) {
  int SWIG_arg = 0;
  VisContextCamera_cl *arg1 = (VisContextCamera_cl *) 0 ;
  SwigValueWrapper< hkvMat3 > result;
  
  SWIG_check_num_args("GetWorldRotationMatrix",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetWorldRotationMatrix",1,"VisContextCamera_cl const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisContextCamera_cl,0))){
    SWIG_fail_ptr("VisContextCamera_cl_GetWorldRotationMatrix",1,SWIGTYPE_p_VisContextCamera_cl);
  }
  
  result = VisContextCamera_cl_GetWorldRotationMatrix((VisContextCamera_cl const *)arg1);
  {
    hkvMat3 * resultptr = new hkvMat3((const hkvMat3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_hkvMat3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisContextCamera_cl_GetCameraToWorldRotation(lua_State* L) {
  int SWIG_arg = 0;
  VisContextCamera_cl *arg1 = (VisContextCamera_cl *) 0 ;
  SwigValueWrapper< hkvMat3 > result;
  
  SWIG_check_num_args("GetCameraToWorldRotation",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetCameraToWorldRotation",1,"VisContextCamera_cl const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisContextCamera_cl,0))){
    SWIG_fail_ptr("VisContextCamera_cl_GetCameraToWorldRotation",1,SWIGTYPE_p_VisContextCamera_cl);
  }
  
  result = VisContextCamera_cl_GetCameraToWorldRotation((VisContextCamera_cl const *)arg1);
  {
    hkvMat3 * resultptr = new hkvMat3((const hkvMat3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_hkvMat3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisContextCamera_cl_GetWorldToCameraRotation(lua_State* L) {
  int SWIG_arg = 0;
  VisContextCamera_cl *arg1 = (VisContextCamera_cl *) 0 ;
  SwigValueWrapper< hkvMat3 > result;
  
  SWIG_check_num_args("GetWorldToCameraRotation",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetWorldToCameraRotation",1,"VisContextCamera_cl const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisContextCamera_cl,0))){
    SWIG_fail_ptr("VisContextCamera_cl_GetWorldToCameraRotation",1,SWIGTYPE_p_VisContextCamera_cl);
  }
  
  result = VisContextCamera_cl_GetWorldToCameraRotation((VisContextCamera_cl const *)arg1);
  {
    hkvMat3 * resultptr = new hkvMat3((const hkvMat3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_hkvMat3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisContextCamera_cl_LookAt(lua_State* L) {
  int SWIG_arg = 0;
  VisContextCamera_cl *arg1 = (VisContextCamera_cl *) 0 ;
  hkvVec3 *arg2 = (hkvVec3 *) 0 ;
  
  SWIG_check_num_args("LookAt",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("LookAt",1,"VisContextCamera_cl *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("LookAt",2,"hkvVec3 *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisContextCamera_cl,0))){
    SWIG_fail_ptr("VisContextCamera_cl_LookAt",1,SWIGTYPE_p_VisContextCamera_cl);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("VisContextCamera_cl_LookAt",2,SWIGTYPE_p_hkvVec3);
  }
  
  VisContextCamera_cl_LookAt(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisContextCamera_cl_ActivateInMainRenderContext(lua_State* L) {
  int SWIG_arg = 0;
  VisContextCamera_cl *arg1 = (VisContextCamera_cl *) 0 ;
  
  SWIG_check_num_args("ActivateInMainRenderContext",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ActivateInMainRenderContext",1,"VisContextCamera_cl *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisContextCamera_cl,0))){
    SWIG_fail_ptr("VisContextCamera_cl_ActivateInMainRenderContext",1,SWIGTYPE_p_VisContextCamera_cl);
  }
  
  VisContextCamera_cl_ActivateInMainRenderContext(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisContextCamera_cl_AttachToEntity__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  VisContextCamera_cl *arg1 = (VisContextCamera_cl *) 0 ;
  VisBaseEntity_cl *arg2 = (VisBaseEntity_cl *) 0 ;
  
  SWIG_check_num_args("AttachToEntity",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("AttachToEntity",1,"VisContextCamera_cl *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("AttachToEntity",2,"VisBaseEntity_cl *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisContextCamera_cl,0))){
    SWIG_fail_ptr("VisContextCamera_cl_AttachToEntity",1,SWIGTYPE_p_VisContextCamera_cl);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_VisBaseEntity_cl,0))){
    SWIG_fail_ptr("VisContextCamera_cl_AttachToEntity",2,SWIGTYPE_p_VisBaseEntity_cl);
  }
  
  VisContextCamera_cl_AttachToEntity__SWIG_1(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisContextCamera_cl_AttachToEntity__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  VisContextCamera_cl *arg1 = (VisContextCamera_cl *) 0 ;
  VisBaseEntity_cl *arg2 = (VisBaseEntity_cl *) 0 ;
  hkvVec3 *arg3 = 0 ;
  
  SWIG_check_num_args("AttachToEntity",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("AttachToEntity",1,"VisContextCamera_cl *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("AttachToEntity",2,"VisBaseEntity_cl *");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("AttachToEntity",3,"hkvVec3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisContextCamera_cl,0))){
    SWIG_fail_ptr("VisContextCamera_cl_AttachToEntity",1,SWIGTYPE_p_VisContextCamera_cl);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_VisBaseEntity_cl,0))){
    SWIG_fail_ptr("VisContextCamera_cl_AttachToEntity",2,SWIGTYPE_p_VisBaseEntity_cl);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("VisContextCamera_cl_AttachToEntity",3,SWIGTYPE_p_hkvVec3);
  }
  
  VisContextCamera_cl_AttachToEntity__SWIG_2(arg1,arg2,(hkvVec3 const &)*arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisContextCamera_cl_AttachToEntity(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VisContextCamera_cl, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_VisBaseEntity_cl, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_VisContextCamera_cl_AttachToEntity__SWIG_1(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VisContextCamera_cl, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_VisBaseEntity_cl, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_hkvVec3, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          return _wrap_VisContextCamera_cl_AttachToEntity__SWIG_2(L);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VisContextCamera_cl, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_VisBaseEntity_cl, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_hkvVec3, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          {
            void *ptr;
            if (SWIG_isptrtype(L,argv[3])==0 || SWIG_ConvertPtr(L,argv[3], (void **) &ptr, SWIGTYPE_p_hkvMat3, 0)) {
              _v = 0;
            } else {
              _v = 1;
            }
          }
          if (_v) {
            return _wrap_VisContextCamera_cl_AttachToEntity__SWIG_0(L);
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'VisContextCamera_cl_AttachToEntity'\n"
    "  Possible C/C++ prototypes are:\n"
    "    AttachToEntity(VisContextCamera_cl *,VisBaseEntity_cl *,hkvVec3 const &,hkvMat3 const *)\n"
    "    AttachToEntity(VisContextCamera_cl *,VisBaseEntity_cl *)\n"
    "    AttachToEntity(VisContextCamera_cl *,VisBaseEntity_cl *,hkvVec3 const &)\n");
  lua_error(L);return 0;
}


static swig_lua_method swig_VisContextCamera_cl_methods[] = {
    { "__tostring",VisContextCamera_cl_ToString},
    {"Set", _wrap_VisContextCamera_cl_Set}, 
    {"GetDirection", _wrap_VisContextCamera_cl_GetDirection}, 
    {"IsActive", _wrap_VisContextCamera_cl_IsActive}, 
    {"GetWorldRotationMatrix", _wrap_VisContextCamera_cl_GetWorldRotationMatrix}, 
    {"GetCameraToWorldRotation", _wrap_VisContextCamera_cl_GetCameraToWorldRotation}, 
    {"GetWorldToCameraRotation", _wrap_VisContextCamera_cl_GetWorldToCameraRotation}, 
    {"LookAt", _wrap_VisContextCamera_cl_LookAt}, 
    {"ActivateInMainRenderContext", _wrap_VisContextCamera_cl_ActivateInMainRenderContext}, 
    {"AttachToEntity", _wrap_VisContextCamera_cl_AttachToEntity}, 
    {0,0}
};
static swig_lua_attribute swig_VisContextCamera_cl_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_VisContextCamera_cl_bases[] = {0,0};
static const char *swig_VisContextCamera_cl_base_names[] = {"VisObject3D_cl *",0};
static swig_lua_class _wrap_class_VisContextCamera_cl = { "VisContextCamera_cl", &SWIGTYPE_p_VisContextCamera_cl,0,0, swig_VisContextCamera_cl_methods, swig_VisContextCamera_cl_attributes, swig_VisContextCamera_cl_bases, swig_VisContextCamera_cl_base_names };

static int _wrap_IVTimeOfDay_SetDayTime(lua_State* L) {
  int SWIG_arg = 0;
  IVTimeOfDay *arg1 = (IVTimeOfDay *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("SetDayTime",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetDayTime",1,"IVTimeOfDay *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SetDayTime",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_IVTimeOfDay,0))){
    SWIG_fail_ptr("IVTimeOfDay_SetDayTime",1,SWIGTYPE_p_IVTimeOfDay);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->SetDayTime(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_IVTimeOfDay_GetDayTime(lua_State* L) {
  int SWIG_arg = 0;
  IVTimeOfDay *arg1 = (IVTimeOfDay *) 0 ;
  float result;
  
  SWIG_check_num_args("GetDayTime",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetDayTime",1,"IVTimeOfDay *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_IVTimeOfDay,0))){
    SWIG_fail_ptr("IVTimeOfDay_GetDayTime",1,SWIGTYPE_p_IVTimeOfDay);
  }
  
  result = (float)(arg1)->GetDayTime();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_IVTimeOfDay_IncDayTime(lua_State* L) {
  int SWIG_arg = 0;
  IVTimeOfDay *arg1 = (IVTimeOfDay *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("IncDayTime",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("IncDayTime",1,"IVTimeOfDay *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("IncDayTime",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_IVTimeOfDay,0))){
    SWIG_fail_ptr("IVTimeOfDay_IncDayTime",1,SWIGTYPE_p_IVTimeOfDay);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->IncDayTime(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_IVTimeOfDay_GetSunColor(lua_State* L) {
  int SWIG_arg = 0;
  IVTimeOfDay *arg1 = (IVTimeOfDay *) 0 ;
  VColorRef result;
  
  SWIG_check_num_args("GetSunColor",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetSunColor",1,"IVTimeOfDay *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_IVTimeOfDay,0))){
    SWIG_fail_ptr("IVTimeOfDay_GetSunColor",1,SWIGTYPE_p_IVTimeOfDay);
  }
  
  result = (arg1)->GetSunColor();
  {
    VColorRef * resultptr = new VColorRef((const VColorRef &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_VColorRef,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_IVTimeOfDay_GetAmbientColor(lua_State* L) {
  int SWIG_arg = 0;
  IVTimeOfDay *arg1 = (IVTimeOfDay *) 0 ;
  VColorRef result;
  
  SWIG_check_num_args("GetAmbientColor",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetAmbientColor",1,"IVTimeOfDay *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_IVTimeOfDay,0))){
    SWIG_fail_ptr("IVTimeOfDay_GetAmbientColor",1,SWIGTYPE_p_IVTimeOfDay);
  }
  
  result = (arg1)->GetAmbientColor();
  {
    VColorRef * resultptr = new VColorRef((const VColorRef &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_VColorRef,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_IVTimeOfDay_GetSunDirection(lua_State* L) {
  int SWIG_arg = 0;
  IVTimeOfDay *arg1 = (IVTimeOfDay *) 0 ;
  SwigValueWrapper< hkvVec3 > result;
  
  SWIG_check_num_args("GetSunDirection",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetSunDirection",1,"IVTimeOfDay *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_IVTimeOfDay,0))){
    SWIG_fail_ptr("IVTimeOfDay_GetSunDirection",1,SWIGTYPE_p_IVTimeOfDay);
  }
  
  result = IVTimeOfDay_GetSunDirection(arg1);
  {
    hkvVec3 * resultptr = new hkvVec3((const hkvVec3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_hkvVec3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static swig_lua_method swig_IVTimeOfDay_methods[] = {
    {"SetDayTime", _wrap_IVTimeOfDay_SetDayTime}, 
    {"GetDayTime", _wrap_IVTimeOfDay_GetDayTime}, 
    {"IncDayTime", _wrap_IVTimeOfDay_IncDayTime}, 
    {"GetSunColor", _wrap_IVTimeOfDay_GetSunColor}, 
    {"GetAmbientColor", _wrap_IVTimeOfDay_GetAmbientColor}, 
    {"GetSunDirection", _wrap_IVTimeOfDay_GetSunDirection}, 
    {0,0}
};
static swig_lua_attribute swig_IVTimeOfDay_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_IVTimeOfDay_bases[] = {0,0};
static const char *swig_IVTimeOfDay_base_names[] = {"VisTypedEngineObject_cl *",0};
static swig_lua_class _wrap_class_IVTimeOfDay = { "IVTimeOfDay", &SWIGTYPE_p_IVTimeOfDay,0,0, swig_IVTimeOfDay_methods, swig_IVTimeOfDay_attributes, swig_IVTimeOfDay_bases, swig_IVTimeOfDay_base_names };

static int _wrap_TriggerBoxEntity_cl_SetObserverFlags(lua_State* L) {
  int SWIG_arg = 0;
  TriggerBoxEntity_cl *arg1 = (TriggerBoxEntity_cl *) 0 ;
  VBitmask *arg2 = (VBitmask *) 0 ;
  
  SWIG_check_num_args("SetObserverFlags",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetObserverFlags",1,"TriggerBoxEntity_cl *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SetObserverFlags",2,"VBitmask *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_TriggerBoxEntity_cl,0))){
    SWIG_fail_ptr("TriggerBoxEntity_cl_SetObserverFlags",1,SWIGTYPE_p_TriggerBoxEntity_cl);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_VBitmask,0))){
    SWIG_fail_ptr("TriggerBoxEntity_cl_SetObserverFlags",2,SWIGTYPE_p_VBitmask);
  }
  
  TriggerBoxEntity_cl_SetObserverFlags(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TriggerBoxEntity_cl_GetObserverFlags(lua_State* L) {
  int SWIG_arg = 0;
  TriggerBoxEntity_cl *arg1 = (TriggerBoxEntity_cl *) 0 ;
  VBitmask result;
  
  SWIG_check_num_args("GetObserverFlags",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetObserverFlags",1,"TriggerBoxEntity_cl const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_TriggerBoxEntity_cl,0))){
    SWIG_fail_ptr("TriggerBoxEntity_cl_GetObserverFlags",1,SWIGTYPE_p_TriggerBoxEntity_cl);
  }
  
  result = TriggerBoxEntity_cl_GetObserverFlags((TriggerBoxEntity_cl const *)arg1);
  {
    VBitmask * resultptr = new VBitmask((const VBitmask &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_VBitmask,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TriggerBoxEntity_cl_SetEnabled(lua_State* L) {
  int SWIG_arg = 0;
  TriggerBoxEntity_cl *arg1 = (TriggerBoxEntity_cl *) 0 ;
  bool arg2 ;
  
  SWIG_check_num_args("SetEnabled",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetEnabled",1,"TriggerBoxEntity_cl *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("SetEnabled",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_TriggerBoxEntity_cl,0))){
    SWIG_fail_ptr("TriggerBoxEntity_cl_SetEnabled",1,SWIGTYPE_p_TriggerBoxEntity_cl);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  TriggerBoxEntity_cl_SetEnabled(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TriggerBoxEntity_cl_IsEnabled(lua_State* L) {
  int SWIG_arg = 0;
  TriggerBoxEntity_cl *arg1 = (TriggerBoxEntity_cl *) 0 ;
  VBitmask result;
  
  SWIG_check_num_args("IsEnabled",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("IsEnabled",1,"TriggerBoxEntity_cl const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_TriggerBoxEntity_cl,0))){
    SWIG_fail_ptr("TriggerBoxEntity_cl_IsEnabled",1,SWIGTYPE_p_TriggerBoxEntity_cl);
  }
  
  result = TriggerBoxEntity_cl_IsEnabled((TriggerBoxEntity_cl const *)arg1);
  {
    VBitmask * resultptr = new VBitmask((const VBitmask &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_VBitmask,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TriggerBoxEntity_cl_TestInside__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  TriggerBoxEntity_cl *arg1 = (TriggerBoxEntity_cl *) 0 ;
  hkvAlignedBBox *arg2 = 0 ;
  bool result;
  
  SWIG_check_num_args("TestInside",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("TestInside",1,"TriggerBoxEntity_cl const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("TestInside",2,"hkvAlignedBBox const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_TriggerBoxEntity_cl,0))){
    SWIG_fail_ptr("TriggerBoxEntity_cl_TestInside",1,SWIGTYPE_p_TriggerBoxEntity_cl);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_hkvAlignedBBox,0))){
    SWIG_fail_ptr("TriggerBoxEntity_cl_TestInside",2,SWIGTYPE_p_hkvAlignedBBox);
  }
  
  result = (bool)TriggerBoxEntity_cl_TestInside__SWIG_0((TriggerBoxEntity_cl const *)arg1,(hkvAlignedBBox const &)*arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TriggerBoxEntity_cl_TestInside__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  TriggerBoxEntity_cl *arg1 = (TriggerBoxEntity_cl *) 0 ;
  hkvVec3 *arg2 = 0 ;
  bool result;
  
  SWIG_check_num_args("TestInside",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("TestInside",1,"TriggerBoxEntity_cl const *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("TestInside",2,"hkvVec3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_TriggerBoxEntity_cl,0))){
    SWIG_fail_ptr("TriggerBoxEntity_cl_TestInside",1,SWIGTYPE_p_TriggerBoxEntity_cl);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("TriggerBoxEntity_cl_TestInside",2,SWIGTYPE_p_hkvVec3);
  }
  
  result = (bool)TriggerBoxEntity_cl_TestInside__SWIG_1((TriggerBoxEntity_cl const *)arg1,(hkvVec3 const &)*arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TriggerBoxEntity_cl_TestInside(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_TriggerBoxEntity_cl, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_hkvAlignedBBox, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_TriggerBoxEntity_cl_TestInside__SWIG_0(L);
      }
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_TriggerBoxEntity_cl, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_hkvVec3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_TriggerBoxEntity_cl_TestInside__SWIG_1(L);
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'TriggerBoxEntity_cl_TestInside'\n"
    "  Possible C/C++ prototypes are:\n"
    "    TestInside(TriggerBoxEntity_cl const *,hkvAlignedBBox const &)\n"
    "    TestInside(TriggerBoxEntity_cl const *,hkvVec3 const &)\n");
  lua_error(L);return 0;
}


static int _wrap_TriggerBoxEntity_cl_AddObservedEntity(lua_State* L) {
  int SWIG_arg = 0;
  TriggerBoxEntity_cl *arg1 = (TriggerBoxEntity_cl *) 0 ;
  VisBaseEntity_cl *arg2 = (VisBaseEntity_cl *) 0 ;
  
  SWIG_check_num_args("AddObservedEntity",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("AddObservedEntity",1,"TriggerBoxEntity_cl *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("AddObservedEntity",2,"VisBaseEntity_cl *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_TriggerBoxEntity_cl,0))){
    SWIG_fail_ptr("TriggerBoxEntity_cl_AddObservedEntity",1,SWIGTYPE_p_TriggerBoxEntity_cl);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_VisBaseEntity_cl,0))){
    SWIG_fail_ptr("TriggerBoxEntity_cl_AddObservedEntity",2,SWIGTYPE_p_VisBaseEntity_cl);
  }
  
  (arg1)->AddObservedEntity(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TriggerBoxEntity_cl_RemoveObservedEntity(lua_State* L) {
  int SWIG_arg = 0;
  TriggerBoxEntity_cl *arg1 = (TriggerBoxEntity_cl *) 0 ;
  VisBaseEntity_cl *arg2 = (VisBaseEntity_cl *) 0 ;
  
  SWIG_check_num_args("RemoveObservedEntity",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("RemoveObservedEntity",1,"TriggerBoxEntity_cl *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("RemoveObservedEntity",2,"VisBaseEntity_cl *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_TriggerBoxEntity_cl,0))){
    SWIG_fail_ptr("TriggerBoxEntity_cl_RemoveObservedEntity",1,SWIGTYPE_p_TriggerBoxEntity_cl);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_VisBaseEntity_cl,0))){
    SWIG_fail_ptr("TriggerBoxEntity_cl_RemoveObservedEntity",2,SWIGTYPE_p_VisBaseEntity_cl);
  }
  
  (arg1)->RemoveObservedEntity(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static swig_lua_method swig_TriggerBoxEntity_cl_methods[] = {
    { "__tostring",TriggerBoxEntity_cl_ToString},
    { "__concat",TriggerBoxEntity_cl_Concat},
    {"SetObserverFlags", _wrap_TriggerBoxEntity_cl_SetObserverFlags}, 
    {"GetObserverFlags", _wrap_TriggerBoxEntity_cl_GetObserverFlags}, 
    {"SetEnabled", _wrap_TriggerBoxEntity_cl_SetEnabled}, 
    {"IsEnabled", _wrap_TriggerBoxEntity_cl_IsEnabled}, 
    {"TestInside", _wrap_TriggerBoxEntity_cl_TestInside}, 
    {"AddObservedEntity", _wrap_TriggerBoxEntity_cl_AddObservedEntity}, 
    {"RemoveObservedEntity", _wrap_TriggerBoxEntity_cl_RemoveObservedEntity}, 
    {0,0}
};
static swig_lua_attribute swig_TriggerBoxEntity_cl_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_TriggerBoxEntity_cl_bases[] = {0,0};
static const char *swig_TriggerBoxEntity_cl_base_names[] = {"VisBaseEntity_cl *",0};
static swig_lua_class _wrap_class_TriggerBoxEntity_cl = { "TriggerBoxEntity_cl", &SWIGTYPE_p_TriggerBoxEntity_cl,0,0, swig_TriggerBoxEntity_cl_methods, swig_TriggerBoxEntity_cl_attributes, swig_TriggerBoxEntity_cl_bases, swig_TriggerBoxEntity_cl_base_names };

static int _wrap_VisScreenMask_cl_SetBlending(lua_State* L) {
  int SWIG_arg = 0;
  VisScreenMask_cl *arg1 = (VisScreenMask_cl *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("SetBlending",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetBlending",1,"VisScreenMask_cl *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SetBlending",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisScreenMask_cl,0))){
    SWIG_fail_ptr("VisScreenMask_cl_SetBlending",1,SWIGTYPE_p_VisScreenMask_cl);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  VisScreenMask_cl_SetBlending(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisScreenMask_cl_GetBlending(lua_State* L) {
  int SWIG_arg = 0;
  VisScreenMask_cl *arg1 = (VisScreenMask_cl *) 0 ;
  int result;
  
  SWIG_check_num_args("GetBlending",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetBlending",1,"VisScreenMask_cl *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisScreenMask_cl,0))){
    SWIG_fail_ptr("VisScreenMask_cl_GetBlending",1,SWIGTYPE_p_VisScreenMask_cl);
  }
  
  result = (int)VisScreenMask_cl_GetBlending(arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisScreenMask_cl_SetWrapping(lua_State* L) {
  int SWIG_arg = 0;
  VisScreenMask_cl *arg1 = (VisScreenMask_cl *) 0 ;
  bool arg2 ;
  bool arg3 ;
  
  SWIG_check_num_args("SetWrapping",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetWrapping",1,"VisScreenMask_cl *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("SetWrapping",2,"bool");
  if(!lua_isboolean(L,3)) SWIG_fail_arg("SetWrapping",3,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisScreenMask_cl,0))){
    SWIG_fail_ptr("VisScreenMask_cl_SetWrapping",1,SWIGTYPE_p_VisScreenMask_cl);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  arg3 = (lua_toboolean(L, 3)!=0);
  VisScreenMask_cl_SetWrapping(arg1,arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisScreenMask_cl_SetVisible(lua_State* L) {
  int SWIG_arg = 0;
  VisScreenMask_cl *arg1 = (VisScreenMask_cl *) 0 ;
  bool arg2 ;
  
  SWIG_check_num_args("SetVisible",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetVisible",1,"VisScreenMask_cl *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("SetVisible",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisScreenMask_cl,0))){
    SWIG_fail_ptr("VisScreenMask_cl_SetVisible",1,SWIGTYPE_p_VisScreenMask_cl);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  VisScreenMask_cl_SetVisible(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisScreenMask_cl_IsVisible(lua_State* L) {
  int SWIG_arg = 0;
  VisScreenMask_cl *arg1 = (VisScreenMask_cl *) 0 ;
  bool result;
  
  SWIG_check_num_args("IsVisible",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("IsVisible",1,"VisScreenMask_cl *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisScreenMask_cl,0))){
    SWIG_fail_ptr("VisScreenMask_cl_IsVisible",1,SWIGTYPE_p_VisScreenMask_cl);
  }
  
  result = (bool)VisScreenMask_cl_IsVisible(arg1);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisScreenMask_cl_GetFiltering(lua_State* L) {
  int SWIG_arg = 0;
  VisScreenMask_cl *arg1 = (VisScreenMask_cl *) 0 ;
  bool result;
  
  SWIG_check_num_args("GetFiltering",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetFiltering",1,"VisScreenMask_cl const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisScreenMask_cl,0))){
    SWIG_fail_ptr("VisScreenMask_cl_GetFiltering",1,SWIGTYPE_p_VisScreenMask_cl);
  }
  
  result = (bool)VisScreenMask_cl_GetFiltering((VisScreenMask_cl const *)arg1);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisScreenMask_cl_SetFiltering(lua_State* L) {
  int SWIG_arg = 0;
  VisScreenMask_cl *arg1 = (VisScreenMask_cl *) 0 ;
  bool arg2 ;
  
  SWIG_check_num_args("SetFiltering",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetFiltering",1,"VisScreenMask_cl *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("SetFiltering",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisScreenMask_cl,0))){
    SWIG_fail_ptr("VisScreenMask_cl_SetFiltering",1,SWIGTYPE_p_VisScreenMask_cl);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  VisScreenMask_cl_SetFiltering(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisScreenMask_cl_GetDepthWrite(lua_State* L) {
  int SWIG_arg = 0;
  VisScreenMask_cl *arg1 = (VisScreenMask_cl *) 0 ;
  bool result;
  
  SWIG_check_num_args("GetDepthWrite",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetDepthWrite",1,"VisScreenMask_cl const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisScreenMask_cl,0))){
    SWIG_fail_ptr("VisScreenMask_cl_GetDepthWrite",1,SWIGTYPE_p_VisScreenMask_cl);
  }
  
  result = (bool)VisScreenMask_cl_GetDepthWrite((VisScreenMask_cl const *)arg1);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisScreenMask_cl_SetDepthWrite(lua_State* L) {
  int SWIG_arg = 0;
  VisScreenMask_cl *arg1 = (VisScreenMask_cl *) 0 ;
  bool arg2 ;
  
  SWIG_check_num_args("SetDepthWrite",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetDepthWrite",1,"VisScreenMask_cl *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("SetDepthWrite",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisScreenMask_cl,0))){
    SWIG_fail_ptr("VisScreenMask_cl_SetDepthWrite",1,SWIGTYPE_p_VisScreenMask_cl);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  VisScreenMask_cl_SetDepthWrite(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisScreenMask_cl_SetVisibleBitmask(lua_State* L) {
  int SWIG_arg = 0;
  VisScreenMask_cl *arg1 = (VisScreenMask_cl *) 0 ;
  VBitmask *arg2 = (VBitmask *) 0 ;
  
  SWIG_check_num_args("SetVisibleBitmask",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetVisibleBitmask",1,"VisScreenMask_cl *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SetVisibleBitmask",2,"VBitmask *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisScreenMask_cl,0))){
    SWIG_fail_ptr("VisScreenMask_cl_SetVisibleBitmask",1,SWIGTYPE_p_VisScreenMask_cl);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_VBitmask,0))){
    SWIG_fail_ptr("VisScreenMask_cl_SetVisibleBitmask",2,SWIGTYPE_p_VBitmask);
  }
  
  VisScreenMask_cl_SetVisibleBitmask(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisScreenMask_cl_GetVisibleBitmask(lua_State* L) {
  int SWIG_arg = 0;
  VisScreenMask_cl *arg1 = (VisScreenMask_cl *) 0 ;
  VBitmask result;
  
  SWIG_check_num_args("GetVisibleBitmask",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetVisibleBitmask",1,"VisScreenMask_cl const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisScreenMask_cl,0))){
    SWIG_fail_ptr("VisScreenMask_cl_GetVisibleBitmask",1,SWIGTYPE_p_VisScreenMask_cl);
  }
  
  result = VisScreenMask_cl_GetVisibleBitmask((VisScreenMask_cl const *)arg1);
  {
    VBitmask * resultptr = new VBitmask((const VBitmask &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_VBitmask,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisScreenMask_cl_SetColor(lua_State* L) {
  int SWIG_arg = 0;
  VisScreenMask_cl *arg1 = (VisScreenMask_cl *) 0 ;
  VColorRef arg2 ;
  VColorRef *argp2 ;
  
  SWIG_check_num_args("SetColor",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetColor",1,"VisScreenMask_cl *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("SetColor",2,"VColorRef");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisScreenMask_cl,0))){
    SWIG_fail_ptr("VisScreenMask_cl_SetColor",1,SWIGTYPE_p_VisScreenMask_cl);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_VColorRef,0))){
    SWIG_fail_ptr("VisScreenMask_cl_SetColor",2,SWIGTYPE_p_VColorRef);
  }
  arg2 = *argp2;
  
  (arg1)->SetColor(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisScreenMask_cl_GetColor(lua_State* L) {
  int SWIG_arg = 0;
  VisScreenMask_cl *arg1 = (VisScreenMask_cl *) 0 ;
  VColorRef result;
  
  SWIG_check_num_args("GetColor",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetColor",1,"VisScreenMask_cl const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisScreenMask_cl,0))){
    SWIG_fail_ptr("VisScreenMask_cl_GetColor",1,SWIGTYPE_p_VisScreenMask_cl);
  }
  
  result = ((VisScreenMask_cl const *)arg1)->GetColor();
  {
    VColorRef * resultptr = new VColorRef((const VColorRef &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_VColorRef,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisScreenMask_cl_SetTargetSize(lua_State* L) {
  int SWIG_arg = 0;
  VisScreenMask_cl *arg1 = (VisScreenMask_cl *) 0 ;
  float arg2 ;
  float arg3 ;
  
  SWIG_check_num_args("SetTargetSize",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetTargetSize",1,"VisScreenMask_cl *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SetTargetSize",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("SetTargetSize",3,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisScreenMask_cl,0))){
    SWIG_fail_ptr("VisScreenMask_cl_SetTargetSize",1,SWIGTYPE_p_VisScreenMask_cl);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  (arg1)->SetTargetSize(arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisScreenMask_cl_SetTextureRange(lua_State* L) {
  int SWIG_arg = 0;
  VisScreenMask_cl *arg1 = (VisScreenMask_cl *) 0 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  float arg5 ;
  
  SWIG_check_num_args("SetTextureRange",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetTextureRange",1,"VisScreenMask_cl *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SetTextureRange",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("SetTextureRange",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("SetTextureRange",4,"float");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("SetTextureRange",5,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisScreenMask_cl,0))){
    SWIG_fail_ptr("VisScreenMask_cl_SetTextureRange",1,SWIGTYPE_p_VisScreenMask_cl);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4);
  arg5 = (float)lua_tonumber(L, 5);
  (arg1)->SetTextureRange(arg2,arg3,arg4,arg5);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisScreenMask_cl_SetPos__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  VisScreenMask_cl *arg1 = (VisScreenMask_cl *) 0 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  
  SWIG_check_num_args("SetPos",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetPos",1,"VisScreenMask_cl *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SetPos",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("SetPos",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("SetPos",4,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisScreenMask_cl,0))){
    SWIG_fail_ptr("VisScreenMask_cl_SetPos",1,SWIGTYPE_p_VisScreenMask_cl);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4);
  (arg1)->SetPos(arg2,arg3,arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisScreenMask_cl_SetPos__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  VisScreenMask_cl *arg1 = (VisScreenMask_cl *) 0 ;
  float arg2 ;
  float arg3 ;
  
  SWIG_check_num_args("SetPos",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetPos",1,"VisScreenMask_cl *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SetPos",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("SetPos",3,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisScreenMask_cl,0))){
    SWIG_fail_ptr("VisScreenMask_cl_SetPos",1,SWIGTYPE_p_VisScreenMask_cl);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  (arg1)->SetPos(arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisScreenMask_cl_SetPos(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VisScreenMask_cl, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          return _wrap_VisScreenMask_cl_SetPos__SWIG_1(L);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VisScreenMask_cl, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_VisScreenMask_cl_SetPos__SWIG_0(L);
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'VisScreenMask_cl_SetPos'\n"
    "  Possible C/C++ prototypes are:\n"
    "    SetPos(VisScreenMask_cl *,float,float,float)\n"
    "    SetPos(VisScreenMask_cl *,float,float)\n");
  lua_error(L);return 0;
}


static int _wrap_VisScreenMask_cl_SetZVal(lua_State* L) {
  int SWIG_arg = 0;
  VisScreenMask_cl *arg1 = (VisScreenMask_cl *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("SetZVal",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetZVal",1,"VisScreenMask_cl *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SetZVal",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisScreenMask_cl,0))){
    SWIG_fail_ptr("VisScreenMask_cl_SetZVal",1,SWIGTYPE_p_VisScreenMask_cl);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->SetZVal(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisScreenMask_cl_GetZVal(lua_State* L) {
  int SWIG_arg = 0;
  VisScreenMask_cl *arg1 = (VisScreenMask_cl *) 0 ;
  float result;
  
  SWIG_check_num_args("GetZVal",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetZVal",1,"VisScreenMask_cl const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisScreenMask_cl,0))){
    SWIG_fail_ptr("VisScreenMask_cl_GetZVal",1,SWIGTYPE_p_VisScreenMask_cl);
  }
  
  result = (float)((VisScreenMask_cl const *)arg1)->GetZVal();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisScreenMask_cl_SetKey(lua_State* L) {
  int SWIG_arg = 0;
  VisScreenMask_cl *arg1 = (VisScreenMask_cl *) 0 ;
  char *arg2 = (char *) 0 ;
  
  SWIG_check_num_args("SetKey",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetKey",1,"VisScreenMask_cl *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("SetKey",2,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisScreenMask_cl,0))){
    SWIG_fail_ptr("VisScreenMask_cl_SetKey",1,SWIGTYPE_p_VisScreenMask_cl);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  (arg1)->SetKey((char const *)arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisScreenMask_cl_GetKey(lua_State* L) {
  int SWIG_arg = 0;
  VisScreenMask_cl *arg1 = (VisScreenMask_cl *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("GetKey",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetKey",1,"VisScreenMask_cl const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisScreenMask_cl,0))){
    SWIG_fail_ptr("VisScreenMask_cl_GetKey",1,SWIGTYPE_p_VisScreenMask_cl);
  }
  
  result = (char *)((VisScreenMask_cl const *)arg1)->GetKey();
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisScreenMask_cl_SetOrder(lua_State* L) {
  int SWIG_arg = 0;
  VisScreenMask_cl *arg1 = (VisScreenMask_cl *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("SetOrder",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetOrder",1,"VisScreenMask_cl *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SetOrder",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisScreenMask_cl,0))){
    SWIG_fail_ptr("VisScreenMask_cl_SetOrder",1,SWIGTYPE_p_VisScreenMask_cl);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->SetOrder(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisScreenMask_cl_GetOrder(lua_State* L) {
  int SWIG_arg = 0;
  VisScreenMask_cl *arg1 = (VisScreenMask_cl *) 0 ;
  int result;
  
  SWIG_check_num_args("GetOrder",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetOrder",1,"VisScreenMask_cl const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisScreenMask_cl,0))){
    SWIG_fail_ptr("VisScreenMask_cl_GetOrder",1,SWIGTYPE_p_VisScreenMask_cl);
  }
  
  result = (int)((VisScreenMask_cl const *)arg1)->GetOrder();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisScreenMask_cl_SetRotationAngle(lua_State* L) {
  int SWIG_arg = 0;
  VisScreenMask_cl *arg1 = (VisScreenMask_cl *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("SetRotationAngle",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetRotationAngle",1,"VisScreenMask_cl *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SetRotationAngle",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisScreenMask_cl,0))){
    SWIG_fail_ptr("VisScreenMask_cl_SetRotationAngle",1,SWIGTYPE_p_VisScreenMask_cl);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->SetRotationAngle(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisScreenMask_cl_GetRotationAngle(lua_State* L) {
  int SWIG_arg = 0;
  VisScreenMask_cl *arg1 = (VisScreenMask_cl *) 0 ;
  float result;
  
  SWIG_check_num_args("GetRotationAngle",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetRotationAngle",1,"VisScreenMask_cl const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisScreenMask_cl,0))){
    SWIG_fail_ptr("VisScreenMask_cl_GetRotationAngle",1,SWIGTYPE_p_VisScreenMask_cl);
  }
  
  result = (float)((VisScreenMask_cl const *)arg1)->GetRotationAngle();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisScreenMask_cl_SetRotationCenter(lua_State* L) {
  int SWIG_arg = 0;
  VisScreenMask_cl *arg1 = (VisScreenMask_cl *) 0 ;
  float arg2 ;
  float arg3 ;
  
  SWIG_check_num_args("SetRotationCenter",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetRotationCenter",1,"VisScreenMask_cl *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SetRotationCenter",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("SetRotationCenter",3,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisScreenMask_cl,0))){
    SWIG_fail_ptr("VisScreenMask_cl_SetRotationCenter",1,SWIGTYPE_p_VisScreenMask_cl);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  (arg1)->SetRotationCenter(arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisScreenMask_cl_GetTextureObject(lua_State* L) {
  int SWIG_arg = 0;
  VisScreenMask_cl *arg1 = (VisScreenMask_cl *) 0 ;
  VTextureObject *result = 0 ;
  
  SWIG_check_num_args("GetTextureObject",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetTextureObject",1,"VisScreenMask_cl *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisScreenMask_cl,0))){
    SWIG_fail_ptr("VisScreenMask_cl_GetTextureObject",1,SWIGTYPE_p_VisScreenMask_cl);
  }
  
  result = (VTextureObject *)(arg1)->GetTextureObject();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_VTextureObject,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisScreenMask_cl_SetTextureObject(lua_State* L) {
  int SWIG_arg = 0;
  VisScreenMask_cl *arg1 = (VisScreenMask_cl *) 0 ;
  VTextureObject *arg2 = (VTextureObject *) 0 ;
  
  SWIG_check_num_args("SetTextureObject",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetTextureObject",1,"VisScreenMask_cl *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SetTextureObject",2,"VTextureObject *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisScreenMask_cl,0))){
    SWIG_fail_ptr("VisScreenMask_cl_SetTextureObject",1,SWIGTYPE_p_VisScreenMask_cl);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_VTextureObject,0))){
    SWIG_fail_ptr("VisScreenMask_cl_SetTextureObject",2,SWIGTYPE_p_VTextureObject);
  }
  
  (arg1)->SetTextureObject(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisScreenMask_cl_Unload(lua_State* L) {
  int SWIG_arg = 0;
  VisScreenMask_cl *arg1 = (VisScreenMask_cl *) 0 ;
  
  SWIG_check_num_args("Unload",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Unload",1,"VisScreenMask_cl *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisScreenMask_cl,0))){
    SWIG_fail_ptr("VisScreenMask_cl_Unload",1,SWIGTYPE_p_VisScreenMask_cl);
  }
  
  (arg1)->Unload();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static swig_lua_method swig_VisScreenMask_cl_methods[] = {
    { "__tostring",VisScreenMask_cl_ToString},
    { "GetTextureSize",VisScreenMask_cl_GetTextureSize},
    { "GetPos",VisScreenMask_cl_GetPos},
    { "__concat",VisScreenMask_cl_Concat},
    {"SetBlending", _wrap_VisScreenMask_cl_SetBlending}, 
    {"GetBlending", _wrap_VisScreenMask_cl_GetBlending}, 
    {"SetWrapping", _wrap_VisScreenMask_cl_SetWrapping}, 
    {"SetVisible", _wrap_VisScreenMask_cl_SetVisible}, 
    {"IsVisible", _wrap_VisScreenMask_cl_IsVisible}, 
    {"GetFiltering", _wrap_VisScreenMask_cl_GetFiltering}, 
    {"SetFiltering", _wrap_VisScreenMask_cl_SetFiltering}, 
    {"GetDepthWrite", _wrap_VisScreenMask_cl_GetDepthWrite}, 
    {"SetDepthWrite", _wrap_VisScreenMask_cl_SetDepthWrite}, 
    {"SetVisibleBitmask", _wrap_VisScreenMask_cl_SetVisibleBitmask}, 
    {"GetVisibleBitmask", _wrap_VisScreenMask_cl_GetVisibleBitmask}, 
    {"SetColor", _wrap_VisScreenMask_cl_SetColor}, 
    {"GetColor", _wrap_VisScreenMask_cl_GetColor}, 
    {"SetTargetSize", _wrap_VisScreenMask_cl_SetTargetSize}, 
    {"SetTextureRange", _wrap_VisScreenMask_cl_SetTextureRange}, 
    {"SetPos", _wrap_VisScreenMask_cl_SetPos}, 
    {"SetZVal", _wrap_VisScreenMask_cl_SetZVal}, 
    {"GetZVal", _wrap_VisScreenMask_cl_GetZVal}, 
    {"SetKey", _wrap_VisScreenMask_cl_SetKey}, 
    {"GetKey", _wrap_VisScreenMask_cl_GetKey}, 
    {"SetOrder", _wrap_VisScreenMask_cl_SetOrder}, 
    {"GetOrder", _wrap_VisScreenMask_cl_GetOrder}, 
    {"SetRotationAngle", _wrap_VisScreenMask_cl_SetRotationAngle}, 
    {"GetRotationAngle", _wrap_VisScreenMask_cl_GetRotationAngle}, 
    {"SetRotationCenter", _wrap_VisScreenMask_cl_SetRotationCenter}, 
    {"GetTextureObject", _wrap_VisScreenMask_cl_GetTextureObject}, 
    {"SetTextureObject", _wrap_VisScreenMask_cl_SetTextureObject}, 
    {"Unload", _wrap_VisScreenMask_cl_Unload}, 
    {0,0}
};
static swig_lua_attribute swig_VisScreenMask_cl_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_VisScreenMask_cl_bases[] = {0};
static const char *swig_VisScreenMask_cl_base_names[] = {0};
static swig_lua_class _wrap_class_VisScreenMask_cl = { "VisScreenMask_cl", &SWIGTYPE_p_VisScreenMask_cl,0,0, swig_VisScreenMask_cl_methods, swig_VisScreenMask_cl_attributes, swig_VisScreenMask_cl_bases, swig_VisScreenMask_cl_base_names };

static int _wrap_IVRendererNode_RemovePostProcessor(lua_State* L) {
  int SWIG_arg = 0;
  IVRendererNode *arg1 = (IVRendererNode *) 0 ;
  VPostProcessingBaseComponent *arg2 = (VPostProcessingBaseComponent *) 0 ;
  bool result;
  
  SWIG_check_num_args("RemovePostProcessor",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("RemovePostProcessor",1,"IVRendererNode *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("RemovePostProcessor",2,"VPostProcessingBaseComponent *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_IVRendererNode,0))){
    SWIG_fail_ptr("IVRendererNode_RemovePostProcessor",1,SWIGTYPE_p_IVRendererNode);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_VPostProcessingBaseComponent,0))){
    SWIG_fail_ptr("IVRendererNode_RemovePostProcessor",2,SWIGTYPE_p_VPostProcessingBaseComponent);
  }
  
  result = (bool)IVRendererNode_RemovePostProcessor(arg1,arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_IVRendererNode_AddPostProcessor__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  IVRendererNode *arg1 = (IVRendererNode *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  VPostProcessingBaseComponent *result = 0 ;
  
  SWIG_check_num_args("AddPostProcessor",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("AddPostProcessor",1,"IVRendererNode *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("AddPostProcessor",2,"char const *");
  if(!SWIG_lua_isnilstring(L,3)) SWIG_fail_arg("AddPostProcessor",3,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_IVRendererNode,0))){
    SWIG_fail_ptr("IVRendererNode_AddPostProcessor",1,SWIGTYPE_p_IVRendererNode);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  arg3 = (char *)lua_tostring(L, 3);
  result = (VPostProcessingBaseComponent *)IVRendererNode_AddPostProcessor__SWIG_0(arg1,(char const *)arg2,(char const *)arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_VPostProcessingBaseComponent,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_IVRendererNode_AddPostProcessor__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  IVRendererNode *arg1 = (IVRendererNode *) 0 ;
  char *arg2 = (char *) 0 ;
  VPostProcessingBaseComponent *result = 0 ;
  
  SWIG_check_num_args("AddPostProcessor",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("AddPostProcessor",1,"IVRendererNode *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("AddPostProcessor",2,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_IVRendererNode,0))){
    SWIG_fail_ptr("IVRendererNode_AddPostProcessor",1,SWIGTYPE_p_IVRendererNode);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  result = (VPostProcessingBaseComponent *)IVRendererNode_AddPostProcessor__SWIG_0(arg1,(char const *)arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_VPostProcessingBaseComponent,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_IVRendererNode_AddPostProcessor(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_IVRendererNode, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = SWIG_lua_isnilstring(L,argv[1]);
      }
      if (_v) {
        return _wrap_IVRendererNode_AddPostProcessor__SWIG_1(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_IVRendererNode, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = SWIG_lua_isnilstring(L,argv[1]);
      }
      if (_v) {
        {
          _v = SWIG_lua_isnilstring(L,argv[2]);
        }
        if (_v) {
          return _wrap_IVRendererNode_AddPostProcessor__SWIG_0(L);
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'IVRendererNode_AddPostProcessor'\n"
    "  Possible C/C++ prototypes are:\n"
    "    AddPostProcessor(IVRendererNode *,char const *,char const *)\n"
    "    AddPostProcessor(IVRendererNode *,char const *)\n");
  lua_error(L);return 0;
}


static int _wrap_IVRendererNode_GetMultisampleMode(lua_State* L) {
  int SWIG_arg = 0;
  IVRendererNode *arg1 = (IVRendererNode *) 0 ;
  int result;
  
  SWIG_check_num_args("GetMultisampleMode",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetMultisampleMode",1,"IVRendererNode *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_IVRendererNode,0))){
    SWIG_fail_ptr("IVRendererNode_GetMultisampleMode",1,SWIGTYPE_p_IVRendererNode);
  }
  
  result = (int)IVRendererNode_GetMultisampleMode(arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_IVRendererNode_SetGammaCorrection(lua_State* L) {
  int SWIG_arg = 0;
  IVRendererNode *arg1 = (IVRendererNode *) 0 ;
  int arg2 ;
  bool result;
  
  SWIG_check_num_args("SetGammaCorrection",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetGammaCorrection",1,"IVRendererNode *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SetGammaCorrection",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_IVRendererNode,0))){
    SWIG_fail_ptr("IVRendererNode_SetGammaCorrection",1,SWIGTYPE_p_IVRendererNode);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  result = (bool)IVRendererNode_SetGammaCorrection(arg1,arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_IVRendererNode_GetGammaCorrection(lua_State* L) {
  int SWIG_arg = 0;
  IVRendererNode *arg1 = (IVRendererNode *) 0 ;
  int result;
  
  SWIG_check_num_args("GetGammaCorrection",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetGammaCorrection",1,"IVRendererNode *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_IVRendererNode,0))){
    SWIG_fail_ptr("IVRendererNode_GetGammaCorrection",1,SWIGTYPE_p_IVRendererNode);
  }
  
  result = (int)IVRendererNode_GetGammaCorrection(arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_IVRendererNode_SetUseHDR(lua_State* L) {
  int SWIG_arg = 0;
  IVRendererNode *arg1 = (IVRendererNode *) 0 ;
  bool arg2 ;
  bool result;
  
  SWIG_check_num_args("SetUseHDR",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetUseHDR",1,"IVRendererNode *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("SetUseHDR",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_IVRendererNode,0))){
    SWIG_fail_ptr("IVRendererNode_SetUseHDR",1,SWIGTYPE_p_IVRendererNode);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  result = (bool)IVRendererNode_SetUseHDR(arg1,arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_IVRendererNode_GetUseHDR(lua_State* L) {
  int SWIG_arg = 0;
  IVRendererNode *arg1 = (IVRendererNode *) 0 ;
  bool result;
  
  SWIG_check_num_args("GetUseHDR",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetUseHDR",1,"IVRendererNode *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_IVRendererNode,0))){
    SWIG_fail_ptr("IVRendererNode_GetUseHDR",1,SWIGTYPE_p_IVRendererNode);
  }
  
  result = (bool)IVRendererNode_GetUseHDR(arg1);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_IVRendererNode_IsInternalPostProcessor(lua_State* L) {
  int SWIG_arg = 0;
  IVRendererNode *arg1 = (IVRendererNode *) 0 ;
  VPostProcessingBaseComponent *arg2 = (VPostProcessingBaseComponent *) 0 ;
  bool result;
  
  SWIG_check_num_args("IsInternalPostProcessor",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("IsInternalPostProcessor",1,"IVRendererNode *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("IsInternalPostProcessor",2,"VPostProcessingBaseComponent *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_IVRendererNode,0))){
    SWIG_fail_ptr("IVRendererNode_IsInternalPostProcessor",1,SWIGTYPE_p_IVRendererNode);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_VPostProcessingBaseComponent,0))){
    SWIG_fail_ptr("IVRendererNode_IsInternalPostProcessor",2,SWIGTYPE_p_VPostProcessingBaseComponent);
  }
  
  result = (bool)IVRendererNode_IsInternalPostProcessor(arg1,arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_IVRendererNode_RemovePostProcessors(lua_State* L) {
  int SWIG_arg = 0;
  IVRendererNode *arg1 = (IVRendererNode *) 0 ;
  bool result;
  
  SWIG_check_num_args("RemovePostProcessors",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("RemovePostProcessors",1,"IVRendererNode *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_IVRendererNode,0))){
    SWIG_fail_ptr("IVRendererNode_RemovePostProcessors",1,SWIGTYPE_p_IVRendererNode);
  }
  
  result = (bool)IVRendererNode_RemovePostProcessors(arg1);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_IVRendererNode_SetRenderingEnabled(lua_State* L) {
  int SWIG_arg = 0;
  IVRendererNode *arg1 = (IVRendererNode *) 0 ;
  bool arg2 ;
  
  SWIG_check_num_args("SetRenderingEnabled",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetRenderingEnabled",1,"IVRendererNode *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("SetRenderingEnabled",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_IVRendererNode,0))){
    SWIG_fail_ptr("IVRendererNode_SetRenderingEnabled",1,SWIGTYPE_p_IVRendererNode);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  (arg1)->SetRenderingEnabled(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_IVRendererNode_GetRenderingEnabled(lua_State* L) {
  int SWIG_arg = 0;
  IVRendererNode *arg1 = (IVRendererNode *) 0 ;
  bool result;
  
  SWIG_check_num_args("GetRenderingEnabled",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetRenderingEnabled",1,"IVRendererNode const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_IVRendererNode,0))){
    SWIG_fail_ptr("IVRendererNode_GetRenderingEnabled",1,SWIGTYPE_p_IVRendererNode);
  }
  
  result = (bool)((IVRendererNode const *)arg1)->GetRenderingEnabled();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static swig_lua_method swig_IVRendererNode_methods[] = {
    { "__tostring",IVRendererNode_ToString},
    { "GetPostProcessor",IVRendererNode_GetPostProcessor},
    { "__concat",IVRendererNode_Concat},
    {"RemovePostProcessor", _wrap_IVRendererNode_RemovePostProcessor}, 
    {"AddPostProcessor", _wrap_IVRendererNode_AddPostProcessor}, 
    {"GetMultisampleMode", _wrap_IVRendererNode_GetMultisampleMode}, 
    {"SetGammaCorrection", _wrap_IVRendererNode_SetGammaCorrection}, 
    {"GetGammaCorrection", _wrap_IVRendererNode_GetGammaCorrection}, 
    {"SetUseHDR", _wrap_IVRendererNode_SetUseHDR}, 
    {"GetUseHDR", _wrap_IVRendererNode_GetUseHDR}, 
    {"IsInternalPostProcessor", _wrap_IVRendererNode_IsInternalPostProcessor}, 
    {"RemovePostProcessors", _wrap_IVRendererNode_RemovePostProcessors}, 
    {"SetRenderingEnabled", _wrap_IVRendererNode_SetRenderingEnabled}, 
    {"GetRenderingEnabled", _wrap_IVRendererNode_GetRenderingEnabled}, 
    {0,0}
};
static swig_lua_attribute swig_IVRendererNode_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_IVRendererNode_bases[] = {0,0};
static const char *swig_IVRendererNode_base_names[] = {"VisTypedEngineObject_cl *",0};
static swig_lua_class _wrap_class_IVRendererNode = { "IVRendererNode", &SWIGTYPE_p_IVRendererNode,0,0, swig_IVRendererNode_methods, swig_IVRendererNode_attributes, swig_IVRendererNode_bases, swig_IVRendererNode_base_names };

static int _wrap_VPostProcessingBaseComponent_IsValid(lua_State* L) {
  int SWIG_arg = 0;
  VPostProcessingBaseComponent *arg1 = (VPostProcessingBaseComponent *) 0 ;
  bool result;
  
  SWIG_check_num_args("IsValid",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("IsValid",1,"VPostProcessingBaseComponent const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VPostProcessingBaseComponent,0))){
    SWIG_fail_ptr("VPostProcessingBaseComponent_IsValid",1,SWIGTYPE_p_VPostProcessingBaseComponent);
  }
  
  result = (bool)((VPostProcessingBaseComponent const *)arg1)->IsValid();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VPostProcessingBaseComponent_SetActive(lua_State* L) {
  int SWIG_arg = 0;
  VPostProcessingBaseComponent *arg1 = (VPostProcessingBaseComponent *) 0 ;
  bool arg2 ;
  
  SWIG_check_num_args("SetActive",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetActive",1,"VPostProcessingBaseComponent *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("SetActive",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VPostProcessingBaseComponent,0))){
    SWIG_fail_ptr("VPostProcessingBaseComponent_SetActive",1,SWIGTYPE_p_VPostProcessingBaseComponent);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  (arg1)->SetActive(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VPostProcessingBaseComponent_IsActive(lua_State* L) {
  int SWIG_arg = 0;
  VPostProcessingBaseComponent *arg1 = (VPostProcessingBaseComponent *) 0 ;
  bool result;
  
  SWIG_check_num_args("IsActive",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("IsActive",1,"VPostProcessingBaseComponent const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VPostProcessingBaseComponent,0))){
    SWIG_fail_ptr("VPostProcessingBaseComponent_IsActive",1,SWIGTYPE_p_VPostProcessingBaseComponent);
  }
  
  result = (bool)((VPostProcessingBaseComponent const *)arg1)->IsActive();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static swig_lua_method swig_VPostProcessingBaseComponent_methods[] = {
    { "__tostring",VPostProcessingBaseComponent_ToString},
    { "__concat",VPostProcessingBaseComponent_Concat},
    {"IsValid", _wrap_VPostProcessingBaseComponent_IsValid}, 
    {"SetActive", _wrap_VPostProcessingBaseComponent_SetActive}, 
    {"IsActive", _wrap_VPostProcessingBaseComponent_IsActive}, 
    {0,0}
};
static swig_lua_attribute swig_VPostProcessingBaseComponent_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_VPostProcessingBaseComponent_bases[] = {0,0};
static const char *swig_VPostProcessingBaseComponent_base_names[] = {"IVObjectComponent *",0};
static swig_lua_class _wrap_class_VPostProcessingBaseComponent = { "VPostProcessingBaseComponent", &SWIGTYPE_p_VPostProcessingBaseComponent,0,0, swig_VPostProcessingBaseComponent_methods, swig_VPostProcessingBaseComponent_attributes, swig_VPostProcessingBaseComponent_bases, swig_VPostProcessingBaseComponent_base_names };

static int _wrap_CubeMapHandle_cl_SetActivate(lua_State* L) {
  int SWIG_arg = 0;
  CubeMapHandle_cl *arg1 = (CubeMapHandle_cl *) 0 ;
  bool arg2 ;
  
  SWIG_check_num_args("SetActivate",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetActivate",1,"CubeMapHandle_cl *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("SetActivate",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_CubeMapHandle_cl,0))){
    SWIG_fail_ptr("CubeMapHandle_cl_SetActivate",1,SWIGTYPE_p_CubeMapHandle_cl);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  (arg1)->SetActivate(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_CubeMapHandle_cl_GetCubeMapTexture(lua_State* L) {
  int SWIG_arg = 0;
  CubeMapHandle_cl *arg1 = (CubeMapHandle_cl *) 0 ;
  VTextureObject *result = 0 ;
  
  SWIG_check_num_args("GetCubeMapTexture",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetCubeMapTexture",1,"CubeMapHandle_cl *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_CubeMapHandle_cl,0))){
    SWIG_fail_ptr("CubeMapHandle_cl_GetCubeMapTexture",1,SWIGTYPE_p_CubeMapHandle_cl);
  }
  
  result = (VTextureObject *)(arg1)->GetCubeMapTexture();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_VTextureObject,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_CubeMapHandle_cl_GetSize(lua_State* L) {
  int SWIG_arg = 0;
  CubeMapHandle_cl *arg1 = (CubeMapHandle_cl *) 0 ;
  int result;
  
  SWIG_check_num_args("GetSize",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetSize",1,"CubeMapHandle_cl const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_CubeMapHandle_cl,0))){
    SWIG_fail_ptr("CubeMapHandle_cl_GetSize",1,SWIGTYPE_p_CubeMapHandle_cl);
  }
  
  result = (int)((CubeMapHandle_cl const *)arg1)->GetSize();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_CubeMapHandle_cl_SetContinuousUpdate(lua_State* L) {
  int SWIG_arg = 0;
  CubeMapHandle_cl *arg1 = (CubeMapHandle_cl *) 0 ;
  bool arg2 ;
  
  SWIG_check_num_args("SetContinuousUpdate",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetContinuousUpdate",1,"CubeMapHandle_cl *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("SetContinuousUpdate",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_CubeMapHandle_cl,0))){
    SWIG_fail_ptr("CubeMapHandle_cl_SetContinuousUpdate",1,SWIGTYPE_p_CubeMapHandle_cl);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  (arg1)->SetContinuousUpdate(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_CubeMapHandle_cl_SetAlternatingUpdate(lua_State* L) {
  int SWIG_arg = 0;
  CubeMapHandle_cl *arg1 = (CubeMapHandle_cl *) 0 ;
  bool arg2 ;
  
  SWIG_check_num_args("SetAlternatingUpdate",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetAlternatingUpdate",1,"CubeMapHandle_cl *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("SetAlternatingUpdate",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_CubeMapHandle_cl,0))){
    SWIG_fail_ptr("CubeMapHandle_cl_SetAlternatingUpdate",1,SWIGTYPE_p_CubeMapHandle_cl);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  (arg1)->SetAlternatingUpdate(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_CubeMapHandle_cl_GetContinuousUpdate(lua_State* L) {
  int SWIG_arg = 0;
  CubeMapHandle_cl *arg1 = (CubeMapHandle_cl *) 0 ;
  bool result;
  
  SWIG_check_num_args("GetContinuousUpdate",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetContinuousUpdate",1,"CubeMapHandle_cl const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_CubeMapHandle_cl,0))){
    SWIG_fail_ptr("CubeMapHandle_cl_GetContinuousUpdate",1,SWIGTYPE_p_CubeMapHandle_cl);
  }
  
  result = (bool)((CubeMapHandle_cl const *)arg1)->GetContinuousUpdate();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_CubeMapHandle_cl_SetUpdateParams(lua_State* L) {
  int SWIG_arg = 0;
  CubeMapHandle_cl *arg1 = (CubeMapHandle_cl *) 0 ;
  float arg2 ;
  int arg3 ;
  
  SWIG_check_num_args("SetUpdateParams",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetUpdateParams",1,"CubeMapHandle_cl *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SetUpdateParams",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("SetUpdateParams",3,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_CubeMapHandle_cl,0))){
    SWIG_fail_ptr("CubeMapHandle_cl_SetUpdateParams",1,SWIGTYPE_p_CubeMapHandle_cl);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (int)lua_tonumber(L, 3);
  (arg1)->SetUpdateParams(arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_CubeMapHandle_cl_Invalidate(lua_State* L) {
  int SWIG_arg = 0;
  CubeMapHandle_cl *arg1 = (CubeMapHandle_cl *) 0 ;
  
  SWIG_check_num_args("Invalidate",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Invalidate",1,"CubeMapHandle_cl *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_CubeMapHandle_cl,0))){
    SWIG_fail_ptr("CubeMapHandle_cl_Invalidate",1,SWIGTYPE_p_CubeMapHandle_cl);
  }
  
  (arg1)->Invalidate();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_CubeMapHandle_cl_GetBlurPasses(lua_State* L) {
  int SWIG_arg = 0;
  CubeMapHandle_cl *arg1 = (CubeMapHandle_cl *) 0 ;
  int result;
  
  SWIG_check_num_args("GetBlurPasses",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetBlurPasses",1,"CubeMapHandle_cl const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_CubeMapHandle_cl,0))){
    SWIG_fail_ptr("CubeMapHandle_cl_GetBlurPasses",1,SWIGTYPE_p_CubeMapHandle_cl);
  }
  
  result = (int)((CubeMapHandle_cl const *)arg1)->GetBlurPasses();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_CubeMapHandle_cl_GetAutoGenMipMaps(lua_State* L) {
  int SWIG_arg = 0;
  CubeMapHandle_cl *arg1 = (CubeMapHandle_cl *) 0 ;
  bool result;
  
  SWIG_check_num_args("GetAutoGenMipMaps",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetAutoGenMipMaps",1,"CubeMapHandle_cl const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_CubeMapHandle_cl,0))){
    SWIG_fail_ptr("CubeMapHandle_cl_GetAutoGenMipMaps",1,SWIGTYPE_p_CubeMapHandle_cl);
  }
  
  result = (bool)((CubeMapHandle_cl const *)arg1)->GetAutoGenMipMaps();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_CubeMapHandle_cl_SetRenderFilterMask(lua_State* L) {
  int SWIG_arg = 0;
  CubeMapHandle_cl *arg1 = (CubeMapHandle_cl *) 0 ;
  VBitmask *arg2 = (VBitmask *) 0 ;
  
  SWIG_check_num_args("SetRenderFilterMask",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetRenderFilterMask",1,"CubeMapHandle_cl *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SetRenderFilterMask",2,"VBitmask *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_CubeMapHandle_cl,0))){
    SWIG_fail_ptr("CubeMapHandle_cl_SetRenderFilterMask",1,SWIGTYPE_p_CubeMapHandle_cl);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_VBitmask,0))){
    SWIG_fail_ptr("CubeMapHandle_cl_SetRenderFilterMask",2,SWIGTYPE_p_VBitmask);
  }
  
  CubeMapHandle_cl_SetRenderFilterMask(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_CubeMapHandle_cl_GetRenderFilterMask(lua_State* L) {
  int SWIG_arg = 0;
  CubeMapHandle_cl *arg1 = (CubeMapHandle_cl *) 0 ;
  VBitmask result;
  
  SWIG_check_num_args("GetRenderFilterMask",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetRenderFilterMask",1,"CubeMapHandle_cl const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_CubeMapHandle_cl,0))){
    SWIG_fail_ptr("CubeMapHandle_cl_GetRenderFilterMask",1,SWIGTYPE_p_CubeMapHandle_cl);
  }
  
  result = CubeMapHandle_cl_GetRenderFilterMask((CubeMapHandle_cl const *)arg1);
  {
    VBitmask * resultptr = new VBitmask((const VBitmask &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_VBitmask,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static swig_lua_method swig_CubeMapHandle_cl_methods[] = {
    { "__tostring",CubeMapHandle_cl_ToString},
    { "GetUpdateParams",CubeMapHandle_cl_GetUpdateParams},
    { "GetClipPlanes",CubeMapHandle_cl_GetClipPlanes},
    { "__concat",CubeMapHandle_cl_Concat},
    {"SetActivate", _wrap_CubeMapHandle_cl_SetActivate}, 
    {"GetCubeMapTexture", _wrap_CubeMapHandle_cl_GetCubeMapTexture}, 
    {"GetSize", _wrap_CubeMapHandle_cl_GetSize}, 
    {"SetContinuousUpdate", _wrap_CubeMapHandle_cl_SetContinuousUpdate}, 
    {"SetAlternatingUpdate", _wrap_CubeMapHandle_cl_SetAlternatingUpdate}, 
    {"GetContinuousUpdate", _wrap_CubeMapHandle_cl_GetContinuousUpdate}, 
    {"SetUpdateParams", _wrap_CubeMapHandle_cl_SetUpdateParams}, 
    {"Invalidate", _wrap_CubeMapHandle_cl_Invalidate}, 
    {"GetBlurPasses", _wrap_CubeMapHandle_cl_GetBlurPasses}, 
    {"GetAutoGenMipMaps", _wrap_CubeMapHandle_cl_GetAutoGenMipMaps}, 
    {"SetRenderFilterMask", _wrap_CubeMapHandle_cl_SetRenderFilterMask}, 
    {"GetRenderFilterMask", _wrap_CubeMapHandle_cl_GetRenderFilterMask}, 
    {0,0}
};
static swig_lua_attribute swig_CubeMapHandle_cl_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_CubeMapHandle_cl_bases[] = {0,0};
static const char *swig_CubeMapHandle_cl_base_names[] = {"VisBaseEntity_cl *",0};
static swig_lua_class _wrap_class_CubeMapHandle_cl = { "CubeMapHandle_cl", &SWIGTYPE_p_CubeMapHandle_cl,0,0, swig_CubeMapHandle_cl_methods, swig_CubeMapHandle_cl_attributes, swig_CubeMapHandle_cl_bases, swig_CubeMapHandle_cl_base_names };

static int _wrap_PathCameraEntity_LoadScriptFile(lua_State* L) {
  int SWIG_arg = 0;
  PathCameraEntity *arg1 = (PathCameraEntity *) 0 ;
  char *arg2 = (char *) 0 ;
  bool result;
  
  SWIG_check_num_args("LoadScriptFile",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("LoadScriptFile",1,"PathCameraEntity *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("LoadScriptFile",2,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_PathCameraEntity,0))){
    SWIG_fail_ptr("PathCameraEntity_LoadScriptFile",1,SWIGTYPE_p_PathCameraEntity);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  result = (bool)(arg1)->LoadScriptFile((char const *)arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PathCameraEntity_FreeScriptFile(lua_State* L) {
  int SWIG_arg = 0;
  PathCameraEntity *arg1 = (PathCameraEntity *) 0 ;
  
  SWIG_check_num_args("FreeScriptFile",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("FreeScriptFile",1,"PathCameraEntity *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_PathCameraEntity,0))){
    SWIG_fail_ptr("PathCameraEntity_FreeScriptFile",1,SWIGTYPE_p_PathCameraEntity);
  }
  
  (arg1)->FreeScriptFile();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PathCameraEntity_Start(lua_State* L) {
  int SWIG_arg = 0;
  PathCameraEntity *arg1 = (PathCameraEntity *) 0 ;
  bool result;
  
  SWIG_check_num_args("Start",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Start",1,"PathCameraEntity *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_PathCameraEntity,0))){
    SWIG_fail_ptr("PathCameraEntity_Start",1,SWIGTYPE_p_PathCameraEntity);
  }
  
  result = (bool)(arg1)->Start();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PathCameraEntity_Stop(lua_State* L) {
  int SWIG_arg = 0;
  PathCameraEntity *arg1 = (PathCameraEntity *) 0 ;
  
  SWIG_check_num_args("Stop",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Stop",1,"PathCameraEntity *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_PathCameraEntity,0))){
    SWIG_fail_ptr("PathCameraEntity_Stop",1,SWIGTYPE_p_PathCameraEntity);
  }
  
  (arg1)->Stop();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PathCameraEntity_SetPause(lua_State* L) {
  int SWIG_arg = 0;
  PathCameraEntity *arg1 = (PathCameraEntity *) 0 ;
  bool arg2 ;
  
  SWIG_check_num_args("SetPause",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetPause",1,"PathCameraEntity *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("SetPause",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_PathCameraEntity,0))){
    SWIG_fail_ptr("PathCameraEntity_SetPause",1,SWIGTYPE_p_PathCameraEntity);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  (arg1)->SetPause(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PathCameraEntity_SetTimeScaling(lua_State* L) {
  int SWIG_arg = 0;
  PathCameraEntity *arg1 = (PathCameraEntity *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("SetTimeScaling",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetTimeScaling",1,"PathCameraEntity *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SetTimeScaling",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_PathCameraEntity,0))){
    SWIG_fail_ptr("PathCameraEntity_SetTimeScaling",1,SWIGTYPE_p_PathCameraEntity);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->SetTimeScaling(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PathCameraEntity_GetTimeScaling(lua_State* L) {
  int SWIG_arg = 0;
  PathCameraEntity *arg1 = (PathCameraEntity *) 0 ;
  float result;
  
  SWIG_check_num_args("GetTimeScaling",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetTimeScaling",1,"PathCameraEntity const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_PathCameraEntity,0))){
    SWIG_fail_ptr("PathCameraEntity_GetTimeScaling",1,SWIGTYPE_p_PathCameraEntity);
  }
  
  result = (float)((PathCameraEntity const *)arg1)->GetTimeScaling();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PathCameraEntity_IsPlaying(lua_State* L) {
  int SWIG_arg = 0;
  PathCameraEntity *arg1 = (PathCameraEntity *) 0 ;
  bool result;
  
  SWIG_check_num_args("IsPlaying",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("IsPlaying",1,"PathCameraEntity const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_PathCameraEntity,0))){
    SWIG_fail_ptr("PathCameraEntity_IsPlaying",1,SWIGTYPE_p_PathCameraEntity);
  }
  
  result = (bool)((PathCameraEntity const *)arg1)->IsPlaying();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PathCameraEntity_IsPaused(lua_State* L) {
  int SWIG_arg = 0;
  PathCameraEntity *arg1 = (PathCameraEntity *) 0 ;
  bool result;
  
  SWIG_check_num_args("IsPaused",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("IsPaused",1,"PathCameraEntity const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_PathCameraEntity,0))){
    SWIG_fail_ptr("PathCameraEntity_IsPaused",1,SWIGTYPE_p_PathCameraEntity);
  }
  
  result = (bool)((PathCameraEntity const *)arg1)->IsPaused();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PathCameraEntity_AttachToRendererNode(lua_State* L) {
  int SWIG_arg = 0;
  PathCameraEntity *arg1 = (PathCameraEntity *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("AttachToRendererNode",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("AttachToRendererNode",1,"PathCameraEntity *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("AttachToRendererNode",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_PathCameraEntity,0))){
    SWIG_fail_ptr("PathCameraEntity_AttachToRendererNode",1,SWIGTYPE_p_PathCameraEntity);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->AttachToRendererNode(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static swig_lua_method swig_PathCameraEntity_methods[] = {
    {"LoadScriptFile", _wrap_PathCameraEntity_LoadScriptFile}, 
    {"FreeScriptFile", _wrap_PathCameraEntity_FreeScriptFile}, 
    {"Start", _wrap_PathCameraEntity_Start}, 
    {"Stop", _wrap_PathCameraEntity_Stop}, 
    {"SetPause", _wrap_PathCameraEntity_SetPause}, 
    {"SetTimeScaling", _wrap_PathCameraEntity_SetTimeScaling}, 
    {"GetTimeScaling", _wrap_PathCameraEntity_GetTimeScaling}, 
    {"IsPlaying", _wrap_PathCameraEntity_IsPlaying}, 
    {"IsPaused", _wrap_PathCameraEntity_IsPaused}, 
    {"AttachToRendererNode", _wrap_PathCameraEntity_AttachToRendererNode}, 
    {0,0}
};
static swig_lua_attribute swig_PathCameraEntity_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_PathCameraEntity_bases[] = {0,0};
static const char *swig_PathCameraEntity_base_names[] = {"VisBaseEntity_cl *",0};
static swig_lua_class _wrap_class_PathCameraEntity = { "PathCameraEntity", &SWIGTYPE_p_PathCameraEntity,0,0, swig_PathCameraEntity_methods, swig_PathCameraEntity_attributes, swig_PathCameraEntity_bases, swig_PathCameraEntity_base_names };

static int _wrap_IVisTriggerBaseComponent_cl_SetDisplayName(lua_State* L) {
  int SWIG_arg = 0;
  IVisTriggerBaseComponent_cl *arg1 = (IVisTriggerBaseComponent_cl *) 0 ;
  char *arg2 = (char *) 0 ;
  
  SWIG_check_num_args("SetDisplayName",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetDisplayName",1,"IVisTriggerBaseComponent_cl *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("SetDisplayName",2,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_IVisTriggerBaseComponent_cl,0))){
    SWIG_fail_ptr("IVisTriggerBaseComponent_cl_SetDisplayName",1,SWIGTYPE_p_IVisTriggerBaseComponent_cl);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  IVisTriggerBaseComponent_cl_SetDisplayName(arg1,(char const *)arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_IVisTriggerBaseComponent_cl_SetIconFilename(lua_State* L) {
  int SWIG_arg = 0;
  IVisTriggerBaseComponent_cl *arg1 = (IVisTriggerBaseComponent_cl *) 0 ;
  char *arg2 = (char *) 0 ;
  
  SWIG_check_num_args("SetIconFilename",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetIconFilename",1,"IVisTriggerBaseComponent_cl *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("SetIconFilename",2,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_IVisTriggerBaseComponent_cl,0))){
    SWIG_fail_ptr("IVisTriggerBaseComponent_cl_SetIconFilename",1,SWIGTYPE_p_IVisTriggerBaseComponent_cl);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  IVisTriggerBaseComponent_cl_SetIconFilename(arg1,(char const *)arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static swig_lua_method swig_IVisTriggerBaseComponent_cl_methods[] = {
    { "__tostring",IVisTriggerBaseComponent_cl_ToString},
    {"SetDisplayName", _wrap_IVisTriggerBaseComponent_cl_SetDisplayName}, 
    {"SetIconFilename", _wrap_IVisTriggerBaseComponent_cl_SetIconFilename}, 
    {0,0}
};
static swig_lua_attribute swig_IVisTriggerBaseComponent_cl_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_IVisTriggerBaseComponent_cl_bases[] = {0,0};
static const char *swig_IVisTriggerBaseComponent_cl_base_names[] = {"IVObjectComponent *",0};
static swig_lua_class _wrap_class_IVisTriggerBaseComponent_cl = { "IVisTriggerBaseComponent_cl", &SWIGTYPE_p_IVisTriggerBaseComponent_cl,0,0, swig_IVisTriggerBaseComponent_cl_methods, swig_IVisTriggerBaseComponent_cl_attributes, swig_IVisTriggerBaseComponent_cl_bases, swig_IVisTriggerBaseComponent_cl_base_names };

static int _wrap_VisTriggerSourceComponent_cl_UnlinkAllTargets(lua_State* L) {
  int SWIG_arg = 0;
  VisTriggerSourceComponent_cl *arg1 = (VisTriggerSourceComponent_cl *) 0 ;
  
  SWIG_check_num_args("UnlinkAllTargets",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("UnlinkAllTargets",1,"VisTriggerSourceComponent_cl *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisTriggerSourceComponent_cl,0))){
    SWIG_fail_ptr("VisTriggerSourceComponent_cl_UnlinkAllTargets",1,SWIGTYPE_p_VisTriggerSourceComponent_cl);
  }
  
  (arg1)->UnlinkAllTargets();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisTriggerSourceComponent_cl_TriggerAllTargets(lua_State* L) {
  int SWIG_arg = 0;
  VisTriggerSourceComponent_cl *arg1 = (VisTriggerSourceComponent_cl *) 0 ;
  
  SWIG_check_num_args("TriggerAllTargets",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("TriggerAllTargets",1,"VisTriggerSourceComponent_cl *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisTriggerSourceComponent_cl,0))){
    SWIG_fail_ptr("VisTriggerSourceComponent_cl_TriggerAllTargets",1,SWIGTYPE_p_VisTriggerSourceComponent_cl);
  }
  
  (arg1)->TriggerAllTargets();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisTriggerSourceComponent_cl_LinkToTarget__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  VisTriggerSourceComponent_cl *arg1 = (VisTriggerSourceComponent_cl *) 0 ;
  VisTriggerTargetComponent_cl *arg2 = (VisTriggerTargetComponent_cl *) 0 ;
  int result;
  
  SWIG_check_num_args("LinkToTarget",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("LinkToTarget",1,"VisTriggerSourceComponent_cl *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("LinkToTarget",2,"VisTriggerTargetComponent_cl *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisTriggerSourceComponent_cl,0))){
    SWIG_fail_ptr("VisTriggerSourceComponent_cl_LinkToTarget",1,SWIGTYPE_p_VisTriggerSourceComponent_cl);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_VisTriggerTargetComponent_cl,0))){
    SWIG_fail_ptr("VisTriggerSourceComponent_cl_LinkToTarget",2,SWIGTYPE_p_VisTriggerTargetComponent_cl);
  }
  
  result = (int)VisTriggerSourceComponent_cl_LinkToTarget__SWIG_0(arg1,arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisTriggerSourceComponent_cl_LinkToTarget__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  VisTriggerSourceComponent_cl *arg1 = (VisTriggerSourceComponent_cl *) 0 ;
  char *arg2 = (char *) 0 ;
  VisTypedEngineObject_cl *arg3 = (VisTypedEngineObject_cl *) 0 ;
  int result;
  
  SWIG_check_num_args("LinkToTarget",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("LinkToTarget",1,"VisTriggerSourceComponent_cl *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("LinkToTarget",2,"char const *");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("LinkToTarget",3,"VisTypedEngineObject_cl *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisTriggerSourceComponent_cl,0))){
    SWIG_fail_ptr("VisTriggerSourceComponent_cl_LinkToTarget",1,SWIGTYPE_p_VisTriggerSourceComponent_cl);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_VisTypedEngineObject_cl,0))){
    SWIG_fail_ptr("VisTriggerSourceComponent_cl_LinkToTarget",3,SWIGTYPE_p_VisTypedEngineObject_cl);
  }
  
  result = (int)VisTriggerSourceComponent_cl_LinkToTarget__SWIG_1(arg1,(char const *)arg2,arg3);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisTriggerSourceComponent_cl_LinkToTarget__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  VisTriggerSourceComponent_cl *arg1 = (VisTriggerSourceComponent_cl *) 0 ;
  char *arg2 = (char *) 0 ;
  int result;
  
  SWIG_check_num_args("LinkToTarget",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("LinkToTarget",1,"VisTriggerSourceComponent_cl *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("LinkToTarget",2,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisTriggerSourceComponent_cl,0))){
    SWIG_fail_ptr("VisTriggerSourceComponent_cl_LinkToTarget",1,SWIGTYPE_p_VisTriggerSourceComponent_cl);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  result = (int)VisTriggerSourceComponent_cl_LinkToTarget__SWIG_1(arg1,(char const *)arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisTriggerSourceComponent_cl_LinkToTarget(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VisTriggerSourceComponent_cl, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_VisTriggerTargetComponent_cl, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_VisTriggerSourceComponent_cl_LinkToTarget__SWIG_0(L);
      }
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VisTriggerSourceComponent_cl, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = SWIG_lua_isnilstring(L,argv[1]);
      }
      if (_v) {
        return _wrap_VisTriggerSourceComponent_cl_LinkToTarget__SWIG_2(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VisTriggerSourceComponent_cl, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = SWIG_lua_isnilstring(L,argv[1]);
      }
      if (_v) {
        {
          void *ptr;
          if (SWIG_isptrtype(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_VisTypedEngineObject_cl, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          return _wrap_VisTriggerSourceComponent_cl_LinkToTarget__SWIG_1(L);
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'VisTriggerSourceComponent_cl_LinkToTarget'\n"
    "  Possible C/C++ prototypes are:\n"
    "    LinkToTarget(VisTriggerSourceComponent_cl *,VisTriggerTargetComponent_cl *)\n"
    "    LinkToTarget(VisTriggerSourceComponent_cl *,char const *,VisTypedEngineObject_cl *)\n"
    "    LinkToTarget(VisTriggerSourceComponent_cl *,char const *)\n");
  lua_error(L);return 0;
}


static int _wrap_VisTriggerSourceComponent_cl_UnlinkFromTarget__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  VisTriggerSourceComponent_cl *arg1 = (VisTriggerSourceComponent_cl *) 0 ;
  VisTriggerTargetComponent_cl *arg2 = (VisTriggerTargetComponent_cl *) 0 ;
  int result;
  
  SWIG_check_num_args("UnlinkFromTarget",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("UnlinkFromTarget",1,"VisTriggerSourceComponent_cl *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("UnlinkFromTarget",2,"VisTriggerTargetComponent_cl *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisTriggerSourceComponent_cl,0))){
    SWIG_fail_ptr("VisTriggerSourceComponent_cl_UnlinkFromTarget",1,SWIGTYPE_p_VisTriggerSourceComponent_cl);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_VisTriggerTargetComponent_cl,0))){
    SWIG_fail_ptr("VisTriggerSourceComponent_cl_UnlinkFromTarget",2,SWIGTYPE_p_VisTriggerTargetComponent_cl);
  }
  
  result = (int)VisTriggerSourceComponent_cl_UnlinkFromTarget__SWIG_0(arg1,arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisTriggerSourceComponent_cl_UnlinkFromTarget__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  VisTriggerSourceComponent_cl *arg1 = (VisTriggerSourceComponent_cl *) 0 ;
  char *arg2 = (char *) 0 ;
  VisTypedEngineObject_cl *arg3 = (VisTypedEngineObject_cl *) 0 ;
  int result;
  
  SWIG_check_num_args("UnlinkFromTarget",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("UnlinkFromTarget",1,"VisTriggerSourceComponent_cl *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("UnlinkFromTarget",2,"char const *");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("UnlinkFromTarget",3,"VisTypedEngineObject_cl *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisTriggerSourceComponent_cl,0))){
    SWIG_fail_ptr("VisTriggerSourceComponent_cl_UnlinkFromTarget",1,SWIGTYPE_p_VisTriggerSourceComponent_cl);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_VisTypedEngineObject_cl,0))){
    SWIG_fail_ptr("VisTriggerSourceComponent_cl_UnlinkFromTarget",3,SWIGTYPE_p_VisTypedEngineObject_cl);
  }
  
  result = (int)VisTriggerSourceComponent_cl_UnlinkFromTarget__SWIG_1(arg1,(char const *)arg2,arg3);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisTriggerSourceComponent_cl_UnlinkFromTarget__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  VisTriggerSourceComponent_cl *arg1 = (VisTriggerSourceComponent_cl *) 0 ;
  char *arg2 = (char *) 0 ;
  int result;
  
  SWIG_check_num_args("UnlinkFromTarget",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("UnlinkFromTarget",1,"VisTriggerSourceComponent_cl *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("UnlinkFromTarget",2,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisTriggerSourceComponent_cl,0))){
    SWIG_fail_ptr("VisTriggerSourceComponent_cl_UnlinkFromTarget",1,SWIGTYPE_p_VisTriggerSourceComponent_cl);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  result = (int)VisTriggerSourceComponent_cl_UnlinkFromTarget__SWIG_1(arg1,(char const *)arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisTriggerSourceComponent_cl_UnlinkFromTarget(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VisTriggerSourceComponent_cl, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_VisTriggerTargetComponent_cl, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_VisTriggerSourceComponent_cl_UnlinkFromTarget__SWIG_0(L);
      }
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VisTriggerSourceComponent_cl, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = SWIG_lua_isnilstring(L,argv[1]);
      }
      if (_v) {
        return _wrap_VisTriggerSourceComponent_cl_UnlinkFromTarget__SWIG_2(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VisTriggerSourceComponent_cl, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = SWIG_lua_isnilstring(L,argv[1]);
      }
      if (_v) {
        {
          void *ptr;
          if (SWIG_isptrtype(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_VisTypedEngineObject_cl, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          return _wrap_VisTriggerSourceComponent_cl_UnlinkFromTarget__SWIG_1(L);
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'VisTriggerSourceComponent_cl_UnlinkFromTarget'\n"
    "  Possible C/C++ prototypes are:\n"
    "    UnlinkFromTarget(VisTriggerSourceComponent_cl *,VisTriggerTargetComponent_cl *)\n"
    "    UnlinkFromTarget(VisTriggerSourceComponent_cl *,char const *,VisTypedEngineObject_cl *)\n"
    "    UnlinkFromTarget(VisTriggerSourceComponent_cl *,char const *)\n");
  lua_error(L);return 0;
}


static int _wrap_VisTriggerSourceComponent_cl_Cast(lua_State* L) {
  int SWIG_arg = 0;
  VTypedObject *arg1 = (VTypedObject *) 0 ;
  VisTriggerSourceComponent_cl *result = 0 ;
  
  SWIG_check_num_args("VisTriggerSourceComponent_cl_Cast",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("VisTriggerSourceComponent_cl_Cast",1,"VTypedObject *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VTypedObject,0))){
    SWIG_fail_ptr("VisTriggerSourceComponent_cl_Cast",1,SWIGTYPE_p_VTypedObject);
  }
  
  result = (VisTriggerSourceComponent_cl *)VisTriggerSourceComponent_cl_Cast(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_VisTriggerSourceComponent_cl,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static swig_lua_method swig_VisTriggerSourceComponent_cl_methods[] = {
    {"UnlinkAllTargets", _wrap_VisTriggerSourceComponent_cl_UnlinkAllTargets}, 
    {"TriggerAllTargets", _wrap_VisTriggerSourceComponent_cl_TriggerAllTargets}, 
    {"LinkToTarget", _wrap_VisTriggerSourceComponent_cl_LinkToTarget}, 
    {"UnlinkFromTarget", _wrap_VisTriggerSourceComponent_cl_UnlinkFromTarget}, 
    {0,0}
};
static swig_lua_attribute swig_VisTriggerSourceComponent_cl_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_VisTriggerSourceComponent_cl_bases[] = {0,0};
static const char *swig_VisTriggerSourceComponent_cl_base_names[] = {"IVisTriggerBaseComponent_cl *",0};
static swig_lua_class _wrap_class_VisTriggerSourceComponent_cl = { "VisTriggerSourceComponent_cl", &SWIGTYPE_p_VisTriggerSourceComponent_cl,0,0, swig_VisTriggerSourceComponent_cl_methods, swig_VisTriggerSourceComponent_cl_attributes, swig_VisTriggerSourceComponent_cl_bases, swig_VisTriggerSourceComponent_cl_base_names };

static int _wrap_VisTriggerTargetComponent_cl_UnlinkAllSources(lua_State* L) {
  int SWIG_arg = 0;
  VisTriggerTargetComponent_cl *arg1 = (VisTriggerTargetComponent_cl *) 0 ;
  
  SWIG_check_num_args("UnlinkAllSources",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("UnlinkAllSources",1,"VisTriggerTargetComponent_cl *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisTriggerTargetComponent_cl,0))){
    SWIG_fail_ptr("VisTriggerTargetComponent_cl_UnlinkAllSources",1,SWIGTYPE_p_VisTriggerTargetComponent_cl);
  }
  
  (arg1)->UnlinkAllSources();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisTriggerTargetComponent_cl_LinkToSource__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  VisTriggerTargetComponent_cl *arg1 = (VisTriggerTargetComponent_cl *) 0 ;
  VisTriggerSourceComponent_cl *arg2 = (VisTriggerSourceComponent_cl *) 0 ;
  int result;
  
  SWIG_check_num_args("LinkToSource",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("LinkToSource",1,"VisTriggerTargetComponent_cl *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("LinkToSource",2,"VisTriggerSourceComponent_cl *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisTriggerTargetComponent_cl,0))){
    SWIG_fail_ptr("VisTriggerTargetComponent_cl_LinkToSource",1,SWIGTYPE_p_VisTriggerTargetComponent_cl);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_VisTriggerSourceComponent_cl,0))){
    SWIG_fail_ptr("VisTriggerTargetComponent_cl_LinkToSource",2,SWIGTYPE_p_VisTriggerSourceComponent_cl);
  }
  
  result = (int)VisTriggerTargetComponent_cl_LinkToSource__SWIG_0(arg1,arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisTriggerTargetComponent_cl_LinkToSource__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  VisTriggerTargetComponent_cl *arg1 = (VisTriggerTargetComponent_cl *) 0 ;
  char *arg2 = (char *) 0 ;
  VisTypedEngineObject_cl *arg3 = (VisTypedEngineObject_cl *) 0 ;
  int result;
  
  SWIG_check_num_args("LinkToSource",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("LinkToSource",1,"VisTriggerTargetComponent_cl *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("LinkToSource",2,"char const *");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("LinkToSource",3,"VisTypedEngineObject_cl *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisTriggerTargetComponent_cl,0))){
    SWIG_fail_ptr("VisTriggerTargetComponent_cl_LinkToSource",1,SWIGTYPE_p_VisTriggerTargetComponent_cl);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_VisTypedEngineObject_cl,0))){
    SWIG_fail_ptr("VisTriggerTargetComponent_cl_LinkToSource",3,SWIGTYPE_p_VisTypedEngineObject_cl);
  }
  
  result = (int)VisTriggerTargetComponent_cl_LinkToSource__SWIG_1(arg1,(char const *)arg2,arg3);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisTriggerTargetComponent_cl_LinkToSource__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  VisTriggerTargetComponent_cl *arg1 = (VisTriggerTargetComponent_cl *) 0 ;
  char *arg2 = (char *) 0 ;
  int result;
  
  SWIG_check_num_args("LinkToSource",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("LinkToSource",1,"VisTriggerTargetComponent_cl *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("LinkToSource",2,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisTriggerTargetComponent_cl,0))){
    SWIG_fail_ptr("VisTriggerTargetComponent_cl_LinkToSource",1,SWIGTYPE_p_VisTriggerTargetComponent_cl);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  result = (int)VisTriggerTargetComponent_cl_LinkToSource__SWIG_1(arg1,(char const *)arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisTriggerTargetComponent_cl_LinkToSource(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VisTriggerTargetComponent_cl, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_VisTriggerSourceComponent_cl, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_VisTriggerTargetComponent_cl_LinkToSource__SWIG_0(L);
      }
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VisTriggerTargetComponent_cl, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = SWIG_lua_isnilstring(L,argv[1]);
      }
      if (_v) {
        return _wrap_VisTriggerTargetComponent_cl_LinkToSource__SWIG_2(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VisTriggerTargetComponent_cl, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = SWIG_lua_isnilstring(L,argv[1]);
      }
      if (_v) {
        {
          void *ptr;
          if (SWIG_isptrtype(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_VisTypedEngineObject_cl, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          return _wrap_VisTriggerTargetComponent_cl_LinkToSource__SWIG_1(L);
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'VisTriggerTargetComponent_cl_LinkToSource'\n"
    "  Possible C/C++ prototypes are:\n"
    "    LinkToSource(VisTriggerTargetComponent_cl *,VisTriggerSourceComponent_cl *)\n"
    "    LinkToSource(VisTriggerTargetComponent_cl *,char const *,VisTypedEngineObject_cl *)\n"
    "    LinkToSource(VisTriggerTargetComponent_cl *,char const *)\n");
  lua_error(L);return 0;
}


static int _wrap_VisTriggerTargetComponent_cl_UnlinkFromSource__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  VisTriggerTargetComponent_cl *arg1 = (VisTriggerTargetComponent_cl *) 0 ;
  VisTriggerSourceComponent_cl *arg2 = (VisTriggerSourceComponent_cl *) 0 ;
  int result;
  
  SWIG_check_num_args("UnlinkFromSource",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("UnlinkFromSource",1,"VisTriggerTargetComponent_cl *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("UnlinkFromSource",2,"VisTriggerSourceComponent_cl *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisTriggerTargetComponent_cl,0))){
    SWIG_fail_ptr("VisTriggerTargetComponent_cl_UnlinkFromSource",1,SWIGTYPE_p_VisTriggerTargetComponent_cl);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_VisTriggerSourceComponent_cl,0))){
    SWIG_fail_ptr("VisTriggerTargetComponent_cl_UnlinkFromSource",2,SWIGTYPE_p_VisTriggerSourceComponent_cl);
  }
  
  result = (int)VisTriggerTargetComponent_cl_UnlinkFromSource__SWIG_0(arg1,arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisTriggerTargetComponent_cl_UnlinkFromSource__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  VisTriggerTargetComponent_cl *arg1 = (VisTriggerTargetComponent_cl *) 0 ;
  char *arg2 = (char *) 0 ;
  VisTypedEngineObject_cl *arg3 = (VisTypedEngineObject_cl *) 0 ;
  int result;
  
  SWIG_check_num_args("UnlinkFromSource",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("UnlinkFromSource",1,"VisTriggerTargetComponent_cl *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("UnlinkFromSource",2,"char const *");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("UnlinkFromSource",3,"VisTypedEngineObject_cl *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisTriggerTargetComponent_cl,0))){
    SWIG_fail_ptr("VisTriggerTargetComponent_cl_UnlinkFromSource",1,SWIGTYPE_p_VisTriggerTargetComponent_cl);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_VisTypedEngineObject_cl,0))){
    SWIG_fail_ptr("VisTriggerTargetComponent_cl_UnlinkFromSource",3,SWIGTYPE_p_VisTypedEngineObject_cl);
  }
  
  result = (int)VisTriggerTargetComponent_cl_UnlinkFromSource__SWIG_1(arg1,(char const *)arg2,arg3);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisTriggerTargetComponent_cl_UnlinkFromSource__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  VisTriggerTargetComponent_cl *arg1 = (VisTriggerTargetComponent_cl *) 0 ;
  char *arg2 = (char *) 0 ;
  int result;
  
  SWIG_check_num_args("UnlinkFromSource",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("UnlinkFromSource",1,"VisTriggerTargetComponent_cl *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("UnlinkFromSource",2,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisTriggerTargetComponent_cl,0))){
    SWIG_fail_ptr("VisTriggerTargetComponent_cl_UnlinkFromSource",1,SWIGTYPE_p_VisTriggerTargetComponent_cl);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  result = (int)VisTriggerTargetComponent_cl_UnlinkFromSource__SWIG_1(arg1,(char const *)arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisTriggerTargetComponent_cl_UnlinkFromSource(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VisTriggerTargetComponent_cl, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_VisTriggerSourceComponent_cl, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_VisTriggerTargetComponent_cl_UnlinkFromSource__SWIG_0(L);
      }
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VisTriggerTargetComponent_cl, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = SWIG_lua_isnilstring(L,argv[1]);
      }
      if (_v) {
        return _wrap_VisTriggerTargetComponent_cl_UnlinkFromSource__SWIG_2(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VisTriggerTargetComponent_cl, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = SWIG_lua_isnilstring(L,argv[1]);
      }
      if (_v) {
        {
          void *ptr;
          if (SWIG_isptrtype(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_VisTypedEngineObject_cl, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          return _wrap_VisTriggerTargetComponent_cl_UnlinkFromSource__SWIG_1(L);
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'VisTriggerTargetComponent_cl_UnlinkFromSource'\n"
    "  Possible C/C++ prototypes are:\n"
    "    UnlinkFromSource(VisTriggerTargetComponent_cl *,VisTriggerSourceComponent_cl *)\n"
    "    UnlinkFromSource(VisTriggerTargetComponent_cl *,char const *,VisTypedEngineObject_cl *)\n"
    "    UnlinkFromSource(VisTriggerTargetComponent_cl *,char const *)\n");
  lua_error(L);return 0;
}


static int _wrap_VisTriggerTargetComponent_cl_Cast(lua_State* L) {
  int SWIG_arg = 0;
  VTypedObject *arg1 = (VTypedObject *) 0 ;
  VisTriggerTargetComponent_cl *result = 0 ;
  
  SWIG_check_num_args("VisTriggerTargetComponent_cl_Cast",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("VisTriggerTargetComponent_cl_Cast",1,"VTypedObject *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VTypedObject,0))){
    SWIG_fail_ptr("VisTriggerTargetComponent_cl_Cast",1,SWIGTYPE_p_VTypedObject);
  }
  
  result = (VisTriggerTargetComponent_cl *)VisTriggerTargetComponent_cl_Cast(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_VisTriggerTargetComponent_cl,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static swig_lua_method swig_VisTriggerTargetComponent_cl_methods[] = {
    {"UnlinkAllSources", _wrap_VisTriggerTargetComponent_cl_UnlinkAllSources}, 
    {"LinkToSource", _wrap_VisTriggerTargetComponent_cl_LinkToSource}, 
    {"UnlinkFromSource", _wrap_VisTriggerTargetComponent_cl_UnlinkFromSource}, 
    {0,0}
};
static swig_lua_attribute swig_VisTriggerTargetComponent_cl_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_VisTriggerTargetComponent_cl_bases[] = {0,0};
static const char *swig_VisTriggerTargetComponent_cl_base_names[] = {"IVisTriggerBaseComponent_cl *",0};
static swig_lua_class _wrap_class_VisTriggerTargetComponent_cl = { "VisTriggerTargetComponent_cl", &SWIGTYPE_p_VisTriggerTargetComponent_cl,0,0, swig_VisTriggerTargetComponent_cl_methods, swig_VisTriggerTargetComponent_cl_attributes, swig_VisTriggerTargetComponent_cl_bases, swig_VisTriggerTargetComponent_cl_base_names };

static int _wrap_EVENT_TRANSITION_STARTED_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("EVENT_TRANSITION_STARTED",0,0)
  result = (int)(int)EVENT_TRANSITION_STARTED;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_EVENT_TRANSITION_FINISHED_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("EVENT_TRANSITION_FINISHED",0,0)
  result = (int)(int)EVENT_TRANSITION_FINISHED;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_EVENT_SEQUENCE_STARTED_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("EVENT_SEQUENCE_STARTED",0,0)
  result = (int)(int)EVENT_SEQUENCE_STARTED;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_EVENT_SEQUENCE_FINISHED_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("EVENT_SEQUENCE_FINISHED",0,0)
  result = (int)(int)EVENT_SEQUENCE_FINISHED;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_EVENT_TRANSITION_START_REACHED_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("EVENT_TRANSITION_START_REACHED",0,0)
  result = (int)(int)EVENT_TRANSITION_START_REACHED;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VTransitionStateMachine_IsEnabled(lua_State* L) {
  int SWIG_arg = 0;
  VTransitionStateMachine *arg1 = (VTransitionStateMachine *) 0 ;
  bool result;
  
  SWIG_check_num_args("IsEnabled",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("IsEnabled",1,"VTransitionStateMachine const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VTransitionStateMachine,0))){
    SWIG_fail_ptr("VTransitionStateMachine_IsEnabled",1,SWIGTYPE_p_VTransitionStateMachine);
  }
  
  result = (bool)((VTransitionStateMachine const *)arg1)->IsEnabled();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VTransitionStateMachine_SetState(lua_State* L) {
  int SWIG_arg = 0;
  VTransitionStateMachine *arg1 = (VTransitionStateMachine *) 0 ;
  char *arg2 = (char *) 0 ;
  
  SWIG_check_num_args("SetState",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetState",1,"VTransitionStateMachine *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("SetState",2,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VTransitionStateMachine,0))){
    SWIG_fail_ptr("VTransitionStateMachine_SetState",1,SWIGTYPE_p_VTransitionStateMachine);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  (arg1)->SetState((char const *)arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VTransitionStateMachine_IsBlending(lua_State* L) {
  int SWIG_arg = 0;
  VTransitionStateMachine *arg1 = (VTransitionStateMachine *) 0 ;
  bool result;
  
  SWIG_check_num_args("IsBlending",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("IsBlending",1,"VTransitionStateMachine *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VTransitionStateMachine,0))){
    SWIG_fail_ptr("VTransitionStateMachine_IsBlending",1,SWIGTYPE_p_VTransitionStateMachine);
  }
  
  result = (bool)(arg1)->IsBlending();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VTransitionStateMachine_IsWaitingForSyncBlending(lua_State* L) {
  int SWIG_arg = 0;
  VTransitionStateMachine *arg1 = (VTransitionStateMachine *) 0 ;
  bool result;
  
  SWIG_check_num_args("IsWaitingForSyncBlending",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("IsWaitingForSyncBlending",1,"VTransitionStateMachine *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VTransitionStateMachine,0))){
    SWIG_fail_ptr("VTransitionStateMachine_IsWaitingForSyncBlending",1,SWIGTYPE_p_VTransitionStateMachine);
  }
  
  result = (bool)(arg1)->IsWaitingForSyncBlending();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VTransitionStateMachine_SetForwardingAnimEvents(lua_State* L) {
  int SWIG_arg = 0;
  VTransitionStateMachine *arg1 = (VTransitionStateMachine *) 0 ;
  bool arg2 ;
  
  SWIG_check_num_args("SetForwardingAnimEvents",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetForwardingAnimEvents",1,"VTransitionStateMachine *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("SetForwardingAnimEvents",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VTransitionStateMachine,0))){
    SWIG_fail_ptr("VTransitionStateMachine_SetForwardingAnimEvents",1,SWIGTYPE_p_VTransitionStateMachine);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  (arg1)->SetForwardingAnimEvents(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VTransitionStateMachine_AddEventListener(lua_State* L) {
  int SWIG_arg = 0;
  VTransitionStateMachine *arg1 = (VTransitionStateMachine *) 0 ;
  VisTypedEngineObject_cl *arg2 = (VisTypedEngineObject_cl *) 0 ;
  int result;
  
  SWIG_check_num_args("AddEventListener",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("AddEventListener",1,"VTransitionStateMachine *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("AddEventListener",2,"VisTypedEngineObject_cl *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VTransitionStateMachine,0))){
    SWIG_fail_ptr("VTransitionStateMachine_AddEventListener",1,SWIGTYPE_p_VTransitionStateMachine);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_VisTypedEngineObject_cl,0))){
    SWIG_fail_ptr("VTransitionStateMachine_AddEventListener",2,SWIGTYPE_p_VisTypedEngineObject_cl);
  }
  
  result = (int)(arg1)->AddEventListener(arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VTransitionStateMachine_RemoveEventListener(lua_State* L) {
  int SWIG_arg = 0;
  VTransitionStateMachine *arg1 = (VTransitionStateMachine *) 0 ;
  VisTypedEngineObject_cl *arg2 = (VisTypedEngineObject_cl *) 0 ;
  bool result;
  
  SWIG_check_num_args("RemoveEventListener",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("RemoveEventListener",1,"VTransitionStateMachine *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("RemoveEventListener",2,"VisTypedEngineObject_cl *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VTransitionStateMachine,0))){
    SWIG_fail_ptr("VTransitionStateMachine_RemoveEventListener",1,SWIGTYPE_p_VTransitionStateMachine);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_VisTypedEngineObject_cl,0))){
    SWIG_fail_ptr("VTransitionStateMachine_RemoveEventListener",2,SWIGTYPE_p_VisTypedEngineObject_cl);
  }
  
  result = (bool)(arg1)->RemoveEventListener(arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VTransitionStateMachine_SetEnabled(lua_State* L) {
  int SWIG_arg = 0;
  VTransitionStateMachine *arg1 = (VTransitionStateMachine *) 0 ;
  bool arg2 ;
  
  SWIG_check_num_args("SetEnabled",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetEnabled",1,"VTransitionStateMachine *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("SetEnabled",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VTransitionStateMachine,0))){
    SWIG_fail_ptr("VTransitionStateMachine_SetEnabled",1,SWIGTYPE_p_VTransitionStateMachine);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  VTransitionStateMachine_SetEnabled(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VTransitionStateMachine_LoadFromFile(lua_State* L) {
  int SWIG_arg = 0;
  VTransitionStateMachine *arg1 = (VTransitionStateMachine *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  bool result;
  
  SWIG_check_num_args("LoadFromFile",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("LoadFromFile",1,"VTransitionStateMachine *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("LoadFromFile",2,"char const *");
  if(!SWIG_lua_isnilstring(L,3)) SWIG_fail_arg("LoadFromFile",3,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VTransitionStateMachine,0))){
    SWIG_fail_ptr("VTransitionStateMachine_LoadFromFile",1,SWIGTYPE_p_VTransitionStateMachine);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  arg3 = (char *)lua_tostring(L, 3);
  result = (bool)VTransitionStateMachine_LoadFromFile(arg1,(char const *)arg2,(char const *)arg3);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VTransitionStateMachine_GetActiveState(lua_State* L) {
  int SWIG_arg = 0;
  VTransitionStateMachine *arg1 = (VTransitionStateMachine *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("GetActiveState",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetActiveState",1,"VTransitionStateMachine *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VTransitionStateMachine,0))){
    SWIG_fail_ptr("VTransitionStateMachine_GetActiveState",1,SWIGTYPE_p_VTransitionStateMachine);
  }
  
  result = (char *)VTransitionStateMachine_GetActiveState(arg1);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VTransitionStateMachine_GetInactiveState(lua_State* L) {
  int SWIG_arg = 0;
  VTransitionStateMachine *arg1 = (VTransitionStateMachine *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("GetInactiveState",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetInactiveState",1,"VTransitionStateMachine *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VTransitionStateMachine,0))){
    SWIG_fail_ptr("VTransitionStateMachine_GetInactiveState",1,SWIGTYPE_p_VTransitionStateMachine);
  }
  
  result = (char *)VTransitionStateMachine_GetInactiveState(arg1);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VTransitionStateMachine_GetInitialAnimation(lua_State* L) {
  int SWIG_arg = 0;
  VTransitionStateMachine *arg1 = (VTransitionStateMachine *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("GetInitialAnimation",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetInitialAnimation",1,"VTransitionStateMachine *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VTransitionStateMachine,0))){
    SWIG_fail_ptr("VTransitionStateMachine_GetInitialAnimation",1,SWIGTYPE_p_VTransitionStateMachine);
  }
  
  result = (char *)VTransitionStateMachine_GetInitialAnimation(arg1);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VTransitionStateMachine_Cast(lua_State* L) {
  int SWIG_arg = 0;
  VTypedObject *arg1 = (VTypedObject *) 0 ;
  VTransitionStateMachine *result = 0 ;
  
  SWIG_check_num_args("VTransitionStateMachine_Cast",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("VTransitionStateMachine_Cast",1,"VTypedObject *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VTypedObject,0))){
    SWIG_fail_ptr("VTransitionStateMachine_Cast",1,SWIGTYPE_p_VTypedObject);
  }
  
  result = (VTransitionStateMachine *)VTransitionStateMachine_Cast(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_VTransitionStateMachine,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static swig_lua_method swig_VTransitionStateMachine_methods[] = {
    { "__tostring",VTransitionStateMachine_ToString},
    { "__concat",VTransitionStateMachine_Concat},
    {"IsEnabled", _wrap_VTransitionStateMachine_IsEnabled}, 
    {"SetState", _wrap_VTransitionStateMachine_SetState}, 
    {"IsBlending", _wrap_VTransitionStateMachine_IsBlending}, 
    {"IsWaitingForSyncBlending", _wrap_VTransitionStateMachine_IsWaitingForSyncBlending}, 
    {"SetForwardingAnimEvents", _wrap_VTransitionStateMachine_SetForwardingAnimEvents}, 
    {"AddEventListener", _wrap_VTransitionStateMachine_AddEventListener}, 
    {"RemoveEventListener", _wrap_VTransitionStateMachine_RemoveEventListener}, 
    {"SetEnabled", _wrap_VTransitionStateMachine_SetEnabled}, 
    {"LoadFromFile", _wrap_VTransitionStateMachine_LoadFromFile}, 
    {"GetActiveState", _wrap_VTransitionStateMachine_GetActiveState}, 
    {"GetInactiveState", _wrap_VTransitionStateMachine_GetInactiveState}, 
    {"GetInitialAnimation", _wrap_VTransitionStateMachine_GetInitialAnimation}, 
    {0,0}
};
static swig_lua_attribute swig_VTransitionStateMachine_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_VTransitionStateMachine_bases[] = {0,0};
static const char *swig_VTransitionStateMachine_base_names[] = {"IVObjectComponent *",0};
static swig_lua_class _wrap_class_VTransitionStateMachine = { "VTransitionStateMachine", &SWIGTYPE_p_VTransitionStateMachine,0,0, swig_VTransitionStateMachine_methods, swig_VTransitionStateMachine_attributes, swig_VTransitionStateMachine_bases, swig_VTransitionStateMachine_base_names };

static int _wrap_VAnimationComponent_Play__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  VAnimationComponent *arg1 = (VAnimationComponent *) 0 ;
  char *arg2 = (char *) 0 ;
  bool arg3 ;
  char *arg4 = (char *) 0 ;
  bool arg5 ;
  bool result;
  
  SWIG_check_num_args("Play",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Play",1,"VAnimationComponent *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("Play",2,"char const *");
  if(!lua_isboolean(L,3)) SWIG_fail_arg("Play",3,"bool");
  if(!SWIG_lua_isnilstring(L,4)) SWIG_fail_arg("Play",4,"char const *");
  if(!lua_isboolean(L,5)) SWIG_fail_arg("Play",5,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VAnimationComponent,0))){
    SWIG_fail_ptr("VAnimationComponent_Play",1,SWIGTYPE_p_VAnimationComponent);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  arg3 = (lua_toboolean(L, 3)!=0);
  arg4 = (char *)lua_tostring(L, 4);
  arg5 = (lua_toboolean(L, 5)!=0);
  result = (bool)(arg1)->Play((char const *)arg2,arg3,(char const *)arg4,arg5);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VAnimationComponent_Play__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  VAnimationComponent *arg1 = (VAnimationComponent *) 0 ;
  char *arg2 = (char *) 0 ;
  bool arg3 ;
  char *arg4 = (char *) 0 ;
  bool result;
  
  SWIG_check_num_args("Play",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Play",1,"VAnimationComponent *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("Play",2,"char const *");
  if(!lua_isboolean(L,3)) SWIG_fail_arg("Play",3,"bool");
  if(!SWIG_lua_isnilstring(L,4)) SWIG_fail_arg("Play",4,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VAnimationComponent,0))){
    SWIG_fail_ptr("VAnimationComponent_Play",1,SWIGTYPE_p_VAnimationComponent);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  arg3 = (lua_toboolean(L, 3)!=0);
  arg4 = (char *)lua_tostring(L, 4);
  result = (bool)(arg1)->Play((char const *)arg2,arg3,(char const *)arg4);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VAnimationComponent_Play__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  VAnimationComponent *arg1 = (VAnimationComponent *) 0 ;
  char *arg2 = (char *) 0 ;
  bool arg3 ;
  bool result;
  
  SWIG_check_num_args("Play",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Play",1,"VAnimationComponent *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("Play",2,"char const *");
  if(!lua_isboolean(L,3)) SWIG_fail_arg("Play",3,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VAnimationComponent,0))){
    SWIG_fail_ptr("VAnimationComponent_Play",1,SWIGTYPE_p_VAnimationComponent);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  arg3 = (lua_toboolean(L, 3)!=0);
  result = (bool)(arg1)->Play((char const *)arg2,arg3);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VAnimationComponent_Play__SWIG_3(lua_State* L) {
  int SWIG_arg = 0;
  VAnimationComponent *arg1 = (VAnimationComponent *) 0 ;
  char *arg2 = (char *) 0 ;
  bool result;
  
  SWIG_check_num_args("Play",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Play",1,"VAnimationComponent *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("Play",2,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VAnimationComponent,0))){
    SWIG_fail_ptr("VAnimationComponent_Play",1,SWIGTYPE_p_VAnimationComponent);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  result = (bool)(arg1)->Play((char const *)arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VAnimationComponent_Play(lua_State* L) {
  int argc;
  int argv[6]={
    1,2,3,4,5,6
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VAnimationComponent, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = SWIG_lua_isnilstring(L,argv[1]);
      }
      if (_v) {
        return _wrap_VAnimationComponent_Play__SWIG_3(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VAnimationComponent, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = SWIG_lua_isnilstring(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isboolean(L,argv[2]);
        }
        if (_v) {
          return _wrap_VAnimationComponent_Play__SWIG_2(L);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VAnimationComponent, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = SWIG_lua_isnilstring(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isboolean(L,argv[2]);
        }
        if (_v) {
          {
            _v = SWIG_lua_isnilstring(L,argv[3]);
          }
          if (_v) {
            return _wrap_VAnimationComponent_Play__SWIG_1(L);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VAnimationComponent, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = SWIG_lua_isnilstring(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isboolean(L,argv[2]);
        }
        if (_v) {
          {
            _v = SWIG_lua_isnilstring(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isboolean(L,argv[4]);
            }
            if (_v) {
              return _wrap_VAnimationComponent_Play__SWIG_0(L);
            }
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'VAnimationComponent_Play'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Play(VAnimationComponent *,char const *,bool,char const *,bool)\n"
    "    Play(VAnimationComponent *,char const *,bool,char const *)\n"
    "    Play(VAnimationComponent *,char const *,bool)\n"
    "    Play(VAnimationComponent *,char const *)\n");
  lua_error(L);return 0;
}


static int _wrap_VAnimationComponent_Resume__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  VAnimationComponent *arg1 = (VAnimationComponent *) 0 ;
  char *arg2 = (char *) 0 ;
  bool arg3 ;
  char *arg4 = (char *) 0 ;
  bool arg5 ;
  bool result;
  
  SWIG_check_num_args("Resume",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Resume",1,"VAnimationComponent *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("Resume",2,"char const *");
  if(!lua_isboolean(L,3)) SWIG_fail_arg("Resume",3,"bool");
  if(!SWIG_lua_isnilstring(L,4)) SWIG_fail_arg("Resume",4,"char const *");
  if(!lua_isboolean(L,5)) SWIG_fail_arg("Resume",5,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VAnimationComponent,0))){
    SWIG_fail_ptr("VAnimationComponent_Resume",1,SWIGTYPE_p_VAnimationComponent);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  arg3 = (lua_toboolean(L, 3)!=0);
  arg4 = (char *)lua_tostring(L, 4);
  arg5 = (lua_toboolean(L, 5)!=0);
  result = (bool)(arg1)->Resume((char const *)arg2,arg3,(char const *)arg4,arg5);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VAnimationComponent_Resume__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  VAnimationComponent *arg1 = (VAnimationComponent *) 0 ;
  char *arg2 = (char *) 0 ;
  bool arg3 ;
  char *arg4 = (char *) 0 ;
  bool result;
  
  SWIG_check_num_args("Resume",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Resume",1,"VAnimationComponent *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("Resume",2,"char const *");
  if(!lua_isboolean(L,3)) SWIG_fail_arg("Resume",3,"bool");
  if(!SWIG_lua_isnilstring(L,4)) SWIG_fail_arg("Resume",4,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VAnimationComponent,0))){
    SWIG_fail_ptr("VAnimationComponent_Resume",1,SWIGTYPE_p_VAnimationComponent);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  arg3 = (lua_toboolean(L, 3)!=0);
  arg4 = (char *)lua_tostring(L, 4);
  result = (bool)(arg1)->Resume((char const *)arg2,arg3,(char const *)arg4);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VAnimationComponent_Resume__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  VAnimationComponent *arg1 = (VAnimationComponent *) 0 ;
  char *arg2 = (char *) 0 ;
  bool arg3 ;
  bool result;
  
  SWIG_check_num_args("Resume",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Resume",1,"VAnimationComponent *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("Resume",2,"char const *");
  if(!lua_isboolean(L,3)) SWIG_fail_arg("Resume",3,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VAnimationComponent,0))){
    SWIG_fail_ptr("VAnimationComponent_Resume",1,SWIGTYPE_p_VAnimationComponent);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  arg3 = (lua_toboolean(L, 3)!=0);
  result = (bool)(arg1)->Resume((char const *)arg2,arg3);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VAnimationComponent_Resume__SWIG_3(lua_State* L) {
  int SWIG_arg = 0;
  VAnimationComponent *arg1 = (VAnimationComponent *) 0 ;
  char *arg2 = (char *) 0 ;
  bool result;
  
  SWIG_check_num_args("Resume",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Resume",1,"VAnimationComponent *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("Resume",2,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VAnimationComponent,0))){
    SWIG_fail_ptr("VAnimationComponent_Resume",1,SWIGTYPE_p_VAnimationComponent);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  result = (bool)(arg1)->Resume((char const *)arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VAnimationComponent_Resume__SWIG_4(lua_State* L) {
  int SWIG_arg = 0;
  VAnimationComponent *arg1 = (VAnimationComponent *) 0 ;
  bool result;
  
  SWIG_check_num_args("Resume",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Resume",1,"VAnimationComponent *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VAnimationComponent,0))){
    SWIG_fail_ptr("VAnimationComponent_Resume",1,SWIGTYPE_p_VAnimationComponent);
  }
  
  result = (bool)(arg1)->Resume();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VAnimationComponent_Resume(lua_State* L) {
  int argc;
  int argv[6]={
    1,2,3,4,5,6
  };
  
  argc = lua_gettop(L);
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VAnimationComponent, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_VAnimationComponent_Resume__SWIG_4(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VAnimationComponent, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = SWIG_lua_isnilstring(L,argv[1]);
      }
      if (_v) {
        return _wrap_VAnimationComponent_Resume__SWIG_3(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VAnimationComponent, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = SWIG_lua_isnilstring(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isboolean(L,argv[2]);
        }
        if (_v) {
          return _wrap_VAnimationComponent_Resume__SWIG_2(L);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VAnimationComponent, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = SWIG_lua_isnilstring(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isboolean(L,argv[2]);
        }
        if (_v) {
          {
            _v = SWIG_lua_isnilstring(L,argv[3]);
          }
          if (_v) {
            return _wrap_VAnimationComponent_Resume__SWIG_1(L);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VAnimationComponent, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = SWIG_lua_isnilstring(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isboolean(L,argv[2]);
        }
        if (_v) {
          {
            _v = SWIG_lua_isnilstring(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isboolean(L,argv[4]);
            }
            if (_v) {
              return _wrap_VAnimationComponent_Resume__SWIG_0(L);
            }
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'VAnimationComponent_Resume'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Resume(VAnimationComponent *,char const *,bool,char const *,bool)\n"
    "    Resume(VAnimationComponent *,char const *,bool,char const *)\n"
    "    Resume(VAnimationComponent *,char const *,bool)\n"
    "    Resume(VAnimationComponent *,char const *)\n"
    "    Resume(VAnimationComponent *)\n");
  lua_error(L);return 0;
}


static int _wrap_VAnimationComponent_Stop(lua_State* L) {
  int SWIG_arg = 0;
  VAnimationComponent *arg1 = (VAnimationComponent *) 0 ;
  bool result;
  
  SWIG_check_num_args("Stop",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Stop",1,"VAnimationComponent *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VAnimationComponent,0))){
    SWIG_fail_ptr("VAnimationComponent_Stop",1,SWIGTYPE_p_VAnimationComponent);
  }
  
  result = (bool)(arg1)->Stop();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VAnimationComponent_Pause(lua_State* L) {
  int SWIG_arg = 0;
  VAnimationComponent *arg1 = (VAnimationComponent *) 0 ;
  bool result;
  
  SWIG_check_num_args("Pause",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Pause",1,"VAnimationComponent *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VAnimationComponent,0))){
    SWIG_fail_ptr("VAnimationComponent_Pause",1,SWIGTYPE_p_VAnimationComponent);
  }
  
  result = (bool)(arg1)->Pause();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VAnimationComponent_AddAnimationSequence(lua_State* L) {
  int SWIG_arg = 0;
  VAnimationComponent *arg1 = (VAnimationComponent *) 0 ;
  char *arg2 = (char *) 0 ;
  bool result;
  
  SWIG_check_num_args("AddAnimationSequence",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("AddAnimationSequence",1,"VAnimationComponent *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("AddAnimationSequence",2,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VAnimationComponent,0))){
    SWIG_fail_ptr("VAnimationComponent_AddAnimationSequence",1,SWIGTYPE_p_VAnimationComponent);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  result = (bool)(arg1)->AddAnimationSequence((char const *)arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VAnimationComponent_SetTime__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  VAnimationComponent *arg1 = (VAnimationComponent *) 0 ;
  float arg2 ;
  bool arg3 ;
  bool result;
  
  SWIG_check_num_args("SetTime",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetTime",1,"VAnimationComponent *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SetTime",2,"float");
  if(!lua_isboolean(L,3)) SWIG_fail_arg("SetTime",3,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VAnimationComponent,0))){
    SWIG_fail_ptr("VAnimationComponent_SetTime",1,SWIGTYPE_p_VAnimationComponent);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (lua_toboolean(L, 3)!=0);
  result = (bool)(arg1)->SetTime(arg2,arg3);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VAnimationComponent_SetTime__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  VAnimationComponent *arg1 = (VAnimationComponent *) 0 ;
  float arg2 ;
  bool result;
  
  SWIG_check_num_args("SetTime",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetTime",1,"VAnimationComponent *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SetTime",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VAnimationComponent,0))){
    SWIG_fail_ptr("VAnimationComponent_SetTime",1,SWIGTYPE_p_VAnimationComponent);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  result = (bool)(arg1)->SetTime(arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VAnimationComponent_SetTime(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VAnimationComponent, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_VAnimationComponent_SetTime__SWIG_1(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VAnimationComponent, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isboolean(L,argv[2]);
        }
        if (_v) {
          return _wrap_VAnimationComponent_SetTime__SWIG_0(L);
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'VAnimationComponent_SetTime'\n"
    "  Possible C/C++ prototypes are:\n"
    "    SetTime(VAnimationComponent *,float,bool)\n"
    "    SetTime(VAnimationComponent *,float)\n");
  lua_error(L);return 0;
}


static int _wrap_VAnimationComponent_IsPlaying(lua_State* L) {
  int SWIG_arg = 0;
  VAnimationComponent *arg1 = (VAnimationComponent *) 0 ;
  bool result;
  
  SWIG_check_num_args("IsPlaying",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("IsPlaying",1,"VAnimationComponent *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VAnimationComponent,0))){
    SWIG_fail_ptr("VAnimationComponent_IsPlaying",1,SWIGTYPE_p_VAnimationComponent);
  }
  
  result = (bool)(arg1)->IsPlaying();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VAnimationComponent_GetCurrentAnimation(lua_State* L) {
  int SWIG_arg = 0;
  VAnimationComponent *arg1 = (VAnimationComponent *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("GetCurrentAnimation",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetCurrentAnimation",1,"VAnimationComponent *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VAnimationComponent,0))){
    SWIG_fail_ptr("VAnimationComponent_GetCurrentAnimation",1,SWIGTYPE_p_VAnimationComponent);
  }
  
  result = (char *)(arg1)->GetCurrentAnimation();
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VAnimationComponent_Cast(lua_State* L) {
  int SWIG_arg = 0;
  VTypedObject *arg1 = (VTypedObject *) 0 ;
  VAnimationComponent *result = 0 ;
  
  SWIG_check_num_args("VAnimationComponent_Cast",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("VAnimationComponent_Cast",1,"VTypedObject *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VTypedObject,0))){
    SWIG_fail_ptr("VAnimationComponent_Cast",1,SWIGTYPE_p_VTypedObject);
  }
  
  result = (VAnimationComponent *)VAnimationComponent_Cast(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_VAnimationComponent,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static swig_lua_method swig_VAnimationComponent_methods[] = {
    { "__tostring",VAnimationComponent_ToString},
    { "GetSequences",VAnimationComponent_GetSequences},
    { "__concat",VAnimationComponent_Concat},
    {"Play", _wrap_VAnimationComponent_Play}, 
    {"Resume", _wrap_VAnimationComponent_Resume}, 
    {"Stop", _wrap_VAnimationComponent_Stop}, 
    {"Pause", _wrap_VAnimationComponent_Pause}, 
    {"AddAnimationSequence", _wrap_VAnimationComponent_AddAnimationSequence}, 
    {"SetTime", _wrap_VAnimationComponent_SetTime}, 
    {"IsPlaying", _wrap_VAnimationComponent_IsPlaying}, 
    {"GetCurrentAnimation", _wrap_VAnimationComponent_GetCurrentAnimation}, 
    {0,0}
};
static swig_lua_attribute swig_VAnimationComponent_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_VAnimationComponent_bases[] = {0,0};
static const char *swig_VAnimationComponent_base_names[] = {"IVObjectComponent *",0};
static swig_lua_class _wrap_class_VAnimationComponent = { "VAnimationComponent", &SWIGTYPE_p_VAnimationComponent,0,0, swig_VAnimationComponent_methods, swig_VAnimationComponent_attributes, swig_VAnimationComponent_bases, swig_VAnimationComponent_base_names };

static int _wrap_VTimedValueComponent_Resume(lua_State* L) {
  int SWIG_arg = 0;
  VTimedValueComponent *arg1 = (VTimedValueComponent *) 0 ;
  
  SWIG_check_num_args("Resume",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Resume",1,"VTimedValueComponent *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VTimedValueComponent,0))){
    SWIG_fail_ptr("VTimedValueComponent_Resume",1,SWIGTYPE_p_VTimedValueComponent);
  }
  
  (arg1)->Resume();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VTimedValueComponent_Stop(lua_State* L) {
  int SWIG_arg = 0;
  VTimedValueComponent *arg1 = (VTimedValueComponent *) 0 ;
  
  SWIG_check_num_args("Stop",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Stop",1,"VTimedValueComponent *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VTimedValueComponent,0))){
    SWIG_fail_ptr("VTimedValueComponent_Stop",1,SWIGTYPE_p_VTimedValueComponent);
  }
  
  (arg1)->Stop();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VTimedValueComponent_Reset(lua_State* L) {
  int SWIG_arg = 0;
  VTimedValueComponent *arg1 = (VTimedValueComponent *) 0 ;
  
  SWIG_check_num_args("Reset",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Reset",1,"VTimedValueComponent *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VTimedValueComponent,0))){
    SWIG_fail_ptr("VTimedValueComponent_Reset",1,SWIGTYPE_p_VTimedValueComponent);
  }
  
  (arg1)->Reset();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VTimedValueComponent_IsPaused(lua_State* L) {
  int SWIG_arg = 0;
  VTimedValueComponent *arg1 = (VTimedValueComponent *) 0 ;
  bool result;
  
  SWIG_check_num_args("IsPaused",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("IsPaused",1,"VTimedValueComponent *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VTimedValueComponent,0))){
    SWIG_fail_ptr("VTimedValueComponent_IsPaused",1,SWIGTYPE_p_VTimedValueComponent);
  }
  
  result = (bool)(arg1)->IsPaused();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VTimedValueComponent_SetRange__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  VTimedValueComponent *arg1 = (VTimedValueComponent *) 0 ;
  float arg2 ;
  float arg3 ;
  bool arg4 ;
  
  SWIG_check_num_args("SetRange",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetRange",1,"VTimedValueComponent *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SetRange",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("SetRange",3,"float");
  if(!lua_isboolean(L,4)) SWIG_fail_arg("SetRange",4,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VTimedValueComponent,0))){
    SWIG_fail_ptr("VTimedValueComponent_SetRange",1,SWIGTYPE_p_VTimedValueComponent);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (lua_toboolean(L, 4)!=0);
  (arg1)->SetRange(arg2,arg3,arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VTimedValueComponent_SetRange__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  VTimedValueComponent *arg1 = (VTimedValueComponent *) 0 ;
  float arg2 ;
  float arg3 ;
  
  SWIG_check_num_args("SetRange",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetRange",1,"VTimedValueComponent *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SetRange",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("SetRange",3,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VTimedValueComponent,0))){
    SWIG_fail_ptr("VTimedValueComponent_SetRange",1,SWIGTYPE_p_VTimedValueComponent);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  (arg1)->SetRange(arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VTimedValueComponent_SetRange(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VTimedValueComponent, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          return _wrap_VTimedValueComponent_SetRange__SWIG_1(L);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VTimedValueComponent, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isboolean(L,argv[3]);
          }
          if (_v) {
            return _wrap_VTimedValueComponent_SetRange__SWIG_0(L);
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'VTimedValueComponent_SetRange'\n"
    "  Possible C/C++ prototypes are:\n"
    "    SetRange(VTimedValueComponent *,float,float,bool)\n"
    "    SetRange(VTimedValueComponent *,float,float)\n");
  lua_error(L);return 0;
}


static int _wrap_VTimedValueComponent_SetDuration(lua_State* L) {
  int SWIG_arg = 0;
  VTimedValueComponent *arg1 = (VTimedValueComponent *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("SetDuration",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetDuration",1,"VTimedValueComponent *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SetDuration",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VTimedValueComponent,0))){
    SWIG_fail_ptr("VTimedValueComponent_SetDuration",1,SWIGTYPE_p_VTimedValueComponent);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->SetDuration(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VTimedValueComponent_GetValue(lua_State* L) {
  int SWIG_arg = 0;
  VTimedValueComponent *arg1 = (VTimedValueComponent *) 0 ;
  float result;
  
  SWIG_check_num_args("GetValue",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetValue",1,"VTimedValueComponent *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VTimedValueComponent,0))){
    SWIG_fail_ptr("VTimedValueComponent_GetValue",1,SWIGTYPE_p_VTimedValueComponent);
  }
  
  result = (float)(arg1)->GetValue();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VTimedValueComponent_GetTime(lua_State* L) {
  int SWIG_arg = 0;
  VTimedValueComponent *arg1 = (VTimedValueComponent *) 0 ;
  float result;
  
  SWIG_check_num_args("GetTime",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetTime",1,"VTimedValueComponent *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VTimedValueComponent,0))){
    SWIG_fail_ptr("VTimedValueComponent_GetTime",1,SWIGTYPE_p_VTimedValueComponent);
  }
  
  result = (float)(arg1)->GetTime();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VTimedValueComponent_GetFromValue(lua_State* L) {
  int SWIG_arg = 0;
  VTimedValueComponent *arg1 = (VTimedValueComponent *) 0 ;
  float result;
  
  SWIG_check_num_args("GetFromValue",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetFromValue",1,"VTimedValueComponent *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VTimedValueComponent,0))){
    SWIG_fail_ptr("VTimedValueComponent_GetFromValue",1,SWIGTYPE_p_VTimedValueComponent);
  }
  
  result = (float)(arg1)->GetFromValue();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VTimedValueComponent_GetToValue(lua_State* L) {
  int SWIG_arg = 0;
  VTimedValueComponent *arg1 = (VTimedValueComponent *) 0 ;
  float result;
  
  SWIG_check_num_args("GetToValue",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetToValue",1,"VTimedValueComponent *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VTimedValueComponent,0))){
    SWIG_fail_ptr("VTimedValueComponent_GetToValue",1,SWIGTYPE_p_VTimedValueComponent);
  }
  
  result = (float)(arg1)->GetToValue();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VTimedValueComponent_GetDuration(lua_State* L) {
  int SWIG_arg = 0;
  VTimedValueComponent *arg1 = (VTimedValueComponent *) 0 ;
  float result;
  
  SWIG_check_num_args("GetDuration",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetDuration",1,"VTimedValueComponent *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VTimedValueComponent,0))){
    SWIG_fail_ptr("VTimedValueComponent_GetDuration",1,SWIGTYPE_p_VTimedValueComponent);
  }
  
  result = (float)(arg1)->GetDuration();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VTimedValueComponent_GetNumCallbacks(lua_State* L) {
  int SWIG_arg = 0;
  VTimedValueComponent *arg1 = (VTimedValueComponent *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("GetNumCallbacks",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetNumCallbacks",1,"VTimedValueComponent *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VTimedValueComponent,0))){
    SWIG_fail_ptr("VTimedValueComponent_GetNumCallbacks",1,SWIGTYPE_p_VTimedValueComponent);
  }
  
  result = (unsigned int)(arg1)->GetNumCallbacks();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VTimedValueComponent_EvaluateAttachedScripts(lua_State* L) {
  int SWIG_arg = 0;
  VTimedValueComponent *arg1 = (VTimedValueComponent *) 0 ;
  bool result;
  
  SWIG_check_num_args("EvaluateAttachedScripts",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("EvaluateAttachedScripts",1,"VTimedValueComponent *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VTimedValueComponent,0))){
    SWIG_fail_ptr("VTimedValueComponent_EvaluateAttachedScripts",1,SWIGTYPE_p_VTimedValueComponent);
  }
  
  result = (bool)(arg1)->EvaluateAttachedScripts();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VTimedValueComponent_AddCallback__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  VTimedValueComponent *arg1 = (VTimedValueComponent *) 0 ;
  char *arg2 = (char *) 0 ;
  float arg3 ;
  
  SWIG_check_num_args("AddCallback",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("AddCallback",1,"VTimedValueComponent *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("AddCallback",2,"char const *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("AddCallback",3,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VTimedValueComponent,0))){
    SWIG_fail_ptr("VTimedValueComponent_AddCallback",1,SWIGTYPE_p_VTimedValueComponent);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  (arg1)->AddCallback((char const *)arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VTimedValueComponent_AddCallback__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  VTimedValueComponent *arg1 = (VTimedValueComponent *) 0 ;
  char *arg2 = (char *) 0 ;
  
  SWIG_check_num_args("AddCallback",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("AddCallback",1,"VTimedValueComponent *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("AddCallback",2,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VTimedValueComponent,0))){
    SWIG_fail_ptr("VTimedValueComponent_AddCallback",1,SWIGTYPE_p_VTimedValueComponent);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  (arg1)->AddCallback((char const *)arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VTimedValueComponent_AddCallback(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VTimedValueComponent, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = SWIG_lua_isnilstring(L,argv[1]);
      }
      if (_v) {
        return _wrap_VTimedValueComponent_AddCallback__SWIG_1(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VTimedValueComponent, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = SWIG_lua_isnilstring(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          return _wrap_VTimedValueComponent_AddCallback__SWIG_0(L);
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'VTimedValueComponent_AddCallback'\n"
    "  Possible C/C++ prototypes are:\n"
    "    AddCallback(VTimedValueComponent *,char const *,float)\n"
    "    AddCallback(VTimedValueComponent *,char const *)\n");
  lua_error(L);return 0;
}


static int _wrap_VTimedValueComponent_Cast(lua_State* L) {
  int SWIG_arg = 0;
  VTypedObject *arg1 = (VTypedObject *) 0 ;
  VTimedValueComponent *result = 0 ;
  
  SWIG_check_num_args("VTimedValueComponent_Cast",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("VTimedValueComponent_Cast",1,"VTypedObject *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VTypedObject,0))){
    SWIG_fail_ptr("VTimedValueComponent_Cast",1,SWIGTYPE_p_VTypedObject);
  }
  
  result = (VTimedValueComponent *)VTimedValueComponent_Cast(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_VTimedValueComponent,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static swig_lua_method swig_VTimedValueComponent_methods[] = {
    { "__tostring",VTimedValueComponent_ToString},
    { "__concat",VTimedValueComponent_Concat},
    {"Resume", _wrap_VTimedValueComponent_Resume}, 
    {"Stop", _wrap_VTimedValueComponent_Stop}, 
    {"Reset", _wrap_VTimedValueComponent_Reset}, 
    {"IsPaused", _wrap_VTimedValueComponent_IsPaused}, 
    {"SetRange", _wrap_VTimedValueComponent_SetRange}, 
    {"SetDuration", _wrap_VTimedValueComponent_SetDuration}, 
    {"GetValue", _wrap_VTimedValueComponent_GetValue}, 
    {"GetTime", _wrap_VTimedValueComponent_GetTime}, 
    {"GetFromValue", _wrap_VTimedValueComponent_GetFromValue}, 
    {"GetToValue", _wrap_VTimedValueComponent_GetToValue}, 
    {"GetDuration", _wrap_VTimedValueComponent_GetDuration}, 
    {"GetNumCallbacks", _wrap_VTimedValueComponent_GetNumCallbacks}, 
    {"EvaluateAttachedScripts", _wrap_VTimedValueComponent_EvaluateAttachedScripts}, 
    {"AddCallback", _wrap_VTimedValueComponent_AddCallback}, 
    {0,0}
};
static swig_lua_attribute swig_VTimedValueComponent_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_VTimedValueComponent_bases[] = {0,0};
static const char *swig_VTimedValueComponent_base_names[] = {"IVObjectComponent *",0};
static swig_lua_class _wrap_class_VTimedValueComponent = { "VTimedValueComponent", &SWIGTYPE_p_VTimedValueComponent,0,0, swig_VTimedValueComponent_methods, swig_VTimedValueComponent_attributes, swig_VTimedValueComponent_bases, swig_VTimedValueComponent_base_names };

static int _wrap_VGUIManager_GetID(lua_State* L) {
  int SWIG_arg = 0;
  VGUIManager *arg1 = (VGUIManager *) 0 ;
  char *arg2 = (char *) 0 ;
  int result;
  
  SWIG_check_num_args("GetID",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetID",1,"VGUIManager *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("GetID",2,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VGUIManager,0))){
    SWIG_fail_ptr("VGUIManager_GetID",1,SWIGTYPE_p_VGUIManager);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  result = (int)(arg1)->GetID((char const *)arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VGUIManager_GetIDName(lua_State* L) {
  int SWIG_arg = 0;
  VGUIManager *arg1 = (VGUIManager *) 0 ;
  int arg2 ;
  char *result = 0 ;
  
  SWIG_check_num_args("GetIDName",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetIDName",1,"VGUIManager *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("GetIDName",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VGUIManager,0))){
    SWIG_fail_ptr("VGUIManager_GetIDName",1,SWIGTYPE_p_VGUIManager);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  result = (char *)(arg1)->GetIDName(arg2);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VGUIManager_LoadResourceFile(lua_State* L) {
  int SWIG_arg = 0;
  VGUIManager *arg1 = (VGUIManager *) 0 ;
  char *arg2 = (char *) 0 ;
  bool result;
  
  SWIG_check_num_args("LoadResourceFile",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("LoadResourceFile",1,"VGUIManager *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("LoadResourceFile",2,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VGUIManager,0))){
    SWIG_fail_ptr("VGUIManager_LoadResourceFile",1,SWIGTYPE_p_VGUIManager);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  result = (bool)(arg1)->LoadResourceFile((char const *)arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VGUIManager_ShowDialog__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  VGUIManager *arg1 = (VGUIManager *) 0 ;
  char *arg2 = (char *) 0 ;
  VDialog *result = 0 ;
  
  SWIG_check_num_args("ShowDialog",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ShowDialog",1,"VGUIManager *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("ShowDialog",2,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VGUIManager,0))){
    SWIG_fail_ptr("VGUIManager_ShowDialog",1,SWIGTYPE_p_VGUIManager);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  result = (VDialog *)VGUIManager_ShowDialog__SWIG_0(arg1,(char const *)arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_VDialog,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VGUIManager_ShowDialog__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  VGUIManager *arg1 = (VGUIManager *) 0 ;
  VDialog *arg2 = (VDialog *) 0 ;
  bool result;
  
  SWIG_check_num_args("ShowDialog",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ShowDialog",1,"VGUIManager *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ShowDialog",2,"VDialog *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VGUIManager,0))){
    SWIG_fail_ptr("VGUIManager_ShowDialog",1,SWIGTYPE_p_VGUIManager);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_VDialog,0))){
    SWIG_fail_ptr("VGUIManager_ShowDialog",2,SWIGTYPE_p_VDialog);
  }
  
  result = (bool)VGUIManager_ShowDialog__SWIG_1(arg1,arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VGUIManager_ShowDialog(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VGUIManager, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_VDialog, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_VGUIManager_ShowDialog__SWIG_1(L);
      }
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VGUIManager, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = SWIG_lua_isnilstring(L,argv[1]);
      }
      if (_v) {
        return _wrap_VGUIManager_ShowDialog__SWIG_0(L);
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'VGUIManager_ShowDialog'\n"
    "  Possible C/C++ prototypes are:\n"
    "    ShowDialog(VGUIManager *,char const *)\n"
    "    ShowDialog(VGUIManager *,VDialog *)\n");
  lua_error(L);return 0;
}


static int _wrap_VGUIManager_CloseDialog(lua_State* L) {
  int SWIG_arg = 0;
  VGUIManager *arg1 = (VGUIManager *) 0 ;
  VDialog *arg2 = (VDialog *) 0 ;
  bool result;
  
  SWIG_check_num_args("CloseDialog",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("CloseDialog",1,"VGUIManager *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("CloseDialog",2,"VDialog *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VGUIManager,0))){
    SWIG_fail_ptr("VGUIManager_CloseDialog",1,SWIGTYPE_p_VGUIManager);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_VDialog,0))){
    SWIG_fail_ptr("VGUIManager_CloseDialog",2,SWIGTYPE_p_VDialog);
  }
  
  result = (bool)VGUIManager_CloseDialog(arg1,arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VGUIManager_ShowModalDialog__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  VGUIManager *arg1 = (VGUIManager *) 0 ;
  char *arg2 = (char *) 0 ;
  float arg3 ;
  float arg4 ;
  int result;
  
  SWIG_check_num_args("ShowModalDialog",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ShowModalDialog",1,"VGUIManager *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("ShowModalDialog",2,"char const *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ShowModalDialog",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ShowModalDialog",4,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VGUIManager,0))){
    SWIG_fail_ptr("VGUIManager_ShowModalDialog",1,SWIGTYPE_p_VGUIManager);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4);
  result = (int)VGUIManager_ShowModalDialog__SWIG_0(arg1,(char const *)arg2,arg3,arg4);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VGUIManager_ShowModalDialog__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  VGUIManager *arg1 = (VGUIManager *) 0 ;
  char *arg2 = (char *) 0 ;
  float arg3 ;
  int result;
  
  SWIG_check_num_args("ShowModalDialog",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ShowModalDialog",1,"VGUIManager *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("ShowModalDialog",2,"char const *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ShowModalDialog",3,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VGUIManager,0))){
    SWIG_fail_ptr("VGUIManager_ShowModalDialog",1,SWIGTYPE_p_VGUIManager);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  result = (int)VGUIManager_ShowModalDialog__SWIG_0(arg1,(char const *)arg2,arg3);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VGUIManager_ShowModalDialog__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  VGUIManager *arg1 = (VGUIManager *) 0 ;
  char *arg2 = (char *) 0 ;
  int result;
  
  SWIG_check_num_args("ShowModalDialog",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ShowModalDialog",1,"VGUIManager *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("ShowModalDialog",2,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VGUIManager,0))){
    SWIG_fail_ptr("VGUIManager_ShowModalDialog",1,SWIGTYPE_p_VGUIManager);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  result = (int)VGUIManager_ShowModalDialog__SWIG_0(arg1,(char const *)arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VGUIManager_ShowModalDialog__SWIG_3(lua_State* L) {
  int SWIG_arg = 0;
  VGUIManager *arg1 = (VGUIManager *) 0 ;
  VDialog *arg2 = (VDialog *) 0 ;
  int result;
  
  SWIG_check_num_args("ShowModalDialog",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ShowModalDialog",1,"VGUIManager *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ShowModalDialog",2,"VDialog *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VGUIManager,0))){
    SWIG_fail_ptr("VGUIManager_ShowModalDialog",1,SWIGTYPE_p_VGUIManager);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_VDialog,0))){
    SWIG_fail_ptr("VGUIManager_ShowModalDialog",2,SWIGTYPE_p_VDialog);
  }
  
  result = (int)VGUIManager_ShowModalDialog__SWIG_3(arg1,arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VGUIManager_ShowModalDialog(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VGUIManager, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_VDialog, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_VGUIManager_ShowModalDialog__SWIG_3(L);
      }
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VGUIManager, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = SWIG_lua_isnilstring(L,argv[1]);
      }
      if (_v) {
        return _wrap_VGUIManager_ShowModalDialog__SWIG_2(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VGUIManager, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = SWIG_lua_isnilstring(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          return _wrap_VGUIManager_ShowModalDialog__SWIG_1(L);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VGUIManager, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = SWIG_lua_isnilstring(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_VGUIManager_ShowModalDialog__SWIG_0(L);
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'VGUIManager_ShowModalDialog'\n"
    "  Possible C/C++ prototypes are:\n"
    "    ShowModalDialog(VGUIManager *,char const *,float,float)\n"
    "    ShowModalDialog(VGUIManager *,char const *,float)\n"
    "    ShowModalDialog(VGUIManager *,char const *)\n"
    "    ShowModalDialog(VGUIManager *,VDialog *)\n");
  lua_error(L);return 0;
}


static int _wrap_VGUIManager_SetCursorVisible(lua_State* L) {
  int SWIG_arg = 0;
  VGUIManager *arg1 = (VGUIManager *) 0 ;
  bool arg2 ;
  
  SWIG_check_num_args("SetCursorVisible",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetCursorVisible",1,"VGUIManager *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("SetCursorVisible",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VGUIManager,0))){
    SWIG_fail_ptr("VGUIManager_SetCursorVisible",1,SWIGTYPE_p_VGUIManager);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  VGUIManager_SetCursorVisible(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VGUIManager_IsCursorVisible(lua_State* L) {
  int SWIG_arg = 0;
  VGUIManager *arg1 = (VGUIManager *) 0 ;
  bool result;
  
  SWIG_check_num_args("IsCursorVisible",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("IsCursorVisible",1,"VGUIManager *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VGUIManager,0))){
    SWIG_fail_ptr("VGUIManager_IsCursorVisible",1,SWIGTYPE_p_VGUIManager);
  }
  
  result = (bool)VGUIManager_IsCursorVisible(arg1);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static swig_lua_method swig_VGUIManager_methods[] = {
    {"GetID", _wrap_VGUIManager_GetID}, 
    {"GetIDName", _wrap_VGUIManager_GetIDName}, 
    {"LoadResourceFile", _wrap_VGUIManager_LoadResourceFile}, 
    {"ShowDialog", _wrap_VGUIManager_ShowDialog}, 
    {"CloseDialog", _wrap_VGUIManager_CloseDialog}, 
    {"ShowModalDialog", _wrap_VGUIManager_ShowModalDialog}, 
    {"SetCursorVisible", _wrap_VGUIManager_SetCursorVisible}, 
    {"IsCursorVisible", _wrap_VGUIManager_IsCursorVisible}, 
    {0,0}
};
static swig_lua_attribute swig_VGUIManager_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_VGUIManager_bases[] = {0};
static const char *swig_VGUIManager_base_names[] = {0};
static swig_lua_class _wrap_class_VGUIManager = { "VGUIManager", &SWIGTYPE_p_VGUIManager,0,0, swig_VGUIManager_methods, swig_VGUIManager_attributes, swig_VGUIManager_bases, swig_VGUIManager_base_names };

static int _wrap_VWindowBase_GetParent(lua_State* L) {
  int SWIG_arg = 0;
  VWindowBase *arg1 = (VWindowBase *) 0 ;
  VWindowBase *result = 0 ;
  
  SWIG_check_num_args("GetParent",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetParent",1,"VWindowBase const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VWindowBase,0))){
    SWIG_fail_ptr("VWindowBase_GetParent",1,SWIGTYPE_p_VWindowBase);
  }
  
  result = (VWindowBase *)((VWindowBase const *)arg1)->GetParent();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_VWindowBase,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VWindowBase_GetID(lua_State* L) {
  int SWIG_arg = 0;
  VWindowBase *arg1 = (VWindowBase *) 0 ;
  int result;
  
  SWIG_check_num_args("GetID",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetID",1,"VWindowBase const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VWindowBase,0))){
    SWIG_fail_ptr("VWindowBase_GetID",1,SWIGTYPE_p_VWindowBase);
  }
  
  result = (int)((VWindowBase const *)arg1)->GetID();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VWindowBase_GetDialogResult(lua_State* L) {
  int SWIG_arg = 0;
  VWindowBase *arg1 = (VWindowBase *) 0 ;
  int result;
  
  SWIG_check_num_args("GetDialogResult",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetDialogResult",1,"VWindowBase const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VWindowBase,0))){
    SWIG_fail_ptr("VWindowBase_GetDialogResult",1,SWIGTYPE_p_VWindowBase);
  }
  
  result = (int)((VWindowBase const *)arg1)->GetDialogResult();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VWindowBase_SetDialogResult(lua_State* L) {
  int SWIG_arg = 0;
  VWindowBase *arg1 = (VWindowBase *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("SetDialogResult",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetDialogResult",1,"VWindowBase *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SetDialogResult",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VWindowBase,0))){
    SWIG_fail_ptr("VWindowBase_SetDialogResult",1,SWIGTYPE_p_VWindowBase);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->SetDialogResult(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VWindowBase_Refresh(lua_State* L) {
  int SWIG_arg = 0;
  VWindowBase *arg1 = (VWindowBase *) 0 ;
  
  SWIG_check_num_args("Refresh",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Refresh",1,"VWindowBase *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VWindowBase,0))){
    SWIG_fail_ptr("VWindowBase_Refresh",1,SWIGTYPE_p_VWindowBase);
  }
  
  (arg1)->Refresh();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VWindowBase_IsVisible(lua_State* L) {
  int SWIG_arg = 0;
  VWindowBase *arg1 = (VWindowBase *) 0 ;
  bool result;
  
  SWIG_check_num_args("IsVisible",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("IsVisible",1,"VWindowBase const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VWindowBase,0))){
    SWIG_fail_ptr("VWindowBase_IsVisible",1,SWIGTYPE_p_VWindowBase);
  }
  
  result = (bool)((VWindowBase const *)arg1)->IsVisible();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VWindowBase_SetVisible(lua_State* L) {
  int SWIG_arg = 0;
  VWindowBase *arg1 = (VWindowBase *) 0 ;
  bool arg2 ;
  
  SWIG_check_num_args("SetVisible",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetVisible",1,"VWindowBase *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("SetVisible",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VWindowBase,0))){
    SWIG_fail_ptr("VWindowBase_SetVisible",1,SWIGTYPE_p_VWindowBase);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  (arg1)->SetVisible(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VWindowBase_IsEnabled(lua_State* L) {
  int SWIG_arg = 0;
  VWindowBase *arg1 = (VWindowBase *) 0 ;
  bool result;
  
  SWIG_check_num_args("IsEnabled",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("IsEnabled",1,"VWindowBase const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VWindowBase,0))){
    SWIG_fail_ptr("VWindowBase_IsEnabled",1,SWIGTYPE_p_VWindowBase);
  }
  
  result = (bool)((VWindowBase const *)arg1)->IsEnabled();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VWindowBase_SetEnabled(lua_State* L) {
  int SWIG_arg = 0;
  VWindowBase *arg1 = (VWindowBase *) 0 ;
  bool arg2 ;
  
  SWIG_check_num_args("SetEnabled",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetEnabled",1,"VWindowBase *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("SetEnabled",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VWindowBase,0))){
    SWIG_fail_ptr("VWindowBase_SetEnabled",1,SWIGTYPE_p_VWindowBase);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  (arg1)->SetEnabled(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VWindowBase_IsStatic(lua_State* L) {
  int SWIG_arg = 0;
  VWindowBase *arg1 = (VWindowBase *) 0 ;
  bool result;
  
  SWIG_check_num_args("IsStatic",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("IsStatic",1,"VWindowBase const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VWindowBase,0))){
    SWIG_fail_ptr("VWindowBase_IsStatic",1,SWIGTYPE_p_VWindowBase);
  }
  
  result = (bool)((VWindowBase const *)arg1)->IsStatic();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VWindowBase_SetSelected(lua_State* L) {
  int SWIG_arg = 0;
  VWindowBase *arg1 = (VWindowBase *) 0 ;
  bool arg2 ;
  
  SWIG_check_num_args("SetSelected",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetSelected",1,"VWindowBase *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("SetSelected",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VWindowBase,0))){
    SWIG_fail_ptr("VWindowBase_SetSelected",1,SWIGTYPE_p_VWindowBase);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  (arg1)->SetSelected(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VWindowBase_IsMouseOver(lua_State* L) {
  int SWIG_arg = 0;
  VWindowBase *arg1 = (VWindowBase *) 0 ;
  bool result;
  
  SWIG_check_num_args("IsMouseOver",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("IsMouseOver",1,"VWindowBase const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VWindowBase,0))){
    SWIG_fail_ptr("VWindowBase_IsMouseOver",1,SWIGTYPE_p_VWindowBase);
  }
  
  result = (bool)((VWindowBase const *)arg1)->IsMouseOver();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VWindowBase_HasFocus(lua_State* L) {
  int SWIG_arg = 0;
  VWindowBase *arg1 = (VWindowBase *) 0 ;
  bool result;
  
  SWIG_check_num_args("HasFocus",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("HasFocus",1,"VWindowBase const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VWindowBase,0))){
    SWIG_fail_ptr("VWindowBase_HasFocus",1,SWIGTYPE_p_VWindowBase);
  }
  
  result = (bool)((VWindowBase const *)arg1)->HasFocus();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VWindowBase_IsSelected(lua_State* L) {
  int SWIG_arg = 0;
  VWindowBase *arg1 = (VWindowBase *) 0 ;
  bool result;
  
  SWIG_check_num_args("IsSelected",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("IsSelected",1,"VWindowBase const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VWindowBase,0))){
    SWIG_fail_ptr("VWindowBase_IsSelected",1,SWIGTYPE_p_VWindowBase);
  }
  
  result = (bool)((VWindowBase const *)arg1)->IsSelected();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VWindowBase_GetStatusBitmask(lua_State* L) {
  int SWIG_arg = 0;
  VWindowBase *arg1 = (VWindowBase *) 0 ;
  VBitmask result;
  
  SWIG_check_num_args("GetStatusBitmask",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetStatusBitmask",1,"VWindowBase const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VWindowBase,0))){
    SWIG_fail_ptr("VWindowBase_GetStatusBitmask",1,SWIGTYPE_p_VWindowBase);
  }
  
  result = VWindowBase_GetStatusBitmask((VWindowBase const *)arg1);
  {
    VBitmask * resultptr = new VBitmask((const VBitmask &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_VBitmask,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VWindowBase_SetStatusBitmask(lua_State* L) {
  int SWIG_arg = 0;
  VWindowBase *arg1 = (VWindowBase *) 0 ;
  VBitmask *arg2 = (VBitmask *) 0 ;
  
  SWIG_check_num_args("SetStatusBitmask",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetStatusBitmask",1,"VWindowBase *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SetStatusBitmask",2,"VBitmask *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VWindowBase,0))){
    SWIG_fail_ptr("VWindowBase_SetStatusBitmask",1,SWIGTYPE_p_VWindowBase);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_VBitmask,0))){
    SWIG_fail_ptr("VWindowBase_SetStatusBitmask",2,SWIGTYPE_p_VBitmask);
  }
  
  VWindowBase_SetStatusBitmask(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VWindowBase_SetPosition(lua_State* L) {
  int SWIG_arg = 0;
  VWindowBase *arg1 = (VWindowBase *) 0 ;
  float arg2 ;
  float arg3 ;
  
  SWIG_check_num_args("SetPosition",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetPosition",1,"VWindowBase *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SetPosition",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("SetPosition",3,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VWindowBase,0))){
    SWIG_fail_ptr("VWindowBase_SetPosition",1,SWIGTYPE_p_VWindowBase);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  (arg1)->SetPosition(arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VWindowBase_SetSize(lua_State* L) {
  int SWIG_arg = 0;
  VWindowBase *arg1 = (VWindowBase *) 0 ;
  float arg2 ;
  float arg3 ;
  
  SWIG_check_num_args("SetSize",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetSize",1,"VWindowBase *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SetSize",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("SetSize",3,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VWindowBase,0))){
    SWIG_fail_ptr("VWindowBase_SetSize",1,SWIGTYPE_p_VWindowBase);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  (arg1)->SetSize(arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VWindowBase_SetOrder(lua_State* L) {
  int SWIG_arg = 0;
  VWindowBase *arg1 = (VWindowBase *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("SetOrder",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetOrder",1,"VWindowBase *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SetOrder",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VWindowBase,0))){
    SWIG_fail_ptr("VWindowBase_SetOrder",1,SWIGTYPE_p_VWindowBase);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->SetOrder(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VWindowBase_GetOrder(lua_State* L) {
  int SWIG_arg = 0;
  VWindowBase *arg1 = (VWindowBase *) 0 ;
  int result;
  
  SWIG_check_num_args("GetOrder",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetOrder",1,"VWindowBase const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VWindowBase,0))){
    SWIG_fail_ptr("VWindowBase_GetOrder",1,SWIGTYPE_p_VWindowBase);
  }
  
  result = (int)((VWindowBase const *)arg1)->GetOrder();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VWindowBase_SetTooltip(lua_State* L) {
  int SWIG_arg = 0;
  VWindowBase *arg1 = (VWindowBase *) 0 ;
  char *arg2 = (char *) 0 ;
  
  SWIG_check_num_args("SetTooltip",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetTooltip",1,"VWindowBase *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("SetTooltip",2,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VWindowBase,0))){
    SWIG_fail_ptr("VWindowBase_SetTooltip",1,SWIGTYPE_p_VWindowBase);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  VWindowBase_SetTooltip(arg1,(char const *)arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VWindowBase_SetText(lua_State* L) {
  int SWIG_arg = 0;
  VWindowBase *arg1 = (VWindowBase *) 0 ;
  char *arg2 = (char *) 0 ;
  
  SWIG_check_num_args("SetText",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetText",1,"VWindowBase *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("SetText",2,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VWindowBase,0))){
    SWIG_fail_ptr("VWindowBase_SetText",1,SWIGTYPE_p_VWindowBase);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  VWindowBase_SetText(arg1,(char const *)arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VWindowBase_SetTabOrder(lua_State* L) {
  int SWIG_arg = 0;
  VWindowBase *arg1 = (VWindowBase *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("SetTabOrder",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetTabOrder",1,"VWindowBase *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SetTabOrder",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VWindowBase,0))){
    SWIG_fail_ptr("VWindowBase_SetTabOrder",1,SWIGTYPE_p_VWindowBase);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->SetTabOrder(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VWindowBase_GetTabOrder(lua_State* L) {
  int SWIG_arg = 0;
  VWindowBase *arg1 = (VWindowBase *) 0 ;
  int result;
  
  SWIG_check_num_args("GetTabOrder",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetTabOrder",1,"VWindowBase const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VWindowBase,0))){
    SWIG_fail_ptr("VWindowBase_GetTabOrder",1,SWIGTYPE_p_VWindowBase);
  }
  
  result = (int)((VWindowBase const *)arg1)->GetTabOrder();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static swig_lua_method swig_VWindowBase_methods[] = {
    { "__tostring",VWindowBase_ToString},
    { "GetSize",VWindowBase_GetSize},
    { "GetPosition",VWindowBase_GetPosition},
    { "GetAbsPosition",VWindowBase_GetAbsPosition},
    { "__concat",VWindowBase_Concat},
    {"GetParent", _wrap_VWindowBase_GetParent}, 
    {"GetID", _wrap_VWindowBase_GetID}, 
    {"GetDialogResult", _wrap_VWindowBase_GetDialogResult}, 
    {"SetDialogResult", _wrap_VWindowBase_SetDialogResult}, 
    {"Refresh", _wrap_VWindowBase_Refresh}, 
    {"IsVisible", _wrap_VWindowBase_IsVisible}, 
    {"SetVisible", _wrap_VWindowBase_SetVisible}, 
    {"IsEnabled", _wrap_VWindowBase_IsEnabled}, 
    {"SetEnabled", _wrap_VWindowBase_SetEnabled}, 
    {"IsStatic", _wrap_VWindowBase_IsStatic}, 
    {"SetSelected", _wrap_VWindowBase_SetSelected}, 
    {"IsMouseOver", _wrap_VWindowBase_IsMouseOver}, 
    {"HasFocus", _wrap_VWindowBase_HasFocus}, 
    {"IsSelected", _wrap_VWindowBase_IsSelected}, 
    {"GetStatusBitmask", _wrap_VWindowBase_GetStatusBitmask}, 
    {"SetStatusBitmask", _wrap_VWindowBase_SetStatusBitmask}, 
    {"SetPosition", _wrap_VWindowBase_SetPosition}, 
    {"SetSize", _wrap_VWindowBase_SetSize}, 
    {"SetOrder", _wrap_VWindowBase_SetOrder}, 
    {"GetOrder", _wrap_VWindowBase_GetOrder}, 
    {"SetTooltip", _wrap_VWindowBase_SetTooltip}, 
    {"SetText", _wrap_VWindowBase_SetText}, 
    {"SetTabOrder", _wrap_VWindowBase_SetTabOrder}, 
    {"GetTabOrder", _wrap_VWindowBase_GetTabOrder}, 
    {0,0}
};
static swig_lua_attribute swig_VWindowBase_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_VWindowBase_bases[] = {0,0};
static const char *swig_VWindowBase_base_names[] = {"VisTypedEngineObject_cl *",0};
static swig_lua_class _wrap_class_VWindowBase = { "VWindowBase", &SWIGTYPE_p_VWindowBase,0,0, swig_VWindowBase_methods, swig_VWindowBase_attributes, swig_VWindowBase_bases, swig_VWindowBase_base_names };

static int _wrap_VDialog_BringToFront(lua_State* L) {
  int SWIG_arg = 0;
  VDialog *arg1 = (VDialog *) 0 ;
  
  SWIG_check_num_args("BringToFront",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("BringToFront",1,"VDialog *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VDialog,0))){
    SWIG_fail_ptr("VDialog_BringToFront",1,SWIGTYPE_p_VDialog);
  }
  
  (arg1)->BringToFront();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VDialog_BringToBack(lua_State* L) {
  int SWIG_arg = 0;
  VDialog *arg1 = (VDialog *) 0 ;
  
  SWIG_check_num_args("BringToBack",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("BringToBack",1,"VDialog *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VDialog,0))){
    SWIG_fail_ptr("VDialog_BringToBack",1,SWIGTYPE_p_VDialog);
  }
  
  (arg1)->BringToBack();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VDialog_IsModal(lua_State* L) {
  int SWIG_arg = 0;
  VDialog *arg1 = (VDialog *) 0 ;
  bool result;
  
  SWIG_check_num_args("IsModal",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("IsModal",1,"VDialog const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VDialog,0))){
    SWIG_fail_ptr("VDialog_IsModal",1,SWIGTYPE_p_VDialog);
  }
  
  result = (bool)((VDialog const *)arg1)->IsModal();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VDialog_IsFullscreen(lua_State* L) {
  int SWIG_arg = 0;
  VDialog *arg1 = (VDialog *) 0 ;
  bool result;
  
  SWIG_check_num_args("IsFullscreen",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("IsFullscreen",1,"VDialog const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VDialog,0))){
    SWIG_fail_ptr("VDialog_IsFullscreen",1,SWIGTYPE_p_VDialog);
  }
  
  result = (bool)((VDialog const *)arg1)->IsFullscreen();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VDialog_SetFocusItem(lua_State* L) {
  int SWIG_arg = 0;
  VDialog *arg1 = (VDialog *) 0 ;
  VWindowBase *arg2 = (VWindowBase *) 0 ;
  
  SWIG_check_num_args("SetFocusItem",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetFocusItem",1,"VDialog *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SetFocusItem",2,"VWindowBase *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VDialog,0))){
    SWIG_fail_ptr("VDialog_SetFocusItem",1,SWIGTYPE_p_VDialog);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_VWindowBase,0))){
    SWIG_fail_ptr("VDialog_SetFocusItem",2,SWIGTYPE_p_VWindowBase);
  }
  
  (arg1)->SetFocusItem(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VDialog_GetFocusItem(lua_State* L) {
  int SWIG_arg = 0;
  VDialog *arg1 = (VDialog *) 0 ;
  VWindowBase *result = 0 ;
  
  SWIG_check_num_args("GetFocusItem",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetFocusItem",1,"VDialog const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VDialog,0))){
    SWIG_fail_ptr("VDialog_GetFocusItem",1,SWIGTYPE_p_VDialog);
  }
  
  result = (VWindowBase *)((VDialog const *)arg1)->GetFocusItem();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_VWindowBase,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_VDialog(lua_State* L) {
  int SWIG_arg = 0;
  VDialog *result = 0 ;
  
  SWIG_check_num_args("VDialog::VDialog",0,0)
  result = (VDialog *)new VDialog();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_VDialog,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static swig_lua_method swig_VDialog_methods[] = {
    { "__tostring",VDialog_ToString},
    { "GetStartPosition",VDialog_GetStartPosition},
    {"BringToFront", _wrap_VDialog_BringToFront}, 
    {"BringToBack", _wrap_VDialog_BringToBack}, 
    {"IsModal", _wrap_VDialog_IsModal}, 
    {"IsFullscreen", _wrap_VDialog_IsFullscreen}, 
    {"SetFocusItem", _wrap_VDialog_SetFocusItem}, 
    {"GetFocusItem", _wrap_VDialog_GetFocusItem}, 
    {0,0}
};
static swig_lua_attribute swig_VDialog_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_VDialog_bases[] = {0,0};
static const char *swig_VDialog_base_names[] = {"VWindowBase *",0};
static swig_lua_class _wrap_class_VDialog = { "VDialog", &SWIGTYPE_p_VDialog,_wrap_new_VDialog,0, swig_VDialog_methods, swig_VDialog_attributes, swig_VDialog_bases, swig_VDialog_base_names };

static int _wrap_VStringInputMap_GetTrigger(lua_State* L) {
  int SWIG_arg = 0;
  VStringInputMap *arg1 = (VStringInputMap *) 0 ;
  char *arg2 = (char *) 0 ;
  float result;
  
  SWIG_check_num_args("GetTrigger",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetTrigger",1,"VStringInputMap *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("GetTrigger",2,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VStringInputMap,0))){
    SWIG_fail_ptr("VStringInputMap_GetTrigger",1,SWIGTYPE_p_VStringInputMap);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  result = (float)(arg1)->GetTrigger((char const *)arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static swig_lua_method swig_VStringInputMap_methods[] = {
    { "__tostring",VStringInputMap_ToString},
    { "MapTriggerAxis",VStringInputMap_MapTriggerAxis},
    { "MapTrigger",VStringInputMap_MapTrigger},
    { "__concat",VStringInputMap_Concat},
    {"GetTrigger", _wrap_VStringInputMap_GetTrigger}, 
    {0,0}
};
static swig_lua_attribute swig_VStringInputMap_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_VStringInputMap_bases[] = {0};
static const char *swig_VStringInputMap_base_names[] = {0};
static swig_lua_class _wrap_class_VStringInputMap = { "VStringInputMap", &SWIGTYPE_p_VStringInputMap,0,0, swig_VStringInputMap_methods, swig_VStringInputMap_attributes, swig_VStringInputMap_bases, swig_VStringInputMap_base_names };

static int _wrap_VisGame_cl_CreateLight__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  VisGame_cl *arg1 = (VisGame_cl *) 0 ;
  hkvVec3 *arg2 = (hkvVec3 *) 0 ;
  int arg3 ;
  float arg4 ;
  char *arg5 = (char *) 0 ;
  VisLightSource_cl *result = 0 ;
  
  SWIG_check_num_args("CreateLight",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("CreateLight",1,"VisGame_cl *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("CreateLight",2,"hkvVec3 const *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("CreateLight",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("CreateLight",4,"float");
  if(!SWIG_lua_isnilstring(L,5)) SWIG_fail_arg("CreateLight",5,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisGame_cl,0))){
    SWIG_fail_ptr("VisGame_cl_CreateLight",1,SWIGTYPE_p_VisGame_cl);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("VisGame_cl_CreateLight",2,SWIGTYPE_p_hkvVec3);
  }
  
  arg3 = (int)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4);
  arg5 = (char *)lua_tostring(L, 5);
  result = (VisLightSource_cl *)VisGame_cl_CreateLight__SWIG_0(arg1,(hkvVec3 const *)arg2,arg3,arg4,(char const *)arg5);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_VisLightSource_cl,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisGame_cl_CreateLight__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  VisGame_cl *arg1 = (VisGame_cl *) 0 ;
  hkvVec3 *arg2 = (hkvVec3 *) 0 ;
  int arg3 ;
  float arg4 ;
  VisLightSource_cl *result = 0 ;
  
  SWIG_check_num_args("CreateLight",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("CreateLight",1,"VisGame_cl *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("CreateLight",2,"hkvVec3 const *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("CreateLight",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("CreateLight",4,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisGame_cl,0))){
    SWIG_fail_ptr("VisGame_cl_CreateLight",1,SWIGTYPE_p_VisGame_cl);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("VisGame_cl_CreateLight",2,SWIGTYPE_p_hkvVec3);
  }
  
  arg3 = (int)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4);
  result = (VisLightSource_cl *)VisGame_cl_CreateLight__SWIG_0(arg1,(hkvVec3 const *)arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_VisLightSource_cl,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisGame_cl_CreateLight__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  VisGame_cl *arg1 = (VisGame_cl *) 0 ;
  hkvVec3 *arg2 = (hkvVec3 *) 0 ;
  int arg3 ;
  VisLightSource_cl *result = 0 ;
  
  SWIG_check_num_args("CreateLight",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("CreateLight",1,"VisGame_cl *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("CreateLight",2,"hkvVec3 const *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("CreateLight",3,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisGame_cl,0))){
    SWIG_fail_ptr("VisGame_cl_CreateLight",1,SWIGTYPE_p_VisGame_cl);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("VisGame_cl_CreateLight",2,SWIGTYPE_p_hkvVec3);
  }
  
  arg3 = (int)lua_tonumber(L, 3);
  result = (VisLightSource_cl *)VisGame_cl_CreateLight__SWIG_0(arg1,(hkvVec3 const *)arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_VisLightSource_cl,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisGame_cl_CreateLight__SWIG_3(lua_State* L) {
  int SWIG_arg = 0;
  VisGame_cl *arg1 = (VisGame_cl *) 0 ;
  hkvVec3 *arg2 = (hkvVec3 *) 0 ;
  VisLightSource_cl *result = 0 ;
  
  SWIG_check_num_args("CreateLight",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("CreateLight",1,"VisGame_cl *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("CreateLight",2,"hkvVec3 const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisGame_cl,0))){
    SWIG_fail_ptr("VisGame_cl_CreateLight",1,SWIGTYPE_p_VisGame_cl);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("VisGame_cl_CreateLight",2,SWIGTYPE_p_hkvVec3);
  }
  
  result = (VisLightSource_cl *)VisGame_cl_CreateLight__SWIG_0(arg1,(hkvVec3 const *)arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_VisLightSource_cl,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisGame_cl_CreateLight(lua_State* L) {
  int argc;
  int argv[6]={
    1,2,3,4,5,6
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VisGame_cl, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_hkvVec3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_VisGame_cl_CreateLight__SWIG_3(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VisGame_cl, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_hkvVec3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          return _wrap_VisGame_cl_CreateLight__SWIG_2(L);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VisGame_cl, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_hkvVec3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_VisGame_cl_CreateLight__SWIG_1(L);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VisGame_cl, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_hkvVec3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            {
              _v = SWIG_lua_isnilstring(L,argv[4]);
            }
            if (_v) {
              return _wrap_VisGame_cl_CreateLight__SWIG_0(L);
            }
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'VisGame_cl_CreateLight'\n"
    "  Possible C/C++ prototypes are:\n"
    "    CreateLight(VisGame_cl *,hkvVec3 const *,int,float,char const *)\n"
    "    CreateLight(VisGame_cl *,hkvVec3 const *,int,float)\n"
    "    CreateLight(VisGame_cl *,hkvVec3 const *,int)\n"
    "    CreateLight(VisGame_cl *,hkvVec3 const *)\n");
  lua_error(L);return 0;
}


static int _wrap_VisGame_cl_CreatePath__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  VisGame_cl *arg1 = (VisGame_cl *) 0 ;
  int arg2 ;
  bool arg3 ;
  char *arg4 = (char *) 0 ;
  VisPath_cl *result = 0 ;
  
  SWIG_check_num_args("CreatePath",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("CreatePath",1,"VisGame_cl *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("CreatePath",2,"int");
  if(!lua_isboolean(L,3)) SWIG_fail_arg("CreatePath",3,"bool");
  if(!SWIG_lua_isnilstring(L,4)) SWIG_fail_arg("CreatePath",4,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisGame_cl,0))){
    SWIG_fail_ptr("VisGame_cl_CreatePath",1,SWIGTYPE_p_VisGame_cl);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (lua_toboolean(L, 3)!=0);
  arg4 = (char *)lua_tostring(L, 4);
  result = (VisPath_cl *)VisGame_cl_CreatePath__SWIG_0(arg1,arg2,arg3,(char const *)arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_VisPath_cl,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisGame_cl_CreatePath__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  VisGame_cl *arg1 = (VisGame_cl *) 0 ;
  int arg2 ;
  bool arg3 ;
  VisPath_cl *result = 0 ;
  
  SWIG_check_num_args("CreatePath",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("CreatePath",1,"VisGame_cl *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("CreatePath",2,"int");
  if(!lua_isboolean(L,3)) SWIG_fail_arg("CreatePath",3,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisGame_cl,0))){
    SWIG_fail_ptr("VisGame_cl_CreatePath",1,SWIGTYPE_p_VisGame_cl);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (lua_toboolean(L, 3)!=0);
  result = (VisPath_cl *)VisGame_cl_CreatePath__SWIG_0(arg1,arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_VisPath_cl,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisGame_cl_CreatePath__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  VisGame_cl *arg1 = (VisGame_cl *) 0 ;
  int arg2 ;
  VisPath_cl *result = 0 ;
  
  SWIG_check_num_args("CreatePath",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("CreatePath",1,"VisGame_cl *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("CreatePath",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisGame_cl,0))){
    SWIG_fail_ptr("VisGame_cl_CreatePath",1,SWIGTYPE_p_VisGame_cl);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  result = (VisPath_cl *)VisGame_cl_CreatePath__SWIG_0(arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_VisPath_cl,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisGame_cl_CreatePath__SWIG_3(lua_State* L) {
  int SWIG_arg = 0;
  VisGame_cl *arg1 = (VisGame_cl *) 0 ;
  VisPath_cl *result = 0 ;
  
  SWIG_check_num_args("CreatePath",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("CreatePath",1,"VisGame_cl *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisGame_cl,0))){
    SWIG_fail_ptr("VisGame_cl_CreatePath",1,SWIGTYPE_p_VisGame_cl);
  }
  
  result = (VisPath_cl *)VisGame_cl_CreatePath__SWIG_0(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_VisPath_cl,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisGame_cl_CreatePath(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VisGame_cl, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_VisGame_cl_CreatePath__SWIG_3(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VisGame_cl, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_VisGame_cl_CreatePath__SWIG_2(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VisGame_cl, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isboolean(L,argv[2]);
        }
        if (_v) {
          return _wrap_VisGame_cl_CreatePath__SWIG_1(L);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VisGame_cl, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isboolean(L,argv[2]);
        }
        if (_v) {
          {
            _v = SWIG_lua_isnilstring(L,argv[3]);
          }
          if (_v) {
            return _wrap_VisGame_cl_CreatePath__SWIG_0(L);
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'VisGame_cl_CreatePath'\n"
    "  Possible C/C++ prototypes are:\n"
    "    CreatePath(VisGame_cl *,int,bool,char const *)\n"
    "    CreatePath(VisGame_cl *,int,bool)\n"
    "    CreatePath(VisGame_cl *,int)\n"
    "    CreatePath(VisGame_cl *)\n");
  lua_error(L);return 0;
}


static int _wrap_VisGame_cl_CreatePathNode__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  VisGame_cl *arg1 = (VisGame_cl *) 0 ;
  hkvVec3 *arg2 = (hkvVec3 *) 0 ;
  char *arg3 = (char *) 0 ;
  VisPathNode_cl *result = 0 ;
  
  SWIG_check_num_args("CreatePathNode",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("CreatePathNode",1,"VisGame_cl *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("CreatePathNode",2,"hkvVec3 const *");
  if(!SWIG_lua_isnilstring(L,3)) SWIG_fail_arg("CreatePathNode",3,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisGame_cl,0))){
    SWIG_fail_ptr("VisGame_cl_CreatePathNode",1,SWIGTYPE_p_VisGame_cl);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("VisGame_cl_CreatePathNode",2,SWIGTYPE_p_hkvVec3);
  }
  
  arg3 = (char *)lua_tostring(L, 3);
  result = (VisPathNode_cl *)VisGame_cl_CreatePathNode__SWIG_0(arg1,(hkvVec3 const *)arg2,(char const *)arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_VisPathNode_cl,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisGame_cl_CreatePathNode__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  VisGame_cl *arg1 = (VisGame_cl *) 0 ;
  hkvVec3 *arg2 = (hkvVec3 *) 0 ;
  VisPathNode_cl *result = 0 ;
  
  SWIG_check_num_args("CreatePathNode",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("CreatePathNode",1,"VisGame_cl *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("CreatePathNode",2,"hkvVec3 const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisGame_cl,0))){
    SWIG_fail_ptr("VisGame_cl_CreatePathNode",1,SWIGTYPE_p_VisGame_cl);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("VisGame_cl_CreatePathNode",2,SWIGTYPE_p_hkvVec3);
  }
  
  result = (VisPathNode_cl *)VisGame_cl_CreatePathNode__SWIG_0(arg1,(hkvVec3 const *)arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_VisPathNode_cl,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisGame_cl_CreatePathNode(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VisGame_cl, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_hkvVec3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_VisGame_cl_CreatePathNode__SWIG_1(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VisGame_cl, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_hkvVec3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          _v = SWIG_lua_isnilstring(L,argv[2]);
        }
        if (_v) {
          return _wrap_VisGame_cl_CreatePathNode__SWIG_0(L);
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'VisGame_cl_CreatePathNode'\n"
    "  Possible C/C++ prototypes are:\n"
    "    CreatePathNode(VisGame_cl *,hkvVec3 const *,char const *)\n"
    "    CreatePathNode(VisGame_cl *,hkvVec3 const *)\n");
  lua_error(L);return 0;
}


static int _wrap_VisGame_cl_CreateEffect__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  VisGame_cl *arg1 = (VisGame_cl *) 0 ;
  hkvVec3 *arg2 = (hkvVec3 *) 0 ;
  char *arg3 = (char *) 0 ;
  char *arg4 = (char *) 0 ;
  VisParticleEffect_cl *result = 0 ;
  
  SWIG_check_num_args("CreateEffect",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("CreateEffect",1,"VisGame_cl *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("CreateEffect",2,"hkvVec3 const *");
  if(!SWIG_lua_isnilstring(L,3)) SWIG_fail_arg("CreateEffect",3,"char const *");
  if(!SWIG_lua_isnilstring(L,4)) SWIG_fail_arg("CreateEffect",4,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisGame_cl,0))){
    SWIG_fail_ptr("VisGame_cl_CreateEffect",1,SWIGTYPE_p_VisGame_cl);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("VisGame_cl_CreateEffect",2,SWIGTYPE_p_hkvVec3);
  }
  
  arg3 = (char *)lua_tostring(L, 3);
  arg4 = (char *)lua_tostring(L, 4);
  result = (VisParticleEffect_cl *)VisGame_cl_CreateEffect__SWIG_0(arg1,(hkvVec3 const *)arg2,(char const *)arg3,(char const *)arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_VisParticleEffect_cl,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisGame_cl_CreateEffect__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  VisGame_cl *arg1 = (VisGame_cl *) 0 ;
  hkvVec3 *arg2 = (hkvVec3 *) 0 ;
  char *arg3 = (char *) 0 ;
  VisParticleEffect_cl *result = 0 ;
  
  SWIG_check_num_args("CreateEffect",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("CreateEffect",1,"VisGame_cl *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("CreateEffect",2,"hkvVec3 const *");
  if(!SWIG_lua_isnilstring(L,3)) SWIG_fail_arg("CreateEffect",3,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisGame_cl,0))){
    SWIG_fail_ptr("VisGame_cl_CreateEffect",1,SWIGTYPE_p_VisGame_cl);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("VisGame_cl_CreateEffect",2,SWIGTYPE_p_hkvVec3);
  }
  
  arg3 = (char *)lua_tostring(L, 3);
  result = (VisParticleEffect_cl *)VisGame_cl_CreateEffect__SWIG_0(arg1,(hkvVec3 const *)arg2,(char const *)arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_VisParticleEffect_cl,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisGame_cl_CreateEffect(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VisGame_cl, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_hkvVec3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          _v = SWIG_lua_isnilstring(L,argv[2]);
        }
        if (_v) {
          return _wrap_VisGame_cl_CreateEffect__SWIG_1(L);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VisGame_cl, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_hkvVec3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          _v = SWIG_lua_isnilstring(L,argv[2]);
        }
        if (_v) {
          {
            _v = SWIG_lua_isnilstring(L,argv[3]);
          }
          if (_v) {
            return _wrap_VisGame_cl_CreateEffect__SWIG_0(L);
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'VisGame_cl_CreateEffect'\n"
    "  Possible C/C++ prototypes are:\n"
    "    CreateEffect(VisGame_cl *,hkvVec3 const *,char const *,char const *)\n"
    "    CreateEffect(VisGame_cl *,hkvVec3 const *,char const *)\n");
  lua_error(L);return 0;
}


static int _wrap_VisGame_cl_CreateStaticMeshInstance__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  VisGame_cl *arg1 = (VisGame_cl *) 0 ;
  hkvVec3 *arg2 = (hkvVec3 *) 0 ;
  char *arg3 = (char *) 0 ;
  bool arg4 ;
  char *arg5 = (char *) 0 ;
  VisStaticMeshInstance_cl *result = 0 ;
  
  SWIG_check_num_args("CreateStaticMeshInstance",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("CreateStaticMeshInstance",1,"VisGame_cl *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("CreateStaticMeshInstance",2,"hkvVec3 const *");
  if(!SWIG_lua_isnilstring(L,3)) SWIG_fail_arg("CreateStaticMeshInstance",3,"char const *");
  if(!lua_isboolean(L,4)) SWIG_fail_arg("CreateStaticMeshInstance",4,"bool");
  if(!SWIG_lua_isnilstring(L,5)) SWIG_fail_arg("CreateStaticMeshInstance",5,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisGame_cl,0))){
    SWIG_fail_ptr("VisGame_cl_CreateStaticMeshInstance",1,SWIGTYPE_p_VisGame_cl);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("VisGame_cl_CreateStaticMeshInstance",2,SWIGTYPE_p_hkvVec3);
  }
  
  arg3 = (char *)lua_tostring(L, 3);
  arg4 = (lua_toboolean(L, 4)!=0);
  arg5 = (char *)lua_tostring(L, 5);
  result = (VisStaticMeshInstance_cl *)VisGame_cl_CreateStaticMeshInstance__SWIG_0(arg1,(hkvVec3 const *)arg2,(char const *)arg3,arg4,(char const *)arg5);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_VisStaticMeshInstance_cl,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisGame_cl_CreateStaticMeshInstance__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  VisGame_cl *arg1 = (VisGame_cl *) 0 ;
  hkvVec3 *arg2 = (hkvVec3 *) 0 ;
  char *arg3 = (char *) 0 ;
  bool arg4 ;
  VisStaticMeshInstance_cl *result = 0 ;
  
  SWIG_check_num_args("CreateStaticMeshInstance",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("CreateStaticMeshInstance",1,"VisGame_cl *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("CreateStaticMeshInstance",2,"hkvVec3 const *");
  if(!SWIG_lua_isnilstring(L,3)) SWIG_fail_arg("CreateStaticMeshInstance",3,"char const *");
  if(!lua_isboolean(L,4)) SWIG_fail_arg("CreateStaticMeshInstance",4,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisGame_cl,0))){
    SWIG_fail_ptr("VisGame_cl_CreateStaticMeshInstance",1,SWIGTYPE_p_VisGame_cl);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("VisGame_cl_CreateStaticMeshInstance",2,SWIGTYPE_p_hkvVec3);
  }
  
  arg3 = (char *)lua_tostring(L, 3);
  arg4 = (lua_toboolean(L, 4)!=0);
  result = (VisStaticMeshInstance_cl *)VisGame_cl_CreateStaticMeshInstance__SWIG_0(arg1,(hkvVec3 const *)arg2,(char const *)arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_VisStaticMeshInstance_cl,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisGame_cl_CreateStaticMeshInstance__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  VisGame_cl *arg1 = (VisGame_cl *) 0 ;
  hkvVec3 *arg2 = (hkvVec3 *) 0 ;
  char *arg3 = (char *) 0 ;
  VisStaticMeshInstance_cl *result = 0 ;
  
  SWIG_check_num_args("CreateStaticMeshInstance",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("CreateStaticMeshInstance",1,"VisGame_cl *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("CreateStaticMeshInstance",2,"hkvVec3 const *");
  if(!SWIG_lua_isnilstring(L,3)) SWIG_fail_arg("CreateStaticMeshInstance",3,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisGame_cl,0))){
    SWIG_fail_ptr("VisGame_cl_CreateStaticMeshInstance",1,SWIGTYPE_p_VisGame_cl);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("VisGame_cl_CreateStaticMeshInstance",2,SWIGTYPE_p_hkvVec3);
  }
  
  arg3 = (char *)lua_tostring(L, 3);
  result = (VisStaticMeshInstance_cl *)VisGame_cl_CreateStaticMeshInstance__SWIG_0(arg1,(hkvVec3 const *)arg2,(char const *)arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_VisStaticMeshInstance_cl,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisGame_cl_CreateStaticMeshInstance(lua_State* L) {
  int argc;
  int argv[6]={
    1,2,3,4,5,6
  };
  
  argc = lua_gettop(L);
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VisGame_cl, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_hkvVec3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          _v = SWIG_lua_isnilstring(L,argv[2]);
        }
        if (_v) {
          return _wrap_VisGame_cl_CreateStaticMeshInstance__SWIG_2(L);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VisGame_cl, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_hkvVec3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          _v = SWIG_lua_isnilstring(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isboolean(L,argv[3]);
          }
          if (_v) {
            return _wrap_VisGame_cl_CreateStaticMeshInstance__SWIG_1(L);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VisGame_cl, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_hkvVec3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          _v = SWIG_lua_isnilstring(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isboolean(L,argv[3]);
          }
          if (_v) {
            {
              _v = SWIG_lua_isnilstring(L,argv[4]);
            }
            if (_v) {
              return _wrap_VisGame_cl_CreateStaticMeshInstance__SWIG_0(L);
            }
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'VisGame_cl_CreateStaticMeshInstance'\n"
    "  Possible C/C++ prototypes are:\n"
    "    CreateStaticMeshInstance(VisGame_cl *,hkvVec3 const *,char const *,bool,char const *)\n"
    "    CreateStaticMeshInstance(VisGame_cl *,hkvVec3 const *,char const *,bool)\n"
    "    CreateStaticMeshInstance(VisGame_cl *,hkvVec3 const *,char const *)\n");
  lua_error(L);return 0;
}


static int _wrap_VisGame_cl_CreateDynamicMesh__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  VisGame_cl *arg1 = (VisGame_cl *) 0 ;
  char *arg2 = (char *) 0 ;
  bool arg3 ;
  bool arg4 ;
  VDynamicMesh *result = 0 ;
  
  SWIG_check_num_args("CreateDynamicMesh",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("CreateDynamicMesh",1,"VisGame_cl *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("CreateDynamicMesh",2,"char const *");
  if(!lua_isboolean(L,3)) SWIG_fail_arg("CreateDynamicMesh",3,"bool");
  if(!lua_isboolean(L,4)) SWIG_fail_arg("CreateDynamicMesh",4,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisGame_cl,0))){
    SWIG_fail_ptr("VisGame_cl_CreateDynamicMesh",1,SWIGTYPE_p_VisGame_cl);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  arg3 = (lua_toboolean(L, 3)!=0);
  arg4 = (lua_toboolean(L, 4)!=0);
  result = (VDynamicMesh *)VisGame_cl_CreateDynamicMesh__SWIG_0(arg1,(char const *)arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_VDynamicMesh,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisGame_cl_CreateDynamicMesh__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  VisGame_cl *arg1 = (VisGame_cl *) 0 ;
  char *arg2 = (char *) 0 ;
  bool arg3 ;
  VDynamicMesh *result = 0 ;
  
  SWIG_check_num_args("CreateDynamicMesh",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("CreateDynamicMesh",1,"VisGame_cl *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("CreateDynamicMesh",2,"char const *");
  if(!lua_isboolean(L,3)) SWIG_fail_arg("CreateDynamicMesh",3,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisGame_cl,0))){
    SWIG_fail_ptr("VisGame_cl_CreateDynamicMesh",1,SWIGTYPE_p_VisGame_cl);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  arg3 = (lua_toboolean(L, 3)!=0);
  result = (VDynamicMesh *)VisGame_cl_CreateDynamicMesh__SWIG_0(arg1,(char const *)arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_VDynamicMesh,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisGame_cl_CreateDynamicMesh(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VisGame_cl, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = SWIG_lua_isnilstring(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isboolean(L,argv[2]);
        }
        if (_v) {
          return _wrap_VisGame_cl_CreateDynamicMesh__SWIG_1(L);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VisGame_cl, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = SWIG_lua_isnilstring(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isboolean(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isboolean(L,argv[3]);
          }
          if (_v) {
            return _wrap_VisGame_cl_CreateDynamicMesh__SWIG_0(L);
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'VisGame_cl_CreateDynamicMesh'\n"
    "  Possible C/C++ prototypes are:\n"
    "    CreateDynamicMesh(VisGame_cl *,char const *,bool,bool)\n"
    "    CreateDynamicMesh(VisGame_cl *,char const *,bool)\n");
  lua_error(L);return 0;
}


static int _wrap_VisGame_cl_MergeMeshes(lua_State* L) {
  int SWIG_arg = 0;
  VisGame_cl *arg1 = (VisGame_cl *) 0 ;
  VDynamicMesh **arg2 = (VDynamicMesh **) 0 ;
  int arg3 ;
  VDynamicMesh *result = 0 ;
  
  SWIG_check_num_args("MergeMeshes",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MergeMeshes",1,"VisGame_cl *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisGame_cl,0))){
    SWIG_fail_ptr("VisGame_cl_MergeMeshes",1,SWIGTYPE_p_VisGame_cl);
  }
  
  arg2 = (VDynamicMesh **)SWIG_get_ptr_array_var(L,2,&arg3,SWIGTYPE_p_VDynamicMesh);
  if (!arg2) SWIG_fail;
  result = (VDynamicMesh *)VisGame_cl_MergeMeshes(arg1,arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_VDynamicMesh,0); SWIG_arg++; 
  SWIG_FREE_ARRAY(arg2);
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  SWIG_FREE_ARRAY(arg2);
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisGame_cl_MergeMeshesByString(lua_State* L) {
  int SWIG_arg = 0;
  VisGame_cl *arg1 = (VisGame_cl *) 0 ;
  char **arg2 = (char **) 0 ;
  int arg3 ;
  VDynamicMesh *result = 0 ;
  
  SWIG_check_num_args("MergeMeshesByString",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MergeMeshesByString",1,"VisGame_cl *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("MergeMeshesByString",2,"char const **");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("MergeMeshesByString",3,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisGame_cl,0))){
    SWIG_fail_ptr("VisGame_cl_MergeMeshesByString",1,SWIGTYPE_p_VisGame_cl);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_p_char,0))){
    SWIG_fail_ptr("VisGame_cl_MergeMeshesByString",2,SWIGTYPE_p_p_char);
  }
  
  arg3 = (int)lua_tonumber(L, 3);
  result = (VDynamicMesh *)VisGame_cl_MergeMeshesByString(arg1,(char const **)arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_VDynamicMesh,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisGame_cl_CreateTexture__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  VisGame_cl *arg1 = (VisGame_cl *) 0 ;
  char *arg2 = (char *) 0 ;
  bool arg3 ;
  VTextureObject *result = 0 ;
  
  SWIG_check_num_args("CreateTexture",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("CreateTexture",1,"VisGame_cl *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("CreateTexture",2,"char const *");
  if(!lua_isboolean(L,3)) SWIG_fail_arg("CreateTexture",3,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisGame_cl,0))){
    SWIG_fail_ptr("VisGame_cl_CreateTexture",1,SWIGTYPE_p_VisGame_cl);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  arg3 = (lua_toboolean(L, 3)!=0);
  result = (VTextureObject *)VisGame_cl_CreateTexture__SWIG_0(arg1,(char const *)arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_VTextureObject,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisGame_cl_CreateTexture__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  VisGame_cl *arg1 = (VisGame_cl *) 0 ;
  char *arg2 = (char *) 0 ;
  VTextureObject *result = 0 ;
  
  SWIG_check_num_args("CreateTexture",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("CreateTexture",1,"VisGame_cl *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("CreateTexture",2,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisGame_cl,0))){
    SWIG_fail_ptr("VisGame_cl_CreateTexture",1,SWIGTYPE_p_VisGame_cl);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  result = (VTextureObject *)VisGame_cl_CreateTexture__SWIG_0(arg1,(char const *)arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_VTextureObject,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisGame_cl_CreateTexture(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VisGame_cl, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = SWIG_lua_isnilstring(L,argv[1]);
      }
      if (_v) {
        return _wrap_VisGame_cl_CreateTexture__SWIG_1(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VisGame_cl, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = SWIG_lua_isnilstring(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isboolean(L,argv[2]);
        }
        if (_v) {
          return _wrap_VisGame_cl_CreateTexture__SWIG_0(L);
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'VisGame_cl_CreateTexture'\n"
    "  Possible C/C++ prototypes are:\n"
    "    CreateTexture(VisGame_cl *,char const *,bool)\n"
    "    CreateTexture(VisGame_cl *,char const *)\n");
  lua_error(L);return 0;
}


static int _wrap_VisGame_cl_CreateCamera__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  VisGame_cl *arg1 = (VisGame_cl *) 0 ;
  bool arg2 ;
  char *arg3 = (char *) 0 ;
  VisContextCamera_cl *result = 0 ;
  
  SWIG_check_num_args("CreateCamera",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("CreateCamera",1,"VisGame_cl *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("CreateCamera",2,"bool");
  if(!SWIG_lua_isnilstring(L,3)) SWIG_fail_arg("CreateCamera",3,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisGame_cl,0))){
    SWIG_fail_ptr("VisGame_cl_CreateCamera",1,SWIGTYPE_p_VisGame_cl);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  arg3 = (char *)lua_tostring(L, 3);
  result = (VisContextCamera_cl *)VisGame_cl_CreateCamera__SWIG_0(arg1,arg2,(char const *)arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_VisContextCamera_cl,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisGame_cl_CreateCamera__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  VisGame_cl *arg1 = (VisGame_cl *) 0 ;
  bool arg2 ;
  VisContextCamera_cl *result = 0 ;
  
  SWIG_check_num_args("CreateCamera",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("CreateCamera",1,"VisGame_cl *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("CreateCamera",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisGame_cl,0))){
    SWIG_fail_ptr("VisGame_cl_CreateCamera",1,SWIGTYPE_p_VisGame_cl);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  result = (VisContextCamera_cl *)VisGame_cl_CreateCamera__SWIG_0(arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_VisContextCamera_cl,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisGame_cl_CreateCamera__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  VisGame_cl *arg1 = (VisGame_cl *) 0 ;
  VisContextCamera_cl *result = 0 ;
  
  SWIG_check_num_args("CreateCamera",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("CreateCamera",1,"VisGame_cl *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisGame_cl,0))){
    SWIG_fail_ptr("VisGame_cl_CreateCamera",1,SWIGTYPE_p_VisGame_cl);
  }
  
  result = (VisContextCamera_cl *)VisGame_cl_CreateCamera__SWIG_0(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_VisContextCamera_cl,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisGame_cl_CreateCamera(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VisGame_cl, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_VisGame_cl_CreateCamera__SWIG_2(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VisGame_cl, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isboolean(L,argv[1]);
      }
      if (_v) {
        return _wrap_VisGame_cl_CreateCamera__SWIG_1(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VisGame_cl, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isboolean(L,argv[1]);
      }
      if (_v) {
        {
          _v = SWIG_lua_isnilstring(L,argv[2]);
        }
        if (_v) {
          return _wrap_VisGame_cl_CreateCamera__SWIG_0(L);
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'VisGame_cl_CreateCamera'\n"
    "  Possible C/C++ prototypes are:\n"
    "    CreateCamera(VisGame_cl *,bool,char const *)\n"
    "    CreateCamera(VisGame_cl *,bool)\n"
    "    CreateCamera(VisGame_cl *)\n");
  lua_error(L);return 0;
}


static int _wrap_VisGame_cl_CreateScreenMask__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  VisGame_cl *arg1 = (VisGame_cl *) 0 ;
  float arg2 ;
  float arg3 ;
  char *arg4 = (char *) 0 ;
  char *arg5 = (char *) 0 ;
  VisScreenMask_cl *result = 0 ;
  
  SWIG_check_num_args("CreateScreenMask",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("CreateScreenMask",1,"VisGame_cl *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("CreateScreenMask",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("CreateScreenMask",3,"float");
  if(!SWIG_lua_isnilstring(L,4)) SWIG_fail_arg("CreateScreenMask",4,"char const *");
  if(!SWIG_lua_isnilstring(L,5)) SWIG_fail_arg("CreateScreenMask",5,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisGame_cl,0))){
    SWIG_fail_ptr("VisGame_cl_CreateScreenMask",1,SWIGTYPE_p_VisGame_cl);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (char *)lua_tostring(L, 4);
  arg5 = (char *)lua_tostring(L, 5);
  result = (VisScreenMask_cl *)VisGame_cl_CreateScreenMask__SWIG_0(arg1,arg2,arg3,(char const *)arg4,(char const *)arg5);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_VisScreenMask_cl,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisGame_cl_CreateScreenMask__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  VisGame_cl *arg1 = (VisGame_cl *) 0 ;
  float arg2 ;
  float arg3 ;
  char *arg4 = (char *) 0 ;
  VisScreenMask_cl *result = 0 ;
  
  SWIG_check_num_args("CreateScreenMask",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("CreateScreenMask",1,"VisGame_cl *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("CreateScreenMask",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("CreateScreenMask",3,"float");
  if(!SWIG_lua_isnilstring(L,4)) SWIG_fail_arg("CreateScreenMask",4,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisGame_cl,0))){
    SWIG_fail_ptr("VisGame_cl_CreateScreenMask",1,SWIGTYPE_p_VisGame_cl);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (char *)lua_tostring(L, 4);
  result = (VisScreenMask_cl *)VisGame_cl_CreateScreenMask__SWIG_0(arg1,arg2,arg3,(char const *)arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_VisScreenMask_cl,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisGame_cl_CreateScreenMask(lua_State* L) {
  int argc;
  int argv[6]={
    1,2,3,4,5,6
  };
  
  argc = lua_gettop(L);
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VisGame_cl, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = SWIG_lua_isnilstring(L,argv[3]);
          }
          if (_v) {
            return _wrap_VisGame_cl_CreateScreenMask__SWIG_1(L);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VisGame_cl, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = SWIG_lua_isnilstring(L,argv[3]);
          }
          if (_v) {
            {
              _v = SWIG_lua_isnilstring(L,argv[4]);
            }
            if (_v) {
              return _wrap_VisGame_cl_CreateScreenMask__SWIG_0(L);
            }
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'VisGame_cl_CreateScreenMask'\n"
    "  Possible C/C++ prototypes are:\n"
    "    CreateScreenMask(VisGame_cl *,float,float,char const *,char const *)\n"
    "    CreateScreenMask(VisGame_cl *,float,float,char const *)\n");
  lua_error(L);return 0;
}


static int _wrap_VisGame_cl_GetLight(lua_State* L) {
  int SWIG_arg = 0;
  VisGame_cl *arg1 = (VisGame_cl *) 0 ;
  char *arg2 = (char *) 0 ;
  VisLightSource_cl *result = 0 ;
  
  SWIG_check_num_args("GetLight",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetLight",1,"VisGame_cl *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("GetLight",2,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisGame_cl,0))){
    SWIG_fail_ptr("VisGame_cl_GetLight",1,SWIGTYPE_p_VisGame_cl);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  result = (VisLightSource_cl *)VisGame_cl_GetLight(arg1,(char const *)arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_VisLightSource_cl,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisGame_cl_GetPath(lua_State* L) {
  int SWIG_arg = 0;
  VisGame_cl *arg1 = (VisGame_cl *) 0 ;
  char *arg2 = (char *) 0 ;
  VisPath_cl *result = 0 ;
  
  SWIG_check_num_args("GetPath",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetPath",1,"VisGame_cl *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("GetPath",2,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisGame_cl,0))){
    SWIG_fail_ptr("VisGame_cl_GetPath",1,SWIGTYPE_p_VisGame_cl);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  result = (VisPath_cl *)VisGame_cl_GetPath(arg1,(char const *)arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_VisPath_cl,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisGame_cl_GetEffect(lua_State* L) {
  int SWIG_arg = 0;
  VisGame_cl *arg1 = (VisGame_cl *) 0 ;
  char *arg2 = (char *) 0 ;
  VisParticleEffect_cl *result = 0 ;
  
  SWIG_check_num_args("GetEffect",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetEffect",1,"VisGame_cl *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("GetEffect",2,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisGame_cl,0))){
    SWIG_fail_ptr("VisGame_cl_GetEffect",1,SWIGTYPE_p_VisGame_cl);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  result = (VisParticleEffect_cl *)VisGame_cl_GetEffect(arg1,(char const *)arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_VisParticleEffect_cl,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisGame_cl_GetStaticMeshInstance(lua_State* L) {
  int SWIG_arg = 0;
  VisGame_cl *arg1 = (VisGame_cl *) 0 ;
  char *arg2 = (char *) 0 ;
  VisStaticMeshInstance_cl *result = 0 ;
  
  SWIG_check_num_args("GetStaticMeshInstance",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetStaticMeshInstance",1,"VisGame_cl *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("GetStaticMeshInstance",2,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisGame_cl,0))){
    SWIG_fail_ptr("VisGame_cl_GetStaticMeshInstance",1,SWIGTYPE_p_VisGame_cl);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  result = (VisStaticMeshInstance_cl *)VisGame_cl_GetStaticMeshInstance(arg1,(char const *)arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_VisStaticMeshInstance_cl,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisGame_cl_GetDynamicMesh(lua_State* L) {
  int SWIG_arg = 0;
  VisGame_cl *arg1 = (VisGame_cl *) 0 ;
  char *arg2 = (char *) 0 ;
  VDynamicMesh *result = 0 ;
  
  SWIG_check_num_args("GetDynamicMesh",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetDynamicMesh",1,"VisGame_cl *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("GetDynamicMesh",2,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisGame_cl,0))){
    SWIG_fail_ptr("VisGame_cl_GetDynamicMesh",1,SWIGTYPE_p_VisGame_cl);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  result = (VDynamicMesh *)VisGame_cl_GetDynamicMesh(arg1,(char const *)arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_VDynamicMesh,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisGame_cl_GetCamera__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  VisGame_cl *arg1 = (VisGame_cl *) 0 ;
  char *arg2 = (char *) 0 ;
  VisContextCamera_cl *result = 0 ;
  
  SWIG_check_num_args("GetCamera",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetCamera",1,"VisGame_cl *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("GetCamera",2,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisGame_cl,0))){
    SWIG_fail_ptr("VisGame_cl_GetCamera",1,SWIGTYPE_p_VisGame_cl);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  result = (VisContextCamera_cl *)VisGame_cl_GetCamera__SWIG_0(arg1,(char const *)arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_VisContextCamera_cl,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisGame_cl_GetCamera__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  VisGame_cl *arg1 = (VisGame_cl *) 0 ;
  VisContextCamera_cl *result = 0 ;
  
  SWIG_check_num_args("GetCamera",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetCamera",1,"VisGame_cl *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisGame_cl,0))){
    SWIG_fail_ptr("VisGame_cl_GetCamera",1,SWIGTYPE_p_VisGame_cl);
  }
  
  result = (VisContextCamera_cl *)VisGame_cl_GetCamera__SWIG_0(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_VisContextCamera_cl,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisGame_cl_GetCamera(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VisGame_cl, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_VisGame_cl_GetCamera__SWIG_1(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VisGame_cl, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = SWIG_lua_isnilstring(L,argv[1]);
      }
      if (_v) {
        return _wrap_VisGame_cl_GetCamera__SWIG_0(L);
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'VisGame_cl_GetCamera'\n"
    "  Possible C/C++ prototypes are:\n"
    "    GetCamera(VisGame_cl *,char const *)\n"
    "    GetCamera(VisGame_cl *)\n");
  lua_error(L);return 0;
}


static int _wrap_VisGame_cl_GetScreenMask(lua_State* L) {
  int SWIG_arg = 0;
  VisGame_cl *arg1 = (VisGame_cl *) 0 ;
  char *arg2 = (char *) 0 ;
  VisScreenMask_cl *result = 0 ;
  
  SWIG_check_num_args("GetScreenMask",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetScreenMask",1,"VisGame_cl *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("GetScreenMask",2,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisGame_cl,0))){
    SWIG_fail_ptr("VisGame_cl_GetScreenMask",1,SWIGTYPE_p_VisGame_cl);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  result = (VisScreenMask_cl *)VisGame_cl_GetScreenMask(arg1,(char const *)arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_VisScreenMask_cl,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisGame_cl_GetCubeMap(lua_State* L) {
  int SWIG_arg = 0;
  VisGame_cl *arg1 = (VisGame_cl *) 0 ;
  char *arg2 = (char *) 0 ;
  CubeMapHandle_cl *result = 0 ;
  
  SWIG_check_num_args("GetCubeMap",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetCubeMap",1,"VisGame_cl *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("GetCubeMap",2,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisGame_cl,0))){
    SWIG_fail_ptr("VisGame_cl_GetCubeMap",1,SWIGTYPE_p_VisGame_cl);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  result = (CubeMapHandle_cl *)VisGame_cl_GetCubeMap(arg1,(char const *)arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_CubeMapHandle_cl,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisGame_cl_DeleteAllUnrefScreenMasks(lua_State* L) {
  int SWIG_arg = 0;
  VisGame_cl *arg1 = (VisGame_cl *) 0 ;
  
  SWIG_check_num_args("DeleteAllUnrefScreenMasks",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("DeleteAllUnrefScreenMasks",1,"VisGame_cl *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisGame_cl,0))){
    SWIG_fail_ptr("VisGame_cl_DeleteAllUnrefScreenMasks",1,SWIGTYPE_p_VisGame_cl);
  }
  
  VisGame_cl_DeleteAllUnrefScreenMasks(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisGame_cl_DeleteAllUnrefLights(lua_State* L) {
  int SWIG_arg = 0;
  VisGame_cl *arg1 = (VisGame_cl *) 0 ;
  
  SWIG_check_num_args("DeleteAllUnrefLights",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("DeleteAllUnrefLights",1,"VisGame_cl *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisGame_cl,0))){
    SWIG_fail_ptr("VisGame_cl_DeleteAllUnrefLights",1,SWIGTYPE_p_VisGame_cl);
  }
  
  VisGame_cl_DeleteAllUnrefLights(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisGame_cl_DeleteAllUnrefPaths(lua_State* L) {
  int SWIG_arg = 0;
  VisGame_cl *arg1 = (VisGame_cl *) 0 ;
  
  SWIG_check_num_args("DeleteAllUnrefPaths",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("DeleteAllUnrefPaths",1,"VisGame_cl *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisGame_cl,0))){
    SWIG_fail_ptr("VisGame_cl_DeleteAllUnrefPaths",1,SWIGTYPE_p_VisGame_cl);
  }
  
  VisGame_cl_DeleteAllUnrefPaths(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisGame_cl_DeleteAllUnrefStaticMeshInstances(lua_State* L) {
  int SWIG_arg = 0;
  VisGame_cl *arg1 = (VisGame_cl *) 0 ;
  
  SWIG_check_num_args("DeleteAllUnrefStaticMeshInstances",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("DeleteAllUnrefStaticMeshInstances",1,"VisGame_cl *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisGame_cl,0))){
    SWIG_fail_ptr("VisGame_cl_DeleteAllUnrefStaticMeshInstances",1,SWIGTYPE_p_VisGame_cl);
  }
  
  VisGame_cl_DeleteAllUnrefStaticMeshInstances(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisGame_cl_DeleteAllUnrefCameras(lua_State* L) {
  int SWIG_arg = 0;
  VisGame_cl *arg1 = (VisGame_cl *) 0 ;
  
  SWIG_check_num_args("DeleteAllUnrefCameras",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("DeleteAllUnrefCameras",1,"VisGame_cl *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisGame_cl,0))){
    SWIG_fail_ptr("VisGame_cl_DeleteAllUnrefCameras",1,SWIGTYPE_p_VisGame_cl);
  }
  
  VisGame_cl_DeleteAllUnrefCameras(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VisGame_cl_ExecuteAction(lua_State* L) {
  int SWIG_arg = 0;
  VisGame_cl *arg1 = (VisGame_cl *) 0 ;
  char *arg2 = (char *) 0 ;
  bool result;
  
  SWIG_check_num_args("ExecuteAction",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ExecuteAction",1,"VisGame_cl *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("ExecuteAction",2,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VisGame_cl,0))){
    SWIG_fail_ptr("VisGame_cl_ExecuteAction",1,SWIGTYPE_p_VisGame_cl);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  result = (bool)VisGame_cl_ExecuteAction(arg1,(char const *)arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static swig_lua_method swig_VisGame_cl_methods[] = {
    { "WaitSeconds",VisGame_cl_WaitSeconds},
    { "InstantiatePrefab",VisGame_cl_InstantiatePrefab},
    { "GetObject",VisGame_cl_GetObject},
    { "GetEntity",VisGame_cl_GetEntity},
    { "CreateEntity",VisGame_cl_CreateEntity},
    { "CreateComponent",VisGame_cl_CreateComponent},
    {"CreateLight", _wrap_VisGame_cl_CreateLight}, 
    {"CreatePath", _wrap_VisGame_cl_CreatePath}, 
    {"CreatePathNode", _wrap_VisGame_cl_CreatePathNode}, 
    {"CreateEffect", _wrap_VisGame_cl_CreateEffect}, 
    {"CreateStaticMeshInstance", _wrap_VisGame_cl_CreateStaticMeshInstance}, 
    {"CreateDynamicMesh", _wrap_VisGame_cl_CreateDynamicMesh}, 
    {"MergeMeshes", _wrap_VisGame_cl_MergeMeshes}, 
    {"MergeMeshesByString", _wrap_VisGame_cl_MergeMeshesByString}, 
    {"CreateTexture", _wrap_VisGame_cl_CreateTexture}, 
    {"CreateCamera", _wrap_VisGame_cl_CreateCamera}, 
    {"CreateScreenMask", _wrap_VisGame_cl_CreateScreenMask}, 
    {"GetLight", _wrap_VisGame_cl_GetLight}, 
    {"GetPath", _wrap_VisGame_cl_GetPath}, 
    {"GetEffect", _wrap_VisGame_cl_GetEffect}, 
    {"GetStaticMeshInstance", _wrap_VisGame_cl_GetStaticMeshInstance}, 
    {"GetDynamicMesh", _wrap_VisGame_cl_GetDynamicMesh}, 
    {"GetCamera", _wrap_VisGame_cl_GetCamera}, 
    {"GetScreenMask", _wrap_VisGame_cl_GetScreenMask}, 
    {"GetCubeMap", _wrap_VisGame_cl_GetCubeMap}, 
    {"DeleteAllUnrefScreenMasks", _wrap_VisGame_cl_DeleteAllUnrefScreenMasks}, 
    {"DeleteAllUnrefLights", _wrap_VisGame_cl_DeleteAllUnrefLights}, 
    {"DeleteAllUnrefPaths", _wrap_VisGame_cl_DeleteAllUnrefPaths}, 
    {"DeleteAllUnrefStaticMeshInstances", _wrap_VisGame_cl_DeleteAllUnrefStaticMeshInstances}, 
    {"DeleteAllUnrefCameras", _wrap_VisGame_cl_DeleteAllUnrefCameras}, 
    {"ExecuteAction", _wrap_VisGame_cl_ExecuteAction}, 
    {0,0}
};
static swig_lua_attribute swig_VisGame_cl_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_VisGame_cl_bases[] = {0};
static const char *swig_VisGame_cl_base_names[] = {0};
static swig_lua_class _wrap_class_VisGame_cl = { "VisGame_cl", &SWIGTYPE_p_VisGame_cl,0,0, swig_VisGame_cl_methods, swig_VisGame_cl_attributes, swig_VisGame_cl_bases, swig_VisGame_cl_base_names };

static int _wrap_IVTimer_GetTime(lua_State* L) {
  int SWIG_arg = 0;
  IVTimer *arg1 = (IVTimer *) 0 ;
  float result;
  
  SWIG_check_num_args("GetTime",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetTime",1,"IVTimer const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_IVTimer,0))){
    SWIG_fail_ptr("IVTimer_GetTime",1,SWIGTYPE_p_IVTimer);
  }
  
  result = (float)((IVTimer const *)arg1)->GetTime();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_IVTimer_SetForcedFrameRate__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  IVTimer *arg1 = (IVTimer *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("ForceFrameRate",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ForceFrameRate",1,"IVTimer *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ForceFrameRate",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_IVTimer,0))){
    SWIG_fail_ptr("IVTimer_SetForcedFrameRate",1,SWIGTYPE_p_IVTimer);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->ForceFrameRate(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_IVTimer_SetForcedFrameRate__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  IVTimer *arg1 = (IVTimer *) 0 ;
  
  SWIG_check_num_args("ForceFrameRate",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ForceFrameRate",1,"IVTimer *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_IVTimer,0))){
    SWIG_fail_ptr("IVTimer_SetForcedFrameRate",1,SWIGTYPE_p_IVTimer);
  }
  
  (arg1)->ForceFrameRate();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_IVTimer_SetForcedFrameRate(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_IVTimer, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_IVTimer_SetForcedFrameRate__SWIG_1(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_IVTimer, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_IVTimer_SetForcedFrameRate__SWIG_0(L);
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'IVTimer_SetForcedFrameRate'\n"
    "  Possible C/C++ prototypes are:\n"
    "    ForceFrameRate(IVTimer *,int)\n"
    "    ForceFrameRate(IVTimer *)\n");
  lua_error(L);return 0;
}


static int _wrap_IVTimer_GetForcedFrameRate(lua_State* L) {
  int SWIG_arg = 0;
  IVTimer *arg1 = (IVTimer *) 0 ;
  int result;
  
  SWIG_check_num_args("GetForcedFrameRate",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetForcedFrameRate",1,"IVTimer const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_IVTimer,0))){
    SWIG_fail_ptr("IVTimer_GetForcedFrameRate",1,SWIGTYPE_p_IVTimer);
  }
  
  result = (int)((IVTimer const *)arg1)->GetForcedFrameRate();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_IVTimer_SetMaxTimeDifference(lua_State* L) {
  int SWIG_arg = 0;
  IVTimer *arg1 = (IVTimer *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("SetMaxTimeDifference",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetMaxTimeDifference",1,"IVTimer *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SetMaxTimeDifference",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_IVTimer,0))){
    SWIG_fail_ptr("IVTimer_SetMaxTimeDifference",1,SWIGTYPE_p_IVTimer);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->SetMaxTimeDifference(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_IVTimer_GetMaxTimeDifference(lua_State* L) {
  int SWIG_arg = 0;
  IVTimer *arg1 = (IVTimer *) 0 ;
  float result;
  
  SWIG_check_num_args("GetMaxTimeDifference",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetMaxTimeDifference",1,"IVTimer const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_IVTimer,0))){
    SWIG_fail_ptr("IVTimer_GetMaxTimeDifference",1,SWIGTYPE_p_IVTimer);
  }
  
  result = (float)((IVTimer const *)arg1)->GetMaxTimeDifference();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_IVTimer_GetTimeDiff(lua_State* L) {
  int SWIG_arg = 0;
  IVTimer *arg1 = (IVTimer *) 0 ;
  float result;
  
  SWIG_check_num_args("GetTimeDiff",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetTimeDiff",1,"IVTimer *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_IVTimer,0))){
    SWIG_fail_ptr("IVTimer_GetTimeDiff",1,SWIGTYPE_p_IVTimer);
  }
  
  result = (float)IVTimer_GetTimeDiff(arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_IVTimer_SetScriptThinkInterval__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  IVTimer *arg1 = (IVTimer *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("SetScriptThinkInterval",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetScriptThinkInterval",1,"IVTimer *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SetScriptThinkInterval",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_IVTimer,0))){
    SWIG_fail_ptr("IVTimer_SetScriptThinkInterval",1,SWIGTYPE_p_IVTimer);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  IVTimer_SetScriptThinkInterval__SWIG_0(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_IVTimer_SetScriptThinkInterval__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  IVTimer *arg1 = (IVTimer *) 0 ;
  
  SWIG_check_num_args("SetScriptThinkInterval",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetScriptThinkInterval",1,"IVTimer *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_IVTimer,0))){
    SWIG_fail_ptr("IVTimer_SetScriptThinkInterval",1,SWIGTYPE_p_IVTimer);
  }
  
  IVTimer_SetScriptThinkInterval__SWIG_0(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_IVTimer_SetScriptThinkInterval(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_IVTimer, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_IVTimer_SetScriptThinkInterval__SWIG_1(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_IVTimer, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_IVTimer_SetScriptThinkInterval__SWIG_0(L);
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'IVTimer_SetScriptThinkInterval'\n"
    "  Possible C/C++ prototypes are:\n"
    "    SetScriptThinkInterval(IVTimer *,float)\n"
    "    SetScriptThinkInterval(IVTimer *)\n");
  lua_error(L);return 0;
}


static int _wrap_IVTimer_GetScriptThinkInterval(lua_State* L) {
  int SWIG_arg = 0;
  IVTimer *arg1 = (IVTimer *) 0 ;
  float result;
  
  SWIG_check_num_args("GetScriptThinkInterval",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetScriptThinkInterval",1,"IVTimer *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_IVTimer,0))){
    SWIG_fail_ptr("IVTimer_GetScriptThinkInterval",1,SWIGTYPE_p_IVTimer);
  }
  
  result = (float)IVTimer_GetScriptThinkInterval(arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_IVTimer_GetThinkInterval(lua_State* L) {
  int SWIG_arg = 0;
  IVTimer *arg1 = (IVTimer *) 0 ;
  float result;
  
  SWIG_check_num_args("GetThinkInterval",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetThinkInterval",1,"IVTimer *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_IVTimer,0))){
    SWIG_fail_ptr("IVTimer_GetThinkInterval",1,SWIGTYPE_p_IVTimer);
  }
  
  result = (float)IVTimer_GetThinkInterval(arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_IVTimer_EnableSlowMotion(lua_State* L) {
  int SWIG_arg = 0;
  IVTimer *arg1 = (IVTimer *) 0 ;
  bool arg2 ;
  
  SWIG_check_num_args("EnableSlowMotion",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("EnableSlowMotion",1,"IVTimer *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("EnableSlowMotion",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_IVTimer,0))){
    SWIG_fail_ptr("IVTimer_EnableSlowMotion",1,SWIGTYPE_p_IVTimer);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  IVTimer_EnableSlowMotion(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_IVTimer_IsSlowMotionEnabled(lua_State* L) {
  int SWIG_arg = 0;
  IVTimer *arg1 = (IVTimer *) 0 ;
  bool result;
  
  SWIG_check_num_args("IsSlowMotionEnabled",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("IsSlowMotionEnabled",1,"IVTimer *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_IVTimer,0))){
    SWIG_fail_ptr("IVTimer_IsSlowMotionEnabled",1,SWIGTYPE_p_IVTimer);
  }
  
  result = (bool)IVTimer_IsSlowMotionEnabled(arg1);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_IVTimer_SetFrozen(lua_State* L) {
  int SWIG_arg = 0;
  IVTimer *arg1 = (IVTimer *) 0 ;
  bool arg2 ;
  
  SWIG_check_num_args("SetFrozen",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetFrozen",1,"IVTimer *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("SetFrozen",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_IVTimer,0))){
    SWIG_fail_ptr("IVTimer_SetFrozen",1,SWIGTYPE_p_IVTimer);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  IVTimer_SetFrozen(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_IVTimer_IsFrozen(lua_State* L) {
  int SWIG_arg = 0;
  IVTimer *arg1 = (IVTimer *) 0 ;
  bool result;
  
  SWIG_check_num_args("IsFrozen",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("IsFrozen",1,"IVTimer *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_IVTimer,0))){
    SWIG_fail_ptr("IVTimer_IsFrozen",1,SWIGTYPE_p_IVTimer);
  }
  
  result = (bool)IVTimer_IsFrozen(arg1);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_IVTimer_SetSlowMotionTimeScale(lua_State* L) {
  int SWIG_arg = 0;
  IVTimer *arg1 = (IVTimer *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("SetSlowMotionTimeScale",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetSlowMotionTimeScale",1,"IVTimer *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SetSlowMotionTimeScale",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_IVTimer,0))){
    SWIG_fail_ptr("IVTimer_SetSlowMotionTimeScale",1,SWIGTYPE_p_IVTimer);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->SetSlowMotionTimeScale(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_IVTimer_GetSlowMotionTimeScale(lua_State* L) {
  int SWIG_arg = 0;
  IVTimer *arg1 = (IVTimer *) 0 ;
  float result;
  
  SWIG_check_num_args("GetSlowMotionTimeScale",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetSlowMotionTimeScale",1,"IVTimer const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_IVTimer,0))){
    SWIG_fail_ptr("IVTimer_GetSlowMotionTimeScale",1,SWIGTYPE_p_IVTimer);
  }
  
  result = (float)((IVTimer const *)arg1)->GetSlowMotionTimeScale();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static swig_lua_method swig_IVTimer_methods[] = {
    {"GetTime", _wrap_IVTimer_GetTime}, 
    {"SetForcedFrameRate", _wrap_IVTimer_SetForcedFrameRate}, 
    {"GetForcedFrameRate", _wrap_IVTimer_GetForcedFrameRate}, 
    {"SetMaxTimeDifference", _wrap_IVTimer_SetMaxTimeDifference}, 
    {"GetMaxTimeDifference", _wrap_IVTimer_GetMaxTimeDifference}, 
    {"GetTimeDiff", _wrap_IVTimer_GetTimeDiff}, 
    {"SetScriptThinkInterval", _wrap_IVTimer_SetScriptThinkInterval}, 
    {"GetScriptThinkInterval", _wrap_IVTimer_GetScriptThinkInterval}, 
    {"GetThinkInterval", _wrap_IVTimer_GetThinkInterval}, 
    {"EnableSlowMotion", _wrap_IVTimer_EnableSlowMotion}, 
    {"IsSlowMotionEnabled", _wrap_IVTimer_IsSlowMotionEnabled}, 
    {"SetFrozen", _wrap_IVTimer_SetFrozen}, 
    {"IsFrozen", _wrap_IVTimer_IsFrozen}, 
    {"SetSlowMotionTimeScale", _wrap_IVTimer_SetSlowMotionTimeScale}, 
    {"GetSlowMotionTimeScale", _wrap_IVTimer_GetSlowMotionTimeScale}, 
    {0,0}
};
static swig_lua_attribute swig_IVTimer_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_IVTimer_bases[] = {0};
static const char *swig_IVTimer_base_names[] = {0};
static swig_lua_class _wrap_class_IVTimer = { "IVTimer", &SWIGTYPE_p_IVTimer,0,0, swig_IVTimer_methods, swig_IVTimer_attributes, swig_IVTimer_bases, swig_IVTimer_base_names };

static int _wrap_IVConsoleManager_PrintLine(lua_State* L) {
  int SWIG_arg = 0;
  IVConsoleManager *arg1 = (IVConsoleManager *) 0 ;
  char *arg2 = (char *) 0 ;
  
  SWIG_check_num_args("OutputTextLine",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("OutputTextLine",1,"IVConsoleManager *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("OutputTextLine",2,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_IVConsoleManager,0))){
    SWIG_fail_ptr("IVConsoleManager_PrintLine",1,SWIGTYPE_p_IVConsoleManager);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  (arg1)->OutputTextLine((char const *)arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_IVConsoleManager_SetAllowed(lua_State* L) {
  int SWIG_arg = 0;
  IVConsoleManager *arg1 = (IVConsoleManager *) 0 ;
  bool arg2 ;
  
  SWIG_check_num_args("SetAllowed",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetAllowed",1,"IVConsoleManager *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("SetAllowed",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_IVConsoleManager,0))){
    SWIG_fail_ptr("IVConsoleManager_SetAllowed",1,SWIGTYPE_p_IVConsoleManager);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  (arg1)->SetAllowed(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_IVConsoleManager_IsAllowed(lua_State* L) {
  int SWIG_arg = 0;
  IVConsoleManager *arg1 = (IVConsoleManager *) 0 ;
  bool result;
  
  SWIG_check_num_args("IsAllowed",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("IsAllowed",1,"IVConsoleManager const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_IVConsoleManager,0))){
    SWIG_fail_ptr("IVConsoleManager_IsAllowed",1,SWIGTYPE_p_IVConsoleManager);
  }
  
  result = (bool)((IVConsoleManager const *)arg1)->IsAllowed();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_IVConsoleManager_SetVisible(lua_State* L) {
  int SWIG_arg = 0;
  IVConsoleManager *arg1 = (IVConsoleManager *) 0 ;
  bool arg2 ;
  
  SWIG_check_num_args("Show",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Show",1,"IVConsoleManager *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("Show",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_IVConsoleManager,0))){
    SWIG_fail_ptr("IVConsoleManager_SetVisible",1,SWIGTYPE_p_IVConsoleManager);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  (arg1)->Show(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_IVConsoleManager_IsVisible(lua_State* L) {
  int SWIG_arg = 0;
  IVConsoleManager *arg1 = (IVConsoleManager *) 0 ;
  bool result;
  
  SWIG_check_num_args("IsVisible",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("IsVisible",1,"IVConsoleManager const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_IVConsoleManager,0))){
    SWIG_fail_ptr("IVConsoleManager_IsVisible",1,SWIGTYPE_p_IVConsoleManager);
  }
  
  result = (bool)((IVConsoleManager const *)arg1)->IsVisible();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static swig_lua_method swig_IVConsoleManager_methods[] = {
    {"PrintLine", _wrap_IVConsoleManager_PrintLine}, 
    {"SetAllowed", _wrap_IVConsoleManager_SetAllowed}, 
    {"IsAllowed", _wrap_IVConsoleManager_IsAllowed}, 
    {"SetVisible", _wrap_IVConsoleManager_SetVisible}, 
    {"IsVisible", _wrap_IVConsoleManager_IsVisible}, 
    {0,0}
};
static swig_lua_attribute swig_IVConsoleManager_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_IVConsoleManager_bases[] = {0};
static const char *swig_IVConsoleManager_base_names[] = {0};
static swig_lua_class _wrap_class_IVConsoleManager = { "IVConsoleManager", &SWIGTYPE_p_IVConsoleManager,0,0, swig_IVConsoleManager_methods, swig_IVConsoleManager_attributes, swig_IVConsoleManager_bases, swig_IVConsoleManager_base_names };

static int _wrap_VScriptDraw_wrapper_Line__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  VScriptDraw_wrapper *arg1 = (VScriptDraw_wrapper *) 0 ;
  hkvVec3 *arg2 = (hkvVec3 *) 0 ;
  hkvVec3 *arg3 = (hkvVec3 *) 0 ;
  VColorRef arg4 ;
  VColorRef *argp4 ;
  
  SWIG_check_num_args("Line",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Line",1,"VScriptDraw_wrapper *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Line",2,"hkvVec3 const *");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("Line",3,"hkvVec3 const *");
  if(!lua_isuserdata(L,4)) SWIG_fail_arg("Line",4,"VColorRef");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VScriptDraw_wrapper,0))){
    SWIG_fail_ptr("VScriptDraw_wrapper_Line",1,SWIGTYPE_p_VScriptDraw_wrapper);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("VScriptDraw_wrapper_Line",2,SWIGTYPE_p_hkvVec3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("VScriptDraw_wrapper_Line",3,SWIGTYPE_p_hkvVec3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&argp4,SWIGTYPE_p_VColorRef,0))){
    SWIG_fail_ptr("VScriptDraw_wrapper_Line",4,SWIGTYPE_p_VColorRef);
  }
  arg4 = *argp4;
  
  (arg1)->Line((hkvVec3 const *)arg2,(hkvVec3 const *)arg3,arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VScriptDraw_wrapper_Line__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  VScriptDraw_wrapper *arg1 = (VScriptDraw_wrapper *) 0 ;
  hkvVec3 *arg2 = (hkvVec3 *) 0 ;
  hkvVec3 *arg3 = (hkvVec3 *) 0 ;
  
  SWIG_check_num_args("Line",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Line",1,"VScriptDraw_wrapper *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Line",2,"hkvVec3 const *");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("Line",3,"hkvVec3 const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VScriptDraw_wrapper,0))){
    SWIG_fail_ptr("VScriptDraw_wrapper_Line",1,SWIGTYPE_p_VScriptDraw_wrapper);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("VScriptDraw_wrapper_Line",2,SWIGTYPE_p_hkvVec3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("VScriptDraw_wrapper_Line",3,SWIGTYPE_p_hkvVec3);
  }
  
  (arg1)->Line((hkvVec3 const *)arg2,(hkvVec3 const *)arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VScriptDraw_wrapper_Line(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VScriptDraw_wrapper, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_hkvVec3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          void *ptr;
          if (SWIG_isptrtype(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_hkvVec3, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          return _wrap_VScriptDraw_wrapper_Line__SWIG_1(L);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VScriptDraw_wrapper, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_hkvVec3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          void *ptr;
          if (SWIG_isptrtype(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_hkvVec3, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          {
            void *ptr;
            if (lua_isuserdata(L,argv[3])==0 || SWIG_ConvertPtr(L,argv[3], (void **) &ptr, SWIGTYPE_p_VColorRef, 0)) {
              _v = 0;
            } else {
              _v = 1;
            }
          }
          if (_v) {
            return _wrap_VScriptDraw_wrapper_Line__SWIG_0(L);
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'VScriptDraw_wrapper_Line'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Line(VScriptDraw_wrapper *,hkvVec3 const *,hkvVec3 const *,VColorRef)\n"
    "    Line(VScriptDraw_wrapper *,hkvVec3 const *,hkvVec3 const *)\n");
  lua_error(L);return 0;
}


static int _wrap_VScriptDraw_wrapper_Line2D__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  VScriptDraw_wrapper *arg1 = (VScriptDraw_wrapper *) 0 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  float arg5 ;
  VColorRef arg6 ;
  VColorRef *argp6 ;
  
  SWIG_check_num_args("Line2D",6,6)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Line2D",1,"VScriptDraw_wrapper *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Line2D",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Line2D",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Line2D",4,"float");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("Line2D",5,"float");
  if(!lua_isuserdata(L,6)) SWIG_fail_arg("Line2D",6,"VColorRef");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VScriptDraw_wrapper,0))){
    SWIG_fail_ptr("VScriptDraw_wrapper_Line2D",1,SWIGTYPE_p_VScriptDraw_wrapper);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4);
  arg5 = (float)lua_tonumber(L, 5);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,6,(void**)&argp6,SWIGTYPE_p_VColorRef,0))){
    SWIG_fail_ptr("VScriptDraw_wrapper_Line2D",6,SWIGTYPE_p_VColorRef);
  }
  arg6 = *argp6;
  
  (arg1)->Line2D(arg2,arg3,arg4,arg5,arg6);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VScriptDraw_wrapper_Line2D__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  VScriptDraw_wrapper *arg1 = (VScriptDraw_wrapper *) 0 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  float arg5 ;
  
  SWIG_check_num_args("Line2D",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Line2D",1,"VScriptDraw_wrapper *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Line2D",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Line2D",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Line2D",4,"float");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("Line2D",5,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VScriptDraw_wrapper,0))){
    SWIG_fail_ptr("VScriptDraw_wrapper_Line2D",1,SWIGTYPE_p_VScriptDraw_wrapper);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4);
  arg5 = (float)lua_tonumber(L, 5);
  (arg1)->Line2D(arg2,arg3,arg4,arg5);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VScriptDraw_wrapper_Line2D(lua_State* L) {
  int argc;
  int argv[7]={
    1,2,3,4,5,6,7
  };
  
  argc = lua_gettop(L);
  if (argc == 5) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VScriptDraw_wrapper, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isnumber(L,argv[4]);
            }
            if (_v) {
              return _wrap_VScriptDraw_wrapper_Line2D__SWIG_1(L);
            }
          }
        }
      }
    }
  }
  if (argc == 6) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VScriptDraw_wrapper, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isnumber(L,argv[4]);
            }
            if (_v) {
              {
                void *ptr;
                if (lua_isuserdata(L,argv[5])==0 || SWIG_ConvertPtr(L,argv[5], (void **) &ptr, SWIGTYPE_p_VColorRef, 0)) {
                  _v = 0;
                } else {
                  _v = 1;
                }
              }
              if (_v) {
                return _wrap_VScriptDraw_wrapper_Line2D__SWIG_0(L);
              }
            }
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'VScriptDraw_wrapper_Line2D'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Line2D(VScriptDraw_wrapper *,float,float,float,float,VColorRef)\n"
    "    Line2D(VScriptDraw_wrapper *,float,float,float,float)\n");
  lua_error(L);return 0;
}


static int _wrap_VScriptDraw_wrapper_Box__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  VScriptDraw_wrapper *arg1 = (VScriptDraw_wrapper *) 0 ;
  hkvVec3 *arg2 = (hkvVec3 *) 0 ;
  float arg3 ;
  VColorRef arg4 ;
  VColorRef *argp4 ;
  
  SWIG_check_num_args("Box",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Box",1,"VScriptDraw_wrapper *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Box",2,"hkvVec3 const *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Box",3,"float");
  if(!lua_isuserdata(L,4)) SWIG_fail_arg("Box",4,"VColorRef");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VScriptDraw_wrapper,0))){
    SWIG_fail_ptr("VScriptDraw_wrapper_Box",1,SWIGTYPE_p_VScriptDraw_wrapper);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("VScriptDraw_wrapper_Box",2,SWIGTYPE_p_hkvVec3);
  }
  
  arg3 = (float)lua_tonumber(L, 3);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&argp4,SWIGTYPE_p_VColorRef,0))){
    SWIG_fail_ptr("VScriptDraw_wrapper_Box",4,SWIGTYPE_p_VColorRef);
  }
  arg4 = *argp4;
  
  (arg1)->Box((hkvVec3 const *)arg2,arg3,arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VScriptDraw_wrapper_Box__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  VScriptDraw_wrapper *arg1 = (VScriptDraw_wrapper *) 0 ;
  hkvVec3 *arg2 = (hkvVec3 *) 0 ;
  float arg3 ;
  
  SWIG_check_num_args("Box",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Box",1,"VScriptDraw_wrapper *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Box",2,"hkvVec3 const *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Box",3,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VScriptDraw_wrapper,0))){
    SWIG_fail_ptr("VScriptDraw_wrapper_Box",1,SWIGTYPE_p_VScriptDraw_wrapper);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("VScriptDraw_wrapper_Box",2,SWIGTYPE_p_hkvVec3);
  }
  
  arg3 = (float)lua_tonumber(L, 3);
  (arg1)->Box((hkvVec3 const *)arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VScriptDraw_wrapper_Box__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  VScriptDraw_wrapper *arg1 = (VScriptDraw_wrapper *) 0 ;
  hkvVec3 *arg2 = (hkvVec3 *) 0 ;
  hkvVec3 *arg3 = (hkvVec3 *) 0 ;
  VColorRef arg4 ;
  VColorRef *argp4 ;
  
  SWIG_check_num_args("Box",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Box",1,"VScriptDraw_wrapper *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Box",2,"hkvVec3 const *");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("Box",3,"hkvVec3 const *");
  if(!lua_isuserdata(L,4)) SWIG_fail_arg("Box",4,"VColorRef");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VScriptDraw_wrapper,0))){
    SWIG_fail_ptr("VScriptDraw_wrapper_Box",1,SWIGTYPE_p_VScriptDraw_wrapper);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("VScriptDraw_wrapper_Box",2,SWIGTYPE_p_hkvVec3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("VScriptDraw_wrapper_Box",3,SWIGTYPE_p_hkvVec3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&argp4,SWIGTYPE_p_VColorRef,0))){
    SWIG_fail_ptr("VScriptDraw_wrapper_Box",4,SWIGTYPE_p_VColorRef);
  }
  arg4 = *argp4;
  
  (arg1)->Box((hkvVec3 const *)arg2,(hkvVec3 const *)arg3,arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VScriptDraw_wrapper_Box__SWIG_3(lua_State* L) {
  int SWIG_arg = 0;
  VScriptDraw_wrapper *arg1 = (VScriptDraw_wrapper *) 0 ;
  hkvVec3 *arg2 = (hkvVec3 *) 0 ;
  hkvVec3 *arg3 = (hkvVec3 *) 0 ;
  
  SWIG_check_num_args("Box",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Box",1,"VScriptDraw_wrapper *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Box",2,"hkvVec3 const *");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("Box",3,"hkvVec3 const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VScriptDraw_wrapper,0))){
    SWIG_fail_ptr("VScriptDraw_wrapper_Box",1,SWIGTYPE_p_VScriptDraw_wrapper);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("VScriptDraw_wrapper_Box",2,SWIGTYPE_p_hkvVec3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("VScriptDraw_wrapper_Box",3,SWIGTYPE_p_hkvVec3);
  }
  
  (arg1)->Box((hkvVec3 const *)arg2,(hkvVec3 const *)arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VScriptDraw_wrapper_Box(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VScriptDraw_wrapper, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_hkvVec3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          void *ptr;
          if (SWIG_isptrtype(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_hkvVec3, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          return _wrap_VScriptDraw_wrapper_Box__SWIG_3(L);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VScriptDraw_wrapper, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_hkvVec3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          return _wrap_VScriptDraw_wrapper_Box__SWIG_1(L);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VScriptDraw_wrapper, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_hkvVec3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          void *ptr;
          if (SWIG_isptrtype(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_hkvVec3, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          {
            void *ptr;
            if (lua_isuserdata(L,argv[3])==0 || SWIG_ConvertPtr(L,argv[3], (void **) &ptr, SWIGTYPE_p_VColorRef, 0)) {
              _v = 0;
            } else {
              _v = 1;
            }
          }
          if (_v) {
            return _wrap_VScriptDraw_wrapper_Box__SWIG_2(L);
          }
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VScriptDraw_wrapper, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_hkvVec3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            void *ptr;
            if (lua_isuserdata(L,argv[3])==0 || SWIG_ConvertPtr(L,argv[3], (void **) &ptr, SWIGTYPE_p_VColorRef, 0)) {
              _v = 0;
            } else {
              _v = 1;
            }
          }
          if (_v) {
            return _wrap_VScriptDraw_wrapper_Box__SWIG_0(L);
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'VScriptDraw_wrapper_Box'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Box(VScriptDraw_wrapper *,hkvVec3 const *,float,VColorRef)\n"
    "    Box(VScriptDraw_wrapper *,hkvVec3 const *,float)\n"
    "    Box(VScriptDraw_wrapper *,hkvVec3 const *,hkvVec3 const *,VColorRef)\n"
    "    Box(VScriptDraw_wrapper *,hkvVec3 const *,hkvVec3 const *)\n");
  lua_error(L);return 0;
}


static int _wrap_VScriptDraw_wrapper_BoundingBox__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  VScriptDraw_wrapper *arg1 = (VScriptDraw_wrapper *) 0 ;
  hkvAlignedBBox *arg2 = (hkvAlignedBBox *) 0 ;
  VColorRef arg3 ;
  VColorRef *argp3 ;
  
  SWIG_check_num_args("BoundingBox",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("BoundingBox",1,"VScriptDraw_wrapper *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("BoundingBox",2,"hkvAlignedBBox const *");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("BoundingBox",3,"VColorRef");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VScriptDraw_wrapper,0))){
    SWIG_fail_ptr("VScriptDraw_wrapper_BoundingBox",1,SWIGTYPE_p_VScriptDraw_wrapper);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_hkvAlignedBBox,0))){
    SWIG_fail_ptr("VScriptDraw_wrapper_BoundingBox",2,SWIGTYPE_p_hkvAlignedBBox);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&argp3,SWIGTYPE_p_VColorRef,0))){
    SWIG_fail_ptr("VScriptDraw_wrapper_BoundingBox",3,SWIGTYPE_p_VColorRef);
  }
  arg3 = *argp3;
  
  (arg1)->BoundingBox((hkvAlignedBBox const *)arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VScriptDraw_wrapper_BoundingBox__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  VScriptDraw_wrapper *arg1 = (VScriptDraw_wrapper *) 0 ;
  hkvAlignedBBox *arg2 = (hkvAlignedBBox *) 0 ;
  
  SWIG_check_num_args("BoundingBox",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("BoundingBox",1,"VScriptDraw_wrapper *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("BoundingBox",2,"hkvAlignedBBox const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VScriptDraw_wrapper,0))){
    SWIG_fail_ptr("VScriptDraw_wrapper_BoundingBox",1,SWIGTYPE_p_VScriptDraw_wrapper);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_hkvAlignedBBox,0))){
    SWIG_fail_ptr("VScriptDraw_wrapper_BoundingBox",2,SWIGTYPE_p_hkvAlignedBBox);
  }
  
  (arg1)->BoundingBox((hkvAlignedBBox const *)arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VScriptDraw_wrapper_BoundingBox__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  VScriptDraw_wrapper *arg1 = (VScriptDraw_wrapper *) 0 ;
  VisBaseEntity_cl *arg2 = (VisBaseEntity_cl *) 0 ;
  VColorRef arg3 ;
  VColorRef *argp3 ;
  
  SWIG_check_num_args("BoundingBox",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("BoundingBox",1,"VScriptDraw_wrapper *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("BoundingBox",2,"VisBaseEntity_cl *");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("BoundingBox",3,"VColorRef");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VScriptDraw_wrapper,0))){
    SWIG_fail_ptr("VScriptDraw_wrapper_BoundingBox",1,SWIGTYPE_p_VScriptDraw_wrapper);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_VisBaseEntity_cl,0))){
    SWIG_fail_ptr("VScriptDraw_wrapper_BoundingBox",2,SWIGTYPE_p_VisBaseEntity_cl);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&argp3,SWIGTYPE_p_VColorRef,0))){
    SWIG_fail_ptr("VScriptDraw_wrapper_BoundingBox",3,SWIGTYPE_p_VColorRef);
  }
  arg3 = *argp3;
  
  (arg1)->BoundingBox(arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VScriptDraw_wrapper_BoundingBox__SWIG_3(lua_State* L) {
  int SWIG_arg = 0;
  VScriptDraw_wrapper *arg1 = (VScriptDraw_wrapper *) 0 ;
  VisBaseEntity_cl *arg2 = (VisBaseEntity_cl *) 0 ;
  
  SWIG_check_num_args("BoundingBox",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("BoundingBox",1,"VScriptDraw_wrapper *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("BoundingBox",2,"VisBaseEntity_cl *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VScriptDraw_wrapper,0))){
    SWIG_fail_ptr("VScriptDraw_wrapper_BoundingBox",1,SWIGTYPE_p_VScriptDraw_wrapper);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_VisBaseEntity_cl,0))){
    SWIG_fail_ptr("VScriptDraw_wrapper_BoundingBox",2,SWIGTYPE_p_VisBaseEntity_cl);
  }
  
  (arg1)->BoundingBox(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VScriptDraw_wrapper_BoundingBox(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VScriptDraw_wrapper, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_hkvAlignedBBox, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_VScriptDraw_wrapper_BoundingBox__SWIG_1(L);
      }
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VScriptDraw_wrapper, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_VisBaseEntity_cl, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_VScriptDraw_wrapper_BoundingBox__SWIG_3(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VScriptDraw_wrapper, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_VisBaseEntity_cl, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_VColorRef, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          return _wrap_VScriptDraw_wrapper_BoundingBox__SWIG_2(L);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VScriptDraw_wrapper, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_hkvAlignedBBox, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_VColorRef, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          return _wrap_VScriptDraw_wrapper_BoundingBox__SWIG_0(L);
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'VScriptDraw_wrapper_BoundingBox'\n"
    "  Possible C/C++ prototypes are:\n"
    "    BoundingBox(VScriptDraw_wrapper *,hkvAlignedBBox const *,VColorRef)\n"
    "    BoundingBox(VScriptDraw_wrapper *,hkvAlignedBBox const *)\n"
    "    BoundingBox(VScriptDraw_wrapper *,VisBaseEntity_cl *,VColorRef)\n"
    "    BoundingBox(VScriptDraw_wrapper *,VisBaseEntity_cl *)\n");
  lua_error(L);return 0;
}


static int _wrap_VScriptDraw_wrapper_OrientedBoundingBox__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  VScriptDraw_wrapper *arg1 = (VScriptDraw_wrapper *) 0 ;
  hkvAlignedBBox *arg2 = (hkvAlignedBBox *) 0 ;
  hkvMat3 *arg3 = (hkvMat3 *) 0 ;
  hkvVec3 *arg4 = (hkvVec3 *) 0 ;
  VColorRef arg5 ;
  VColorRef *argp5 ;
  
  SWIG_check_num_args("OrientedBoundingBox",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("OrientedBoundingBox",1,"VScriptDraw_wrapper *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("OrientedBoundingBox",2,"hkvAlignedBBox const *");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("OrientedBoundingBox",3,"hkvMat3 const *");
  if(!SWIG_isptrtype(L,4)) SWIG_fail_arg("OrientedBoundingBox",4,"hkvVec3 const *");
  if(!lua_isuserdata(L,5)) SWIG_fail_arg("OrientedBoundingBox",5,"VColorRef");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VScriptDraw_wrapper,0))){
    SWIG_fail_ptr("VScriptDraw_wrapper_OrientedBoundingBox",1,SWIGTYPE_p_VScriptDraw_wrapper);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_hkvAlignedBBox,0))){
    SWIG_fail_ptr("VScriptDraw_wrapper_OrientedBoundingBox",2,SWIGTYPE_p_hkvAlignedBBox);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_hkvMat3,0))){
    SWIG_fail_ptr("VScriptDraw_wrapper_OrientedBoundingBox",3,SWIGTYPE_p_hkvMat3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("VScriptDraw_wrapper_OrientedBoundingBox",4,SWIGTYPE_p_hkvVec3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,5,(void**)&argp5,SWIGTYPE_p_VColorRef,0))){
    SWIG_fail_ptr("VScriptDraw_wrapper_OrientedBoundingBox",5,SWIGTYPE_p_VColorRef);
  }
  arg5 = *argp5;
  
  (arg1)->OrientedBoundingBox((hkvAlignedBBox const *)arg2,(hkvMat3 const *)arg3,(hkvVec3 const *)arg4,arg5);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VScriptDraw_wrapper_OrientedBoundingBox__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  VScriptDraw_wrapper *arg1 = (VScriptDraw_wrapper *) 0 ;
  hkvAlignedBBox *arg2 = (hkvAlignedBBox *) 0 ;
  hkvMat3 *arg3 = (hkvMat3 *) 0 ;
  hkvVec3 *arg4 = (hkvVec3 *) 0 ;
  
  SWIG_check_num_args("OrientedBoundingBox",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("OrientedBoundingBox",1,"VScriptDraw_wrapper *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("OrientedBoundingBox",2,"hkvAlignedBBox const *");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("OrientedBoundingBox",3,"hkvMat3 const *");
  if(!SWIG_isptrtype(L,4)) SWIG_fail_arg("OrientedBoundingBox",4,"hkvVec3 const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VScriptDraw_wrapper,0))){
    SWIG_fail_ptr("VScriptDraw_wrapper_OrientedBoundingBox",1,SWIGTYPE_p_VScriptDraw_wrapper);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_hkvAlignedBBox,0))){
    SWIG_fail_ptr("VScriptDraw_wrapper_OrientedBoundingBox",2,SWIGTYPE_p_hkvAlignedBBox);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_hkvMat3,0))){
    SWIG_fail_ptr("VScriptDraw_wrapper_OrientedBoundingBox",3,SWIGTYPE_p_hkvMat3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("VScriptDraw_wrapper_OrientedBoundingBox",4,SWIGTYPE_p_hkvVec3);
  }
  
  (arg1)->OrientedBoundingBox((hkvAlignedBBox const *)arg2,(hkvMat3 const *)arg3,(hkvVec3 const *)arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VScriptDraw_wrapper_OrientedBoundingBox__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  VScriptDraw_wrapper *arg1 = (VScriptDraw_wrapper *) 0 ;
  VisBaseEntity_cl *arg2 = (VisBaseEntity_cl *) 0 ;
  VColorRef arg3 ;
  VColorRef *argp3 ;
  
  SWIG_check_num_args("OrientedBoundingBox",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("OrientedBoundingBox",1,"VScriptDraw_wrapper *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("OrientedBoundingBox",2,"VisBaseEntity_cl *");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("OrientedBoundingBox",3,"VColorRef");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VScriptDraw_wrapper,0))){
    SWIG_fail_ptr("VScriptDraw_wrapper_OrientedBoundingBox",1,SWIGTYPE_p_VScriptDraw_wrapper);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_VisBaseEntity_cl,0))){
    SWIG_fail_ptr("VScriptDraw_wrapper_OrientedBoundingBox",2,SWIGTYPE_p_VisBaseEntity_cl);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&argp3,SWIGTYPE_p_VColorRef,0))){
    SWIG_fail_ptr("VScriptDraw_wrapper_OrientedBoundingBox",3,SWIGTYPE_p_VColorRef);
  }
  arg3 = *argp3;
  
  (arg1)->OrientedBoundingBox(arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VScriptDraw_wrapper_OrientedBoundingBox__SWIG_3(lua_State* L) {
  int SWIG_arg = 0;
  VScriptDraw_wrapper *arg1 = (VScriptDraw_wrapper *) 0 ;
  VisBaseEntity_cl *arg2 = (VisBaseEntity_cl *) 0 ;
  
  SWIG_check_num_args("OrientedBoundingBox",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("OrientedBoundingBox",1,"VScriptDraw_wrapper *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("OrientedBoundingBox",2,"VisBaseEntity_cl *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VScriptDraw_wrapper,0))){
    SWIG_fail_ptr("VScriptDraw_wrapper_OrientedBoundingBox",1,SWIGTYPE_p_VScriptDraw_wrapper);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_VisBaseEntity_cl,0))){
    SWIG_fail_ptr("VScriptDraw_wrapper_OrientedBoundingBox",2,SWIGTYPE_p_VisBaseEntity_cl);
  }
  
  (arg1)->OrientedBoundingBox(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VScriptDraw_wrapper_OrientedBoundingBox(lua_State* L) {
  int argc;
  int argv[6]={
    1,2,3,4,5,6
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VScriptDraw_wrapper, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_VisBaseEntity_cl, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_VScriptDraw_wrapper_OrientedBoundingBox__SWIG_3(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VScriptDraw_wrapper, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_VisBaseEntity_cl, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_VColorRef, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          return _wrap_VScriptDraw_wrapper_OrientedBoundingBox__SWIG_2(L);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VScriptDraw_wrapper, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_hkvAlignedBBox, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          void *ptr;
          if (SWIG_isptrtype(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_hkvMat3, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          {
            void *ptr;
            if (SWIG_isptrtype(L,argv[3])==0 || SWIG_ConvertPtr(L,argv[3], (void **) &ptr, SWIGTYPE_p_hkvVec3, 0)) {
              _v = 0;
            } else {
              _v = 1;
            }
          }
          if (_v) {
            return _wrap_VScriptDraw_wrapper_OrientedBoundingBox__SWIG_1(L);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VScriptDraw_wrapper, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_hkvAlignedBBox, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          void *ptr;
          if (SWIG_isptrtype(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_hkvMat3, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          {
            void *ptr;
            if (SWIG_isptrtype(L,argv[3])==0 || SWIG_ConvertPtr(L,argv[3], (void **) &ptr, SWIGTYPE_p_hkvVec3, 0)) {
              _v = 0;
            } else {
              _v = 1;
            }
          }
          if (_v) {
            {
              void *ptr;
              if (lua_isuserdata(L,argv[4])==0 || SWIG_ConvertPtr(L,argv[4], (void **) &ptr, SWIGTYPE_p_VColorRef, 0)) {
                _v = 0;
              } else {
                _v = 1;
              }
            }
            if (_v) {
              return _wrap_VScriptDraw_wrapper_OrientedBoundingBox__SWIG_0(L);
            }
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'VScriptDraw_wrapper_OrientedBoundingBox'\n"
    "  Possible C/C++ prototypes are:\n"
    "    OrientedBoundingBox(VScriptDraw_wrapper *,hkvAlignedBBox const *,hkvMat3 const *,hkvVec3 const *,VColorRef)\n"
    "    OrientedBoundingBox(VScriptDraw_wrapper *,hkvAlignedBBox const *,hkvMat3 const *,hkvVec3 const *)\n"
    "    OrientedBoundingBox(VScriptDraw_wrapper *,VisBaseEntity_cl *,VColorRef)\n"
    "    OrientedBoundingBox(VScriptDraw_wrapper *,VisBaseEntity_cl *)\n");
  lua_error(L);return 0;
}


static int _wrap_VScriptDraw_wrapper_BoneBoundingBox__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  VScriptDraw_wrapper *arg1 = (VScriptDraw_wrapper *) 0 ;
  VisBaseEntity_cl *arg2 = (VisBaseEntity_cl *) 0 ;
  char *arg3 = (char *) 0 ;
  VColorRef arg4 ;
  VColorRef *argp4 ;
  
  SWIG_check_num_args("BoneBoundingBox",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("BoneBoundingBox",1,"VScriptDraw_wrapper *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("BoneBoundingBox",2,"VisBaseEntity_cl *");
  if(!SWIG_lua_isnilstring(L,3)) SWIG_fail_arg("BoneBoundingBox",3,"char const *");
  if(!lua_isuserdata(L,4)) SWIG_fail_arg("BoneBoundingBox",4,"VColorRef");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VScriptDraw_wrapper,0))){
    SWIG_fail_ptr("VScriptDraw_wrapper_BoneBoundingBox",1,SWIGTYPE_p_VScriptDraw_wrapper);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_VisBaseEntity_cl,0))){
    SWIG_fail_ptr("VScriptDraw_wrapper_BoneBoundingBox",2,SWIGTYPE_p_VisBaseEntity_cl);
  }
  
  arg3 = (char *)lua_tostring(L, 3);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&argp4,SWIGTYPE_p_VColorRef,0))){
    SWIG_fail_ptr("VScriptDraw_wrapper_BoneBoundingBox",4,SWIGTYPE_p_VColorRef);
  }
  arg4 = *argp4;
  
  (arg1)->BoneBoundingBox(arg2,(char const *)arg3,arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VScriptDraw_wrapper_BoneBoundingBox__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  VScriptDraw_wrapper *arg1 = (VScriptDraw_wrapper *) 0 ;
  VisBaseEntity_cl *arg2 = (VisBaseEntity_cl *) 0 ;
  char *arg3 = (char *) 0 ;
  
  SWIG_check_num_args("BoneBoundingBox",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("BoneBoundingBox",1,"VScriptDraw_wrapper *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("BoneBoundingBox",2,"VisBaseEntity_cl *");
  if(!SWIG_lua_isnilstring(L,3)) SWIG_fail_arg("BoneBoundingBox",3,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VScriptDraw_wrapper,0))){
    SWIG_fail_ptr("VScriptDraw_wrapper_BoneBoundingBox",1,SWIGTYPE_p_VScriptDraw_wrapper);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_VisBaseEntity_cl,0))){
    SWIG_fail_ptr("VScriptDraw_wrapper_BoneBoundingBox",2,SWIGTYPE_p_VisBaseEntity_cl);
  }
  
  arg3 = (char *)lua_tostring(L, 3);
  (arg1)->BoneBoundingBox(arg2,(char const *)arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VScriptDraw_wrapper_BoneBoundingBox__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  VScriptDraw_wrapper *arg1 = (VScriptDraw_wrapper *) 0 ;
  VisBaseEntity_cl *arg2 = (VisBaseEntity_cl *) 0 ;
  
  SWIG_check_num_args("BoneBoundingBox",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("BoneBoundingBox",1,"VScriptDraw_wrapper *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("BoneBoundingBox",2,"VisBaseEntity_cl *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VScriptDraw_wrapper,0))){
    SWIG_fail_ptr("VScriptDraw_wrapper_BoneBoundingBox",1,SWIGTYPE_p_VScriptDraw_wrapper);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_VisBaseEntity_cl,0))){
    SWIG_fail_ptr("VScriptDraw_wrapper_BoneBoundingBox",2,SWIGTYPE_p_VisBaseEntity_cl);
  }
  
  (arg1)->BoneBoundingBox(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VScriptDraw_wrapper_BoneBoundingBox(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VScriptDraw_wrapper, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_VisBaseEntity_cl, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_VScriptDraw_wrapper_BoneBoundingBox__SWIG_2(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VScriptDraw_wrapper, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_VisBaseEntity_cl, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          _v = SWIG_lua_isnilstring(L,argv[2]);
        }
        if (_v) {
          return _wrap_VScriptDraw_wrapper_BoneBoundingBox__SWIG_1(L);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VScriptDraw_wrapper, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_VisBaseEntity_cl, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          _v = SWIG_lua_isnilstring(L,argv[2]);
        }
        if (_v) {
          {
            void *ptr;
            if (lua_isuserdata(L,argv[3])==0 || SWIG_ConvertPtr(L,argv[3], (void **) &ptr, SWIGTYPE_p_VColorRef, 0)) {
              _v = 0;
            } else {
              _v = 1;
            }
          }
          if (_v) {
            return _wrap_VScriptDraw_wrapper_BoneBoundingBox__SWIG_0(L);
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'VScriptDraw_wrapper_BoneBoundingBox'\n"
    "  Possible C/C++ prototypes are:\n"
    "    BoneBoundingBox(VScriptDraw_wrapper *,VisBaseEntity_cl *,char const *,VColorRef)\n"
    "    BoneBoundingBox(VScriptDraw_wrapper *,VisBaseEntity_cl *,char const *)\n"
    "    BoneBoundingBox(VScriptDraw_wrapper *,VisBaseEntity_cl *)\n");
  lua_error(L);return 0;
}


static int _wrap_VScriptDraw_wrapper_ParticleBoundingBox(lua_State* L) {
  int SWIG_arg = 0;
  VScriptDraw_wrapper *arg1 = (VScriptDraw_wrapper *) 0 ;
  VisParticleEffect_cl *arg2 = (VisParticleEffect_cl *) 0 ;
  
  SWIG_check_num_args("ParticleBoundingBox",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ParticleBoundingBox",1,"VScriptDraw_wrapper *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ParticleBoundingBox",2,"VisParticleEffect_cl *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VScriptDraw_wrapper,0))){
    SWIG_fail_ptr("VScriptDraw_wrapper_ParticleBoundingBox",1,SWIGTYPE_p_VScriptDraw_wrapper);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_VisParticleEffect_cl,0))){
    SWIG_fail_ptr("VScriptDraw_wrapper_ParticleBoundingBox",2,SWIGTYPE_p_VisParticleEffect_cl);
  }
  
  (arg1)->ParticleBoundingBox(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VScriptDraw_wrapper_Path__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  VScriptDraw_wrapper *arg1 = (VScriptDraw_wrapper *) 0 ;
  VisPath_cl *arg2 = (VisPath_cl *) 0 ;
  VColorRef arg3 ;
  VColorRef *argp3 ;
  
  SWIG_check_num_args("Path",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Path",1,"VScriptDraw_wrapper *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Path",2,"VisPath_cl *");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("Path",3,"VColorRef");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VScriptDraw_wrapper,0))){
    SWIG_fail_ptr("VScriptDraw_wrapper_Path",1,SWIGTYPE_p_VScriptDraw_wrapper);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_VisPath_cl,0))){
    SWIG_fail_ptr("VScriptDraw_wrapper_Path",2,SWIGTYPE_p_VisPath_cl);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&argp3,SWIGTYPE_p_VColorRef,0))){
    SWIG_fail_ptr("VScriptDraw_wrapper_Path",3,SWIGTYPE_p_VColorRef);
  }
  arg3 = *argp3;
  
  (arg1)->Path(arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VScriptDraw_wrapper_Path__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  VScriptDraw_wrapper *arg1 = (VScriptDraw_wrapper *) 0 ;
  VisPath_cl *arg2 = (VisPath_cl *) 0 ;
  
  SWIG_check_num_args("Path",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Path",1,"VScriptDraw_wrapper *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Path",2,"VisPath_cl *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VScriptDraw_wrapper,0))){
    SWIG_fail_ptr("VScriptDraw_wrapper_Path",1,SWIGTYPE_p_VScriptDraw_wrapper);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_VisPath_cl,0))){
    SWIG_fail_ptr("VScriptDraw_wrapper_Path",2,SWIGTYPE_p_VisPath_cl);
  }
  
  (arg1)->Path(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VScriptDraw_wrapper_Path(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VScriptDraw_wrapper, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_VisPath_cl, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_VScriptDraw_wrapper_Path__SWIG_1(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VScriptDraw_wrapper, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_VisPath_cl, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_VColorRef, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          return _wrap_VScriptDraw_wrapper_Path__SWIG_0(L);
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'VScriptDraw_wrapper_Path'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Path(VScriptDraw_wrapper *,VisPath_cl *,VColorRef)\n"
    "    Path(VScriptDraw_wrapper *,VisPath_cl *)\n");
  lua_error(L);return 0;
}


static int _wrap_VScriptDraw_wrapper_Wallmark__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  VScriptDraw_wrapper *arg1 = (VScriptDraw_wrapper *) 0 ;
  hkvVec3 *arg2 = (hkvVec3 *) 0 ;
  hkvVec3 *arg3 = (hkvVec3 *) 0 ;
  char *arg4 = (char *) 0 ;
  int arg5 ;
  float arg6 ;
  float arg7 ;
  float arg8 ;
  
  SWIG_check_num_args("Wallmark",8,8)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Wallmark",1,"VScriptDraw_wrapper *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Wallmark",2,"hkvVec3 const *");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("Wallmark",3,"hkvVec3 const *");
  if(!SWIG_lua_isnilstring(L,4)) SWIG_fail_arg("Wallmark",4,"char const *");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("Wallmark",5,"int");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("Wallmark",6,"float");
  if(!lua_isnumber(L,7)) SWIG_fail_arg("Wallmark",7,"float");
  if(!lua_isnumber(L,8)) SWIG_fail_arg("Wallmark",8,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VScriptDraw_wrapper,0))){
    SWIG_fail_ptr("VScriptDraw_wrapper_Wallmark",1,SWIGTYPE_p_VScriptDraw_wrapper);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("VScriptDraw_wrapper_Wallmark",2,SWIGTYPE_p_hkvVec3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("VScriptDraw_wrapper_Wallmark",3,SWIGTYPE_p_hkvVec3);
  }
  
  arg4 = (char *)lua_tostring(L, 4);
  arg5 = (int)lua_tonumber(L, 5);
  arg6 = (float)lua_tonumber(L, 6);
  arg7 = (float)lua_tonumber(L, 7);
  arg8 = (float)lua_tonumber(L, 8);
  (arg1)->Wallmark((hkvVec3 const *)arg2,(hkvVec3 const *)arg3,(char const *)arg4,arg5,arg6,arg7,arg8);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VScriptDraw_wrapper_Wallmark__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  VScriptDraw_wrapper *arg1 = (VScriptDraw_wrapper *) 0 ;
  hkvVec3 *arg2 = (hkvVec3 *) 0 ;
  hkvVec3 *arg3 = (hkvVec3 *) 0 ;
  char *arg4 = (char *) 0 ;
  int arg5 ;
  float arg6 ;
  float arg7 ;
  
  SWIG_check_num_args("Wallmark",7,7)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Wallmark",1,"VScriptDraw_wrapper *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Wallmark",2,"hkvVec3 const *");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("Wallmark",3,"hkvVec3 const *");
  if(!SWIG_lua_isnilstring(L,4)) SWIG_fail_arg("Wallmark",4,"char const *");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("Wallmark",5,"int");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("Wallmark",6,"float");
  if(!lua_isnumber(L,7)) SWIG_fail_arg("Wallmark",7,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VScriptDraw_wrapper,0))){
    SWIG_fail_ptr("VScriptDraw_wrapper_Wallmark",1,SWIGTYPE_p_VScriptDraw_wrapper);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("VScriptDraw_wrapper_Wallmark",2,SWIGTYPE_p_hkvVec3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("VScriptDraw_wrapper_Wallmark",3,SWIGTYPE_p_hkvVec3);
  }
  
  arg4 = (char *)lua_tostring(L, 4);
  arg5 = (int)lua_tonumber(L, 5);
  arg6 = (float)lua_tonumber(L, 6);
  arg7 = (float)lua_tonumber(L, 7);
  (arg1)->Wallmark((hkvVec3 const *)arg2,(hkvVec3 const *)arg3,(char const *)arg4,arg5,arg6,arg7);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VScriptDraw_wrapper_Wallmark__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  VScriptDraw_wrapper *arg1 = (VScriptDraw_wrapper *) 0 ;
  hkvVec3 *arg2 = (hkvVec3 *) 0 ;
  hkvVec3 *arg3 = (hkvVec3 *) 0 ;
  char *arg4 = (char *) 0 ;
  int arg5 ;
  float arg6 ;
  
  SWIG_check_num_args("Wallmark",6,6)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Wallmark",1,"VScriptDraw_wrapper *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Wallmark",2,"hkvVec3 const *");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("Wallmark",3,"hkvVec3 const *");
  if(!SWIG_lua_isnilstring(L,4)) SWIG_fail_arg("Wallmark",4,"char const *");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("Wallmark",5,"int");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("Wallmark",6,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VScriptDraw_wrapper,0))){
    SWIG_fail_ptr("VScriptDraw_wrapper_Wallmark",1,SWIGTYPE_p_VScriptDraw_wrapper);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("VScriptDraw_wrapper_Wallmark",2,SWIGTYPE_p_hkvVec3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("VScriptDraw_wrapper_Wallmark",3,SWIGTYPE_p_hkvVec3);
  }
  
  arg4 = (char *)lua_tostring(L, 4);
  arg5 = (int)lua_tonumber(L, 5);
  arg6 = (float)lua_tonumber(L, 6);
  (arg1)->Wallmark((hkvVec3 const *)arg2,(hkvVec3 const *)arg3,(char const *)arg4,arg5,arg6);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VScriptDraw_wrapper_Wallmark__SWIG_3(lua_State* L) {
  int SWIG_arg = 0;
  VScriptDraw_wrapper *arg1 = (VScriptDraw_wrapper *) 0 ;
  hkvVec3 *arg2 = (hkvVec3 *) 0 ;
  hkvVec3 *arg3 = (hkvVec3 *) 0 ;
  char *arg4 = (char *) 0 ;
  int arg5 ;
  
  SWIG_check_num_args("Wallmark",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Wallmark",1,"VScriptDraw_wrapper *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Wallmark",2,"hkvVec3 const *");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("Wallmark",3,"hkvVec3 const *");
  if(!SWIG_lua_isnilstring(L,4)) SWIG_fail_arg("Wallmark",4,"char const *");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("Wallmark",5,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VScriptDraw_wrapper,0))){
    SWIG_fail_ptr("VScriptDraw_wrapper_Wallmark",1,SWIGTYPE_p_VScriptDraw_wrapper);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("VScriptDraw_wrapper_Wallmark",2,SWIGTYPE_p_hkvVec3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("VScriptDraw_wrapper_Wallmark",3,SWIGTYPE_p_hkvVec3);
  }
  
  arg4 = (char *)lua_tostring(L, 4);
  arg5 = (int)lua_tonumber(L, 5);
  (arg1)->Wallmark((hkvVec3 const *)arg2,(hkvVec3 const *)arg3,(char const *)arg4,arg5);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VScriptDraw_wrapper_Wallmark__SWIG_4(lua_State* L) {
  int SWIG_arg = 0;
  VScriptDraw_wrapper *arg1 = (VScriptDraw_wrapper *) 0 ;
  hkvVec3 *arg2 = (hkvVec3 *) 0 ;
  hkvVec3 *arg3 = (hkvVec3 *) 0 ;
  char *arg4 = (char *) 0 ;
  
  SWIG_check_num_args("Wallmark",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Wallmark",1,"VScriptDraw_wrapper *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Wallmark",2,"hkvVec3 const *");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("Wallmark",3,"hkvVec3 const *");
  if(!SWIG_lua_isnilstring(L,4)) SWIG_fail_arg("Wallmark",4,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VScriptDraw_wrapper,0))){
    SWIG_fail_ptr("VScriptDraw_wrapper_Wallmark",1,SWIGTYPE_p_VScriptDraw_wrapper);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("VScriptDraw_wrapper_Wallmark",2,SWIGTYPE_p_hkvVec3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("VScriptDraw_wrapper_Wallmark",3,SWIGTYPE_p_hkvVec3);
  }
  
  arg4 = (char *)lua_tostring(L, 4);
  (arg1)->Wallmark((hkvVec3 const *)arg2,(hkvVec3 const *)arg3,(char const *)arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VScriptDraw_wrapper_Wallmark(lua_State* L) {
  int argc;
  int argv[9]={
    1,2,3,4,5,6,7,8,9
  };
  
  argc = lua_gettop(L);
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VScriptDraw_wrapper, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_hkvVec3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          void *ptr;
          if (SWIG_isptrtype(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_hkvVec3, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          {
            _v = SWIG_lua_isnilstring(L,argv[3]);
          }
          if (_v) {
            return _wrap_VScriptDraw_wrapper_Wallmark__SWIG_4(L);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VScriptDraw_wrapper, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_hkvVec3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          void *ptr;
          if (SWIG_isptrtype(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_hkvVec3, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          {
            _v = SWIG_lua_isnilstring(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isnumber(L,argv[4]);
            }
            if (_v) {
              return _wrap_VScriptDraw_wrapper_Wallmark__SWIG_3(L);
            }
          }
        }
      }
    }
  }
  if (argc == 6) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VScriptDraw_wrapper, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_hkvVec3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          void *ptr;
          if (SWIG_isptrtype(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_hkvVec3, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          {
            _v = SWIG_lua_isnilstring(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isnumber(L,argv[4]);
            }
            if (_v) {
              {
                _v = lua_isnumber(L,argv[5]);
              }
              if (_v) {
                return _wrap_VScriptDraw_wrapper_Wallmark__SWIG_2(L);
              }
            }
          }
        }
      }
    }
  }
  if (argc == 7) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VScriptDraw_wrapper, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_hkvVec3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          void *ptr;
          if (SWIG_isptrtype(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_hkvVec3, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          {
            _v = SWIG_lua_isnilstring(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isnumber(L,argv[4]);
            }
            if (_v) {
              {
                _v = lua_isnumber(L,argv[5]);
              }
              if (_v) {
                {
                  _v = lua_isnumber(L,argv[6]);
                }
                if (_v) {
                  return _wrap_VScriptDraw_wrapper_Wallmark__SWIG_1(L);
                }
              }
            }
          }
        }
      }
    }
  }
  if (argc == 8) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VScriptDraw_wrapper, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_hkvVec3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          void *ptr;
          if (SWIG_isptrtype(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_hkvVec3, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          {
            _v = SWIG_lua_isnilstring(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isnumber(L,argv[4]);
            }
            if (_v) {
              {
                _v = lua_isnumber(L,argv[5]);
              }
              if (_v) {
                {
                  _v = lua_isnumber(L,argv[6]);
                }
                if (_v) {
                  {
                    _v = lua_isnumber(L,argv[7]);
                  }
                  if (_v) {
                    return _wrap_VScriptDraw_wrapper_Wallmark__SWIG_0(L);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'VScriptDraw_wrapper_Wallmark'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Wallmark(VScriptDraw_wrapper *,hkvVec3 const *,hkvVec3 const *,char const *,int,float,float,float)\n"
    "    Wallmark(VScriptDraw_wrapper *,hkvVec3 const *,hkvVec3 const *,char const *,int,float,float)\n"
    "    Wallmark(VScriptDraw_wrapper *,hkvVec3 const *,hkvVec3 const *,char const *,int,float)\n"
    "    Wallmark(VScriptDraw_wrapper *,hkvVec3 const *,hkvVec3 const *,char const *,int)\n"
    "    Wallmark(VScriptDraw_wrapper *,hkvVec3 const *,hkvVec3 const *,char const *)\n");
  lua_error(L);return 0;
}


static swig_lua_method swig_VScriptDraw_wrapper_methods[] = {
    {"Line", _wrap_VScriptDraw_wrapper_Line}, 
    {"Line2D", _wrap_VScriptDraw_wrapper_Line2D}, 
    {"Box", _wrap_VScriptDraw_wrapper_Box}, 
    {"BoundingBox", _wrap_VScriptDraw_wrapper_BoundingBox}, 
    {"OrientedBoundingBox", _wrap_VScriptDraw_wrapper_OrientedBoundingBox}, 
    {"BoneBoundingBox", _wrap_VScriptDraw_wrapper_BoneBoundingBox}, 
    {"ParticleBoundingBox", _wrap_VScriptDraw_wrapper_ParticleBoundingBox}, 
    {"Path", _wrap_VScriptDraw_wrapper_Path}, 
    {"Wallmark", _wrap_VScriptDraw_wrapper_Wallmark}, 
    {0,0}
};
static swig_lua_attribute swig_VScriptDraw_wrapper_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_VScriptDraw_wrapper_bases[] = {0};
static const char *swig_VScriptDraw_wrapper_base_names[] = {0};
static swig_lua_class _wrap_class_VScriptDraw_wrapper = { "VScriptDraw_wrapper", &SWIGTYPE_p_VScriptDraw_wrapper,0,0, swig_VScriptDraw_wrapper_methods, swig_VScriptDraw_wrapper_attributes, swig_VScriptDraw_wrapper_bases, swig_VScriptDraw_wrapper_base_names };

static int _wrap_new_VScriptDebug_wrapper(lua_State* L) {
  int SWIG_arg = 0;
  VScriptDebug_wrapper *result = 0 ;
  
  SWIG_check_num_args("VScriptDebug_wrapper",0,0)
  result = (VScriptDebug_wrapper *)new VScriptDebug_wrapper();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_VScriptDebug_wrapper,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VScriptDebug_wrapper_Draw_set(lua_State* L) {
  int SWIG_arg = 0;
  VScriptDebug_wrapper *arg1 = (VScriptDebug_wrapper *) 0 ;
  VScriptDraw_wrapper *arg2 = (VScriptDraw_wrapper *) 0 ;
  
  SWIG_check_num_args("Draw",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Draw",1,"VScriptDebug_wrapper *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Draw",2,"VScriptDraw_wrapper *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VScriptDebug_wrapper,0))){
    SWIG_fail_ptr("VScriptDebug_wrapper_Draw_set",1,SWIGTYPE_p_VScriptDebug_wrapper);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_VScriptDraw_wrapper,0))){
    SWIG_fail_ptr("VScriptDebug_wrapper_Draw_set",2,SWIGTYPE_p_VScriptDraw_wrapper);
  }
  
  if (arg1) (arg1)->Draw = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VScriptDebug_wrapper_Draw_get(lua_State* L) {
  int SWIG_arg = 0;
  VScriptDebug_wrapper *arg1 = (VScriptDebug_wrapper *) 0 ;
  VScriptDraw_wrapper *result = 0 ;
  
  SWIG_check_num_args("Draw",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Draw",1,"VScriptDebug_wrapper *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VScriptDebug_wrapper,0))){
    SWIG_fail_ptr("VScriptDebug_wrapper_Draw_get",1,SWIGTYPE_p_VScriptDebug_wrapper);
  }
  
  result = (VScriptDraw_wrapper *)& ((arg1)->Draw);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_VScriptDraw_wrapper,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VScriptDebug_wrapper_Enable(lua_State* L) {
  int SWIG_arg = 0;
  VScriptDebug_wrapper *arg1 = (VScriptDebug_wrapper *) 0 ;
  bool arg2 ;
  
  SWIG_check_num_args("Enable",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Enable",1,"VScriptDebug_wrapper *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("Enable",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VScriptDebug_wrapper,0))){
    SWIG_fail_ptr("VScriptDebug_wrapper_Enable",1,SWIGTYPE_p_VScriptDebug_wrapper);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  (arg1)->Enable(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VScriptDebug_wrapper_IsEnabled(lua_State* L) {
  int SWIG_arg = 0;
  VScriptDebug_wrapper *arg1 = (VScriptDebug_wrapper *) 0 ;
  bool result;
  
  SWIG_check_num_args("IsEnabled",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("IsEnabled",1,"VScriptDebug_wrapper *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VScriptDebug_wrapper,0))){
    SWIG_fail_ptr("VScriptDebug_wrapper_IsEnabled",1,SWIGTYPE_p_VScriptDebug_wrapper);
  }
  
  result = (bool)(arg1)->IsEnabled();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VScriptDebug_wrapper_PrintLine__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  VScriptDebug_wrapper *arg1 = (VScriptDebug_wrapper *) 0 ;
  char *arg2 = (char *) 0 ;
  VColorRef arg3 ;
  VColorRef *argp3 ;
  
  SWIG_check_num_args("PrintLine",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("PrintLine",1,"VScriptDebug_wrapper *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("PrintLine",2,"char const *");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("PrintLine",3,"VColorRef");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VScriptDebug_wrapper,0))){
    SWIG_fail_ptr("VScriptDebug_wrapper_PrintLine",1,SWIGTYPE_p_VScriptDebug_wrapper);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&argp3,SWIGTYPE_p_VColorRef,0))){
    SWIG_fail_ptr("VScriptDebug_wrapper_PrintLine",3,SWIGTYPE_p_VColorRef);
  }
  arg3 = *argp3;
  
  (arg1)->PrintLine((char const *)arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VScriptDebug_wrapper_PrintLine__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  VScriptDebug_wrapper *arg1 = (VScriptDebug_wrapper *) 0 ;
  char *arg2 = (char *) 0 ;
  
  SWIG_check_num_args("PrintLine",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("PrintLine",1,"VScriptDebug_wrapper *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("PrintLine",2,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VScriptDebug_wrapper,0))){
    SWIG_fail_ptr("VScriptDebug_wrapper_PrintLine",1,SWIGTYPE_p_VScriptDebug_wrapper);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  (arg1)->PrintLine((char const *)arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VScriptDebug_wrapper_PrintLine(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VScriptDebug_wrapper, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = SWIG_lua_isnilstring(L,argv[1]);
      }
      if (_v) {
        return _wrap_VScriptDebug_wrapper_PrintLine__SWIG_1(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VScriptDebug_wrapper, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = SWIG_lua_isnilstring(L,argv[1]);
      }
      if (_v) {
        {
          void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_VColorRef, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          return _wrap_VScriptDebug_wrapper_PrintLine__SWIG_0(L);
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'VScriptDebug_wrapper_PrintLine'\n"
    "  Possible C/C++ prototypes are:\n"
    "    PrintLine(VScriptDebug_wrapper *,char const *,VColorRef)\n"
    "    PrintLine(VScriptDebug_wrapper *,char const *)\n");
  lua_error(L);return 0;
}


static int _wrap_VScriptDebug_wrapper_ClearLines(lua_State* L) {
  int SWIG_arg = 0;
  VScriptDebug_wrapper *arg1 = (VScriptDebug_wrapper *) 0 ;
  
  SWIG_check_num_args("ClearLines",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ClearLines",1,"VScriptDebug_wrapper *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VScriptDebug_wrapper,0))){
    SWIG_fail_ptr("VScriptDebug_wrapper_ClearLines",1,SWIGTYPE_p_VScriptDebug_wrapper);
  }
  
  (arg1)->ClearLines();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VScriptDebug_wrapper_PrintAt__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  VScriptDebug_wrapper *arg1 = (VScriptDebug_wrapper *) 0 ;
  float arg2 ;
  float arg3 ;
  char *arg4 = (char *) 0 ;
  VColorRef arg5 ;
  char *arg6 = (char *) 0 ;
  VColorRef *argp5 ;
  
  SWIG_check_num_args("PrintAt",6,6)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("PrintAt",1,"VScriptDebug_wrapper *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("PrintAt",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("PrintAt",3,"float");
  if(!SWIG_lua_isnilstring(L,4)) SWIG_fail_arg("PrintAt",4,"char const *");
  if(!lua_isuserdata(L,5)) SWIG_fail_arg("PrintAt",5,"VColorRef");
  if(!SWIG_lua_isnilstring(L,6)) SWIG_fail_arg("PrintAt",6,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VScriptDebug_wrapper,0))){
    SWIG_fail_ptr("VScriptDebug_wrapper_PrintAt",1,SWIGTYPE_p_VScriptDebug_wrapper);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (char *)lua_tostring(L, 4);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,5,(void**)&argp5,SWIGTYPE_p_VColorRef,0))){
    SWIG_fail_ptr("VScriptDebug_wrapper_PrintAt",5,SWIGTYPE_p_VColorRef);
  }
  arg5 = *argp5;
  
  arg6 = (char *)lua_tostring(L, 6);
  (arg1)->PrintAt(arg2,arg3,(char const *)arg4,arg5,(char const *)arg6);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VScriptDebug_wrapper_PrintAt__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  VScriptDebug_wrapper *arg1 = (VScriptDebug_wrapper *) 0 ;
  float arg2 ;
  float arg3 ;
  char *arg4 = (char *) 0 ;
  VColorRef arg5 ;
  VColorRef *argp5 ;
  
  SWIG_check_num_args("PrintAt",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("PrintAt",1,"VScriptDebug_wrapper *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("PrintAt",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("PrintAt",3,"float");
  if(!SWIG_lua_isnilstring(L,4)) SWIG_fail_arg("PrintAt",4,"char const *");
  if(!lua_isuserdata(L,5)) SWIG_fail_arg("PrintAt",5,"VColorRef");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VScriptDebug_wrapper,0))){
    SWIG_fail_ptr("VScriptDebug_wrapper_PrintAt",1,SWIGTYPE_p_VScriptDebug_wrapper);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (char *)lua_tostring(L, 4);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,5,(void**)&argp5,SWIGTYPE_p_VColorRef,0))){
    SWIG_fail_ptr("VScriptDebug_wrapper_PrintAt",5,SWIGTYPE_p_VColorRef);
  }
  arg5 = *argp5;
  
  (arg1)->PrintAt(arg2,arg3,(char const *)arg4,arg5);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VScriptDebug_wrapper_PrintAt__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  VScriptDebug_wrapper *arg1 = (VScriptDebug_wrapper *) 0 ;
  float arg2 ;
  float arg3 ;
  char *arg4 = (char *) 0 ;
  
  SWIG_check_num_args("PrintAt",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("PrintAt",1,"VScriptDebug_wrapper *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("PrintAt",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("PrintAt",3,"float");
  if(!SWIG_lua_isnilstring(L,4)) SWIG_fail_arg("PrintAt",4,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VScriptDebug_wrapper,0))){
    SWIG_fail_ptr("VScriptDebug_wrapper_PrintAt",1,SWIGTYPE_p_VScriptDebug_wrapper);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (char *)lua_tostring(L, 4);
  (arg1)->PrintAt(arg2,arg3,(char const *)arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VScriptDebug_wrapper_PrintAt__SWIG_3(lua_State* L) {
  int SWIG_arg = 0;
  VScriptDebug_wrapper *arg1 = (VScriptDebug_wrapper *) 0 ;
  hkvVec3 *arg2 = (hkvVec3 *) 0 ;
  char *arg3 = (char *) 0 ;
  VColorRef arg4 ;
  char *arg5 = (char *) 0 ;
  VColorRef *argp4 ;
  
  SWIG_check_num_args("PrintAt",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("PrintAt",1,"VScriptDebug_wrapper *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("PrintAt",2,"hkvVec3 const *");
  if(!SWIG_lua_isnilstring(L,3)) SWIG_fail_arg("PrintAt",3,"char const *");
  if(!lua_isuserdata(L,4)) SWIG_fail_arg("PrintAt",4,"VColorRef");
  if(!SWIG_lua_isnilstring(L,5)) SWIG_fail_arg("PrintAt",5,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VScriptDebug_wrapper,0))){
    SWIG_fail_ptr("VScriptDebug_wrapper_PrintAt",1,SWIGTYPE_p_VScriptDebug_wrapper);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("VScriptDebug_wrapper_PrintAt",2,SWIGTYPE_p_hkvVec3);
  }
  
  arg3 = (char *)lua_tostring(L, 3);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&argp4,SWIGTYPE_p_VColorRef,0))){
    SWIG_fail_ptr("VScriptDebug_wrapper_PrintAt",4,SWIGTYPE_p_VColorRef);
  }
  arg4 = *argp4;
  
  arg5 = (char *)lua_tostring(L, 5);
  (arg1)->PrintAt((hkvVec3 const *)arg2,(char const *)arg3,arg4,(char const *)arg5);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VScriptDebug_wrapper_PrintAt__SWIG_4(lua_State* L) {
  int SWIG_arg = 0;
  VScriptDebug_wrapper *arg1 = (VScriptDebug_wrapper *) 0 ;
  hkvVec3 *arg2 = (hkvVec3 *) 0 ;
  char *arg3 = (char *) 0 ;
  VColorRef arg4 ;
  VColorRef *argp4 ;
  
  SWIG_check_num_args("PrintAt",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("PrintAt",1,"VScriptDebug_wrapper *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("PrintAt",2,"hkvVec3 const *");
  if(!SWIG_lua_isnilstring(L,3)) SWIG_fail_arg("PrintAt",3,"char const *");
  if(!lua_isuserdata(L,4)) SWIG_fail_arg("PrintAt",4,"VColorRef");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VScriptDebug_wrapper,0))){
    SWIG_fail_ptr("VScriptDebug_wrapper_PrintAt",1,SWIGTYPE_p_VScriptDebug_wrapper);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("VScriptDebug_wrapper_PrintAt",2,SWIGTYPE_p_hkvVec3);
  }
  
  arg3 = (char *)lua_tostring(L, 3);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&argp4,SWIGTYPE_p_VColorRef,0))){
    SWIG_fail_ptr("VScriptDebug_wrapper_PrintAt",4,SWIGTYPE_p_VColorRef);
  }
  arg4 = *argp4;
  
  (arg1)->PrintAt((hkvVec3 const *)arg2,(char const *)arg3,arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VScriptDebug_wrapper_PrintAt__SWIG_5(lua_State* L) {
  int SWIG_arg = 0;
  VScriptDebug_wrapper *arg1 = (VScriptDebug_wrapper *) 0 ;
  hkvVec3 *arg2 = (hkvVec3 *) 0 ;
  char *arg3 = (char *) 0 ;
  
  SWIG_check_num_args("PrintAt",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("PrintAt",1,"VScriptDebug_wrapper *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("PrintAt",2,"hkvVec3 const *");
  if(!SWIG_lua_isnilstring(L,3)) SWIG_fail_arg("PrintAt",3,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VScriptDebug_wrapper,0))){
    SWIG_fail_ptr("VScriptDebug_wrapper_PrintAt",1,SWIGTYPE_p_VScriptDebug_wrapper);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("VScriptDebug_wrapper_PrintAt",2,SWIGTYPE_p_hkvVec3);
  }
  
  arg3 = (char *)lua_tostring(L, 3);
  (arg1)->PrintAt((hkvVec3 const *)arg2,(char const *)arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VScriptDebug_wrapper_PrintAt(lua_State* L) {
  int argc;
  int argv[7]={
    1,2,3,4,5,6,7
  };
  
  argc = lua_gettop(L);
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VScriptDebug_wrapper, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_hkvVec3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          _v = SWIG_lua_isnilstring(L,argv[2]);
        }
        if (_v) {
          return _wrap_VScriptDebug_wrapper_PrintAt__SWIG_5(L);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VScriptDebug_wrapper, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_hkvVec3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          _v = SWIG_lua_isnilstring(L,argv[2]);
        }
        if (_v) {
          {
            void *ptr;
            if (lua_isuserdata(L,argv[3])==0 || SWIG_ConvertPtr(L,argv[3], (void **) &ptr, SWIGTYPE_p_VColorRef, 0)) {
              _v = 0;
            } else {
              _v = 1;
            }
          }
          if (_v) {
            return _wrap_VScriptDebug_wrapper_PrintAt__SWIG_4(L);
          }
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VScriptDebug_wrapper, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = SWIG_lua_isnilstring(L,argv[3]);
          }
          if (_v) {
            return _wrap_VScriptDebug_wrapper_PrintAt__SWIG_2(L);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VScriptDebug_wrapper, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_hkvVec3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          _v = SWIG_lua_isnilstring(L,argv[2]);
        }
        if (_v) {
          {
            void *ptr;
            if (lua_isuserdata(L,argv[3])==0 || SWIG_ConvertPtr(L,argv[3], (void **) &ptr, SWIGTYPE_p_VColorRef, 0)) {
              _v = 0;
            } else {
              _v = 1;
            }
          }
          if (_v) {
            {
              _v = SWIG_lua_isnilstring(L,argv[4]);
            }
            if (_v) {
              return _wrap_VScriptDebug_wrapper_PrintAt__SWIG_3(L);
            }
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VScriptDebug_wrapper, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = SWIG_lua_isnilstring(L,argv[3]);
          }
          if (_v) {
            {
              void *ptr;
              if (lua_isuserdata(L,argv[4])==0 || SWIG_ConvertPtr(L,argv[4], (void **) &ptr, SWIGTYPE_p_VColorRef, 0)) {
                _v = 0;
              } else {
                _v = 1;
              }
            }
            if (_v) {
              return _wrap_VScriptDebug_wrapper_PrintAt__SWIG_1(L);
            }
          }
        }
      }
    }
  }
  if (argc == 6) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VScriptDebug_wrapper, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = SWIG_lua_isnilstring(L,argv[3]);
          }
          if (_v) {
            {
              void *ptr;
              if (lua_isuserdata(L,argv[4])==0 || SWIG_ConvertPtr(L,argv[4], (void **) &ptr, SWIGTYPE_p_VColorRef, 0)) {
                _v = 0;
              } else {
                _v = 1;
              }
            }
            if (_v) {
              {
                _v = SWIG_lua_isnilstring(L,argv[5]);
              }
              if (_v) {
                return _wrap_VScriptDebug_wrapper_PrintAt__SWIG_0(L);
              }
            }
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'VScriptDebug_wrapper_PrintAt'\n"
    "  Possible C/C++ prototypes are:\n"
    "    PrintAt(VScriptDebug_wrapper *,float,float,char const *,VColorRef,char const *)\n"
    "    PrintAt(VScriptDebug_wrapper *,float,float,char const *,VColorRef)\n"
    "    PrintAt(VScriptDebug_wrapper *,float,float,char const *)\n"
    "    PrintAt(VScriptDebug_wrapper *,hkvVec3 const *,char const *,VColorRef,char const *)\n"
    "    PrintAt(VScriptDebug_wrapper *,hkvVec3 const *,char const *,VColorRef)\n"
    "    PrintAt(VScriptDebug_wrapper *,hkvVec3 const *,char const *)\n");
  lua_error(L);return 0;
}


static int _wrap_VScriptDebug_wrapper_SetupLines__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  VScriptDebug_wrapper *arg1 = (VScriptDebug_wrapper *) 0 ;
  int arg2 ;
  float arg3 ;
  
  SWIG_check_num_args("SetupLines",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetupLines",1,"VScriptDebug_wrapper *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SetupLines",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("SetupLines",3,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VScriptDebug_wrapper,0))){
    SWIG_fail_ptr("VScriptDebug_wrapper_SetupLines",1,SWIGTYPE_p_VScriptDebug_wrapper);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  (arg1)->SetupLines(arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VScriptDebug_wrapper_SetupLines__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  VScriptDebug_wrapper *arg1 = (VScriptDebug_wrapper *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("SetupLines",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetupLines",1,"VScriptDebug_wrapper *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SetupLines",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VScriptDebug_wrapper,0))){
    SWIG_fail_ptr("VScriptDebug_wrapper_SetupLines",1,SWIGTYPE_p_VScriptDebug_wrapper);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->SetupLines(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VScriptDebug_wrapper_SetupLines(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VScriptDebug_wrapper, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_VScriptDebug_wrapper_SetupLines__SWIG_1(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VScriptDebug_wrapper, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          return _wrap_VScriptDebug_wrapper_SetupLines__SWIG_0(L);
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'VScriptDebug_wrapper_SetupLines'\n"
    "  Possible C/C++ prototypes are:\n"
    "    SetupLines(VScriptDebug_wrapper *,int,float)\n"
    "    SetupLines(VScriptDebug_wrapper *,int)\n");
  lua_error(L);return 0;
}


static int _wrap_VScriptDebug_wrapper_Log(lua_State* L) {
  int SWIG_arg = 0;
  VScriptDebug_wrapper *arg1 = (VScriptDebug_wrapper *) 0 ;
  char *arg2 = (char *) 0 ;
  
  SWIG_check_num_args("Log",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Log",1,"VScriptDebug_wrapper *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("Log",2,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VScriptDebug_wrapper,0))){
    SWIG_fail_ptr("VScriptDebug_wrapper_Log",1,SWIGTYPE_p_VScriptDebug_wrapper);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  (arg1)->Log((char const *)arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VScriptDebug_wrapper_Error(lua_State* L) {
  int SWIG_arg = 0;
  VScriptDebug_wrapper *arg1 = (VScriptDebug_wrapper *) 0 ;
  char *arg2 = (char *) 0 ;
  
  SWIG_check_num_args("Error",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Error",1,"VScriptDebug_wrapper *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("Error",2,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VScriptDebug_wrapper,0))){
    SWIG_fail_ptr("VScriptDebug_wrapper_Error",1,SWIGTYPE_p_VScriptDebug_wrapper);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  (arg1)->Error((char const *)arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_VScriptDebug_wrapper(void *obj) {
VScriptDebug_wrapper *arg1 = (VScriptDebug_wrapper *) obj;
delete arg1;
}
static swig_lua_method swig_VScriptDebug_wrapper_methods[] = {
    {"Enable", _wrap_VScriptDebug_wrapper_Enable}, 
    {"IsEnabled", _wrap_VScriptDebug_wrapper_IsEnabled}, 
    {"PrintLine", _wrap_VScriptDebug_wrapper_PrintLine}, 
    {"ClearLines", _wrap_VScriptDebug_wrapper_ClearLines}, 
    {"PrintAt", _wrap_VScriptDebug_wrapper_PrintAt}, 
    {"SetupLines", _wrap_VScriptDebug_wrapper_SetupLines}, 
    {"Log", _wrap_VScriptDebug_wrapper_Log}, 
    {"Error", _wrap_VScriptDebug_wrapper_Error}, 
    {0,0}
};
static swig_lua_attribute swig_VScriptDebug_wrapper_attributes[] = {
    { "Draw", _wrap_VScriptDebug_wrapper_Draw_get, _wrap_VScriptDebug_wrapper_Draw_set},
    {0,0,0}
};
static swig_lua_class *swig_VScriptDebug_wrapper_bases[] = {0};
static const char *swig_VScriptDebug_wrapper_base_names[] = {0};
static swig_lua_class _wrap_class_VScriptDebug_wrapper = { "VScriptDebug_wrapper", &SWIGTYPE_p_VScriptDebug_wrapper,_wrap_new_VScriptDebug_wrapper, swig_delete_VScriptDebug_wrapper, swig_VScriptDebug_wrapper_methods, swig_VScriptDebug_wrapper_attributes, swig_VScriptDebug_wrapper_bases, swig_VScriptDebug_wrapper_base_names };

static int _wrap_KEY_UNKNOWN_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEY_UNKNOWN",0,0)
  result = (int)(int)KEY_UNKNOWN;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEY_LSHIFT_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEY_LSHIFT",0,0)
  result = (int)(int)KEY_LSHIFT;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEY_RSHIFT_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEY_RSHIFT",0,0)
  result = (int)(int)KEY_RSHIFT;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEY_LCTRL_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEY_LCTRL",0,0)
  result = (int)(int)KEY_LCTRL;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEY_RCTRL_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEY_RCTRL",0,0)
  result = (int)(int)KEY_RCTRL;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEY_LALT_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEY_LALT",0,0)
  result = (int)(int)KEY_LALT;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEY_RALT_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEY_RALT",0,0)
  result = (int)(int)KEY_RALT;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEY_ALTGR_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEY_ALTGR",0,0)
  result = (int)(int)KEY_ALTGR;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEY_BACKSPACE_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEY_BACKSPACE",0,0)
  result = (int)(int)KEY_BACKSPACE;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEY_TAB_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEY_TAB",0,0)
  result = (int)(int)KEY_TAB;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEY_LWIN_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEY_LWIN",0,0)
  result = (int)(int)KEY_LWIN;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEY_RWIN_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEY_RWIN",0,0)
  result = (int)(int)KEY_RWIN;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEY_APPS_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEY_APPS",0,0)
  result = (int)(int)KEY_APPS;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEY_ENTER_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEY_ENTER",0,0)
  result = (int)(int)KEY_ENTER;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEY_LCOM_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEY_LCOM",0,0)
  result = (int)(int)KEY_LCOM;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEY_RCOM_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEY_RCOM",0,0)
  result = (int)(int)KEY_RCOM;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEY_MAC_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEY_MAC",0,0)
  result = (int)(int)KEY_MAC;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEY_LMETA_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEY_LMETA",0,0)
  result = (int)(int)KEY_LMETA;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEY_RMETA_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEY_RMETA",0,0)
  result = (int)(int)KEY_RMETA;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEY_INS_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEY_INS",0,0)
  result = (int)(int)KEY_INS;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEY_DEL_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEY_DEL",0,0)
  result = (int)(int)KEY_DEL;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEY_HOME_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEY_HOME",0,0)
  result = (int)(int)KEY_HOME;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEY_END_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEY_END",0,0)
  result = (int)(int)KEY_END;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEY_PAGEUP_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEY_PAGEUP",0,0)
  result = (int)(int)KEY_PAGEUP;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEY_PAGEDOWN_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEY_PAGEDOWN",0,0)
  result = (int)(int)KEY_PAGEDOWN;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEY_ESC_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEY_ESC",0,0)
  result = (int)(int)KEY_ESC;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEY_UP_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEY_UP",0,0)
  result = (int)(int)KEY_UP;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEY_DOWN_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEY_DOWN",0,0)
  result = (int)(int)KEY_DOWN;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEY_LEFT_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEY_LEFT",0,0)
  result = (int)(int)KEY_LEFT;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEY_RIGHT_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEY_RIGHT",0,0)
  result = (int)(int)KEY_RIGHT;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEY_SPACE_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEY_SPACE",0,0)
  result = (int)(int)KEY_SPACE;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEY_COMMA_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEY_COMMA",0,0)
  result = (int)(int)KEY_COMMA;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEY_PERIOD_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEY_PERIOD",0,0)
  result = (int)(int)KEY_PERIOD;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEY_MINUS_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEY_MINUS",0,0)
  result = (int)(int)KEY_MINUS;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEY_GRAVE_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEY_GRAVE",0,0)
  result = (int)(int)KEY_GRAVE;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEY_0_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEY_0",0,0)
  result = (int)(int)KEY_0;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEY_1_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEY_1",0,0)
  result = (int)(int)KEY_1;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEY_2_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEY_2",0,0)
  result = (int)(int)KEY_2;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEY_3_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEY_3",0,0)
  result = (int)(int)KEY_3;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEY_4_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEY_4",0,0)
  result = (int)(int)KEY_4;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEY_5_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEY_5",0,0)
  result = (int)(int)KEY_5;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEY_6_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEY_6",0,0)
  result = (int)(int)KEY_6;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEY_7_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEY_7",0,0)
  result = (int)(int)KEY_7;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEY_8_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEY_8",0,0)
  result = (int)(int)KEY_8;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEY_9_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEY_9",0,0)
  result = (int)(int)KEY_9;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEY_CAPS_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEY_CAPS",0,0)
  result = (int)(int)KEY_CAPS;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEY_SCROLL_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEY_SCROLL",0,0)
  result = (int)(int)KEY_SCROLL;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEY_NUM_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEY_NUM",0,0)
  result = (int)(int)KEY_NUM;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEY_PRINTSCREEN_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEY_PRINTSCREEN",0,0)
  result = (int)(int)KEY_PRINTSCREEN;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEY_PAUSE_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEY_PAUSE",0,0)
  result = (int)(int)KEY_PAUSE;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEY_A_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEY_A",0,0)
  result = (int)(int)KEY_A;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEY_B_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEY_B",0,0)
  result = (int)(int)KEY_B;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEY_C_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEY_C",0,0)
  result = (int)(int)KEY_C;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEY_D_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEY_D",0,0)
  result = (int)(int)KEY_D;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEY_E_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEY_E",0,0)
  result = (int)(int)KEY_E;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEY_F_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEY_F",0,0)
  result = (int)(int)KEY_F;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEY_G_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEY_G",0,0)
  result = (int)(int)KEY_G;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEY_H_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEY_H",0,0)
  result = (int)(int)KEY_H;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEY_I_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEY_I",0,0)
  result = (int)(int)KEY_I;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEY_J_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEY_J",0,0)
  result = (int)(int)KEY_J;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEY_K_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEY_K",0,0)
  result = (int)(int)KEY_K;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEY_L_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEY_L",0,0)
  result = (int)(int)KEY_L;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEY_M_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEY_M",0,0)
  result = (int)(int)KEY_M;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEY_N_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEY_N",0,0)
  result = (int)(int)KEY_N;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEY_O_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEY_O",0,0)
  result = (int)(int)KEY_O;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEY_P_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEY_P",0,0)
  result = (int)(int)KEY_P;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEY_Q_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEY_Q",0,0)
  result = (int)(int)KEY_Q;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEY_R_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEY_R",0,0)
  result = (int)(int)KEY_R;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEY_S_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEY_S",0,0)
  result = (int)(int)KEY_S;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEY_T_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEY_T",0,0)
  result = (int)(int)KEY_T;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEY_U_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEY_U",0,0)
  result = (int)(int)KEY_U;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEY_V_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEY_V",0,0)
  result = (int)(int)KEY_V;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEY_W_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEY_W",0,0)
  result = (int)(int)KEY_W;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEY_X_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEY_X",0,0)
  result = (int)(int)KEY_X;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEY_Y_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEY_Y",0,0)
  result = (int)(int)KEY_Y;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEY_Z_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEY_Z",0,0)
  result = (int)(int)KEY_Z;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEYPAD_SLASH_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEYPAD_SLASH",0,0)
  result = (int)(int)KEYPAD_SLASH;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEYPAD_MUL_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEYPAD_MUL",0,0)
  result = (int)(int)KEYPAD_MUL;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEYPAD_MINUS_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEYPAD_MINUS",0,0)
  result = (int)(int)KEYPAD_MINUS;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEYPAD_PLUS_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEYPAD_PLUS",0,0)
  result = (int)(int)KEYPAD_PLUS;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEYPAD_ENTER_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEYPAD_ENTER",0,0)
  result = (int)(int)KEYPAD_ENTER;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEYPAD_PERIOD_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEYPAD_PERIOD",0,0)
  result = (int)(int)KEYPAD_PERIOD;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEYPAD_DEL_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEYPAD_DEL",0,0)
  result = (int)(int)KEYPAD_DEL;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEYPAD_0_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEYPAD_0",0,0)
  result = (int)(int)KEYPAD_0;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEYPAD_INS_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEYPAD_INS",0,0)
  result = (int)(int)KEYPAD_INS;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEYPAD_1_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEYPAD_1",0,0)
  result = (int)(int)KEYPAD_1;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEYPAD_END_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEYPAD_END",0,0)
  result = (int)(int)KEYPAD_END;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEYPAD_2_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEYPAD_2",0,0)
  result = (int)(int)KEYPAD_2;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEYPAD_DOWN_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEYPAD_DOWN",0,0)
  result = (int)(int)KEYPAD_DOWN;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEYPAD_3_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEYPAD_3",0,0)
  result = (int)(int)KEYPAD_3;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEYPAD_PAGEDOWN_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEYPAD_PAGEDOWN",0,0)
  result = (int)(int)KEYPAD_PAGEDOWN;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEYPAD_4_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEYPAD_4",0,0)
  result = (int)(int)KEYPAD_4;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEYPAD_LEFT_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEYPAD_LEFT",0,0)
  result = (int)(int)KEYPAD_LEFT;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEYPAD_5_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEYPAD_5",0,0)
  result = (int)(int)KEYPAD_5;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEYPAD_6_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEYPAD_6",0,0)
  result = (int)(int)KEYPAD_6;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEYPAD_RIGHT_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEYPAD_RIGHT",0,0)
  result = (int)(int)KEYPAD_RIGHT;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEYPAD_7_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEYPAD_7",0,0)
  result = (int)(int)KEYPAD_7;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEYPAD_HOME_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEYPAD_HOME",0,0)
  result = (int)(int)KEYPAD_HOME;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEYPAD_8_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEYPAD_8",0,0)
  result = (int)(int)KEYPAD_8;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEYPAD_UP_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEYPAD_UP",0,0)
  result = (int)(int)KEYPAD_UP;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEYPAD_9_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEYPAD_9",0,0)
  result = (int)(int)KEYPAD_9;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEYPAD_PGAGEUP_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEYPAD_PGAGEUP",0,0)
  result = (int)(int)KEYPAD_PGAGEUP;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEY_F1_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEY_F1",0,0)
  result = (int)(int)KEY_F1;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEY_F2_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEY_F2",0,0)
  result = (int)(int)KEY_F2;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEY_F3_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEY_F3",0,0)
  result = (int)(int)KEY_F3;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEY_F4_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEY_F4",0,0)
  result = (int)(int)KEY_F4;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEY_F5_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEY_F5",0,0)
  result = (int)(int)KEY_F5;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEY_F6_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEY_F6",0,0)
  result = (int)(int)KEY_F6;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEY_F7_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEY_F7",0,0)
  result = (int)(int)KEY_F7;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEY_F8_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEY_F8",0,0)
  result = (int)(int)KEY_F8;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEY_F9_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEY_F9",0,0)
  result = (int)(int)KEY_F9;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEY_F10_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEY_F10",0,0)
  result = (int)(int)KEY_F10;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEY_F11_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEY_F11",0,0)
  result = (int)(int)KEY_F11;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEY_F12_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEY_F12",0,0)
  result = (int)(int)KEY_F12;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEY_EQUAL_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEY_EQUAL",0,0)
  result = (int)(int)KEY_EQUAL;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEY_LSQBRK_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEY_LSQBRK",0,0)
  result = (int)(int)KEY_LSQBRK;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEY_RSQBRK_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEY_RSQBRK",0,0)
  result = (int)(int)KEY_RSQBRK;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEY_SEMICL_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEY_SEMICL",0,0)
  result = (int)(int)KEY_SEMICL;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEY_APOSTR_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEY_APOSTR",0,0)
  result = (int)(int)KEY_APOSTR;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEY_BACKSL_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEY_BACKSL",0,0)
  result = (int)(int)KEY_BACKSL;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEY_SLASH_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEY_SLASH",0,0)
  result = (int)(int)KEY_SLASH;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEY_DE_SS_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEY_DE_SS",0,0)
  result = (int)(int)KEY_DE_SS;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEY_DE_ACCENT_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEY_DE_ACCENT",0,0)
  result = (int)(int)KEY_DE_ACCENT;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEY_DE_UE_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEY_DE_UE",0,0)
  result = (int)(int)KEY_DE_UE;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEY_DE_PLUS_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEY_DE_PLUS",0,0)
  result = (int)(int)KEY_DE_PLUS;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEY_DE_OE_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEY_DE_OE",0,0)
  result = (int)(int)KEY_DE_OE;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEY_DE_AE_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEY_DE_AE",0,0)
  result = (int)(int)KEY_DE_AE;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEY_DE_HASH_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEY_DE_HASH",0,0)
  result = (int)(int)KEY_DE_HASH;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEY_DE_LT_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEY_DE_LT",0,0)
  result = (int)(int)KEY_DE_LT;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEY_DE_CIRC_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEY_DE_CIRC",0,0)
  result = (int)(int)KEY_DE_CIRC;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEY_FR_UGRAVE_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEY_FR_UGRAVE",0,0)
  result = (int)(int)KEY_FR_UGRAVE;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEY_FR_MULTIPLY_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEY_FR_MULTIPLY",0,0)
  result = (int)(int)KEY_FR_MULTIPLY;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEY_FR_COMMA_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEY_FR_COMMA",0,0)
  result = (int)(int)KEY_FR_COMMA;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEY_FR_SEMICL_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEY_FR_SEMICL",0,0)
  result = (int)(int)KEY_FR_SEMICL;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEY_FR_COLON_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEY_FR_COLON",0,0)
  result = (int)(int)KEY_FR_COLON;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEY_FR_SS_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEY_FR_SS",0,0)
  result = (int)(int)KEY_FR_SS;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEY_FR_RBRACKET_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEY_FR_RBRACKET",0,0)
  result = (int)(int)KEY_FR_RBRACKET;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEY_FR_EQUAL_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEY_FR_EQUAL",0,0)
  result = (int)(int)KEY_FR_EQUAL;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KEY_FR_DOLL_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("KEY_FR_DOLL",0,0)
  result = (int)(int)KEY_FR_DOLL;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BUTTON_LEFT_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("BUTTON_LEFT",0,0)
  result = (int)(int)BUTTON_LEFT;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BUTTON_MIDDLE_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("BUTTON_MIDDLE",0,0)
  result = (int)(int)BUTTON_MIDDLE;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BUTTON_RIGHT_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("BUTTON_RIGHT",0,0)
  result = (int)(int)BUTTON_RIGHT;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_VScriptInput_wrapper(lua_State* L) {
  int SWIG_arg = 0;
  VScriptInput_wrapper *result = 0 ;
  
  SWIG_check_num_args("VScriptInput_wrapper",0,0)
  result = (VScriptInput_wrapper *)new VScriptInput_wrapper();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_VScriptInput_wrapper,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VScriptInput_wrapper_IsKeyPressed(lua_State* L) {
  int SWIG_arg = 0;
  VScriptInput_wrapper *arg1 = (VScriptInput_wrapper *) 0 ;
  int arg2 ;
  bool result;
  
  SWIG_check_num_args("IsKeyPressed",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("IsKeyPressed",1,"VScriptInput_wrapper *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("IsKeyPressed",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VScriptInput_wrapper,0))){
    SWIG_fail_ptr("VScriptInput_wrapper_IsKeyPressed",1,SWIGTYPE_p_VScriptInput_wrapper);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  result = (bool)(arg1)->IsKeyPressed(arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VScriptInput_wrapper_SetKeyAsSingleHit__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  VScriptInput_wrapper *arg1 = (VScriptInput_wrapper *) 0 ;
  int arg2 ;
  bool arg3 ;
  bool result;
  
  SWIG_check_num_args("SetKeyAsSingleHit",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetKeyAsSingleHit",1,"VScriptInput_wrapper *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SetKeyAsSingleHit",2,"int");
  if(!lua_isboolean(L,3)) SWIG_fail_arg("SetKeyAsSingleHit",3,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VScriptInput_wrapper,0))){
    SWIG_fail_ptr("VScriptInput_wrapper_SetKeyAsSingleHit",1,SWIGTYPE_p_VScriptInput_wrapper);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (lua_toboolean(L, 3)!=0);
  result = (bool)(arg1)->SetKeyAsSingleHit(arg2,arg3);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VScriptInput_wrapper_SetKeyAsSingleHit__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  VScriptInput_wrapper *arg1 = (VScriptInput_wrapper *) 0 ;
  int arg2 ;
  bool result;
  
  SWIG_check_num_args("SetKeyAsSingleHit",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetKeyAsSingleHit",1,"VScriptInput_wrapper *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SetKeyAsSingleHit",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VScriptInput_wrapper,0))){
    SWIG_fail_ptr("VScriptInput_wrapper_SetKeyAsSingleHit",1,SWIGTYPE_p_VScriptInput_wrapper);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  result = (bool)(arg1)->SetKeyAsSingleHit(arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VScriptInput_wrapper_SetKeyAsSingleHit(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VScriptInput_wrapper, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_VScriptInput_wrapper_SetKeyAsSingleHit__SWIG_1(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VScriptInput_wrapper, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isboolean(L,argv[2]);
        }
        if (_v) {
          return _wrap_VScriptInput_wrapper_SetKeyAsSingleHit__SWIG_0(L);
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'VScriptInput_wrapper_SetKeyAsSingleHit'\n"
    "  Possible C/C++ prototypes are:\n"
    "    SetKeyAsSingleHit(VScriptInput_wrapper *,int,bool)\n"
    "    SetKeyAsSingleHit(VScriptInput_wrapper *,int)\n");
  lua_error(L);return 0;
}


static int _wrap_VScriptInput_wrapper_SetMousePosition(lua_State* L) {
  int SWIG_arg = 0;
  VScriptInput_wrapper *arg1 = (VScriptInput_wrapper *) 0 ;
  float arg2 ;
  float arg3 ;
  bool result;
  
  SWIG_check_num_args("SetMousePosition",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetMousePosition",1,"VScriptInput_wrapper *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SetMousePosition",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("SetMousePosition",3,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VScriptInput_wrapper,0))){
    SWIG_fail_ptr("VScriptInput_wrapper_SetMousePosition",1,SWIGTYPE_p_VScriptInput_wrapper);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  result = (bool)(arg1)->SetMousePosition(arg2,arg3);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VScriptInput_wrapper_IsMouseButtonPressed(lua_State* L) {
  int SWIG_arg = 0;
  VScriptInput_wrapper *arg1 = (VScriptInput_wrapper *) 0 ;
  int arg2 ;
  bool result;
  
  SWIG_check_num_args("IsMouseButtonPressed",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("IsMouseButtonPressed",1,"VScriptInput_wrapper *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("IsMouseButtonPressed",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VScriptInput_wrapper,0))){
    SWIG_fail_ptr("VScriptInput_wrapper_IsMouseButtonPressed",1,SWIGTYPE_p_VScriptInput_wrapper);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  result = (bool)(arg1)->IsMouseButtonPressed(arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VScriptInput_wrapper_GetMouseWheelDelta__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  VScriptInput_wrapper *arg1 = (VScriptInput_wrapper *) 0 ;
  bool arg2 ;
  float result;
  
  SWIG_check_num_args("GetMouseWheelDelta",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetMouseWheelDelta",1,"VScriptInput_wrapper *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("GetMouseWheelDelta",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VScriptInput_wrapper,0))){
    SWIG_fail_ptr("VScriptInput_wrapper_GetMouseWheelDelta",1,SWIGTYPE_p_VScriptInput_wrapper);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  result = (float)(arg1)->GetMouseWheelDelta(arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VScriptInput_wrapper_GetMouseWheelDelta__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  VScriptInput_wrapper *arg1 = (VScriptInput_wrapper *) 0 ;
  float result;
  
  SWIG_check_num_args("GetMouseWheelDelta",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetMouseWheelDelta",1,"VScriptInput_wrapper *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VScriptInput_wrapper,0))){
    SWIG_fail_ptr("VScriptInput_wrapper_GetMouseWheelDelta",1,SWIGTYPE_p_VScriptInput_wrapper);
  }
  
  result = (float)(arg1)->GetMouseWheelDelta();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VScriptInput_wrapper_GetMouseWheelDelta(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VScriptInput_wrapper, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_VScriptInput_wrapper_GetMouseWheelDelta__SWIG_1(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VScriptInput_wrapper, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isboolean(L,argv[1]);
      }
      if (_v) {
        return _wrap_VScriptInput_wrapper_GetMouseWheelDelta__SWIG_0(L);
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'VScriptInput_wrapper_GetMouseWheelDelta'\n"
    "  Possible C/C++ prototypes are:\n"
    "    GetMouseWheelDelta(VScriptInput_wrapper *,bool)\n"
    "    GetMouseWheelDelta(VScriptInput_wrapper *)\n");
  lua_error(L);return 0;
}


static int _wrap_VScriptInput_wrapper_CreateMap__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  VScriptInput_wrapper *arg1 = (VScriptInput_wrapper *) 0 ;
  char *arg2 = (char *) 0 ;
  int arg3 ;
  int arg4 ;
  VStringInputMap *result = 0 ;
  
  SWIG_check_num_args("CreateMap",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("CreateMap",1,"VScriptInput_wrapper *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("CreateMap",2,"char const *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("CreateMap",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("CreateMap",4,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VScriptInput_wrapper,0))){
    SWIG_fail_ptr("VScriptInput_wrapper_CreateMap",1,SWIGTYPE_p_VScriptInput_wrapper);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  arg3 = (int)lua_tonumber(L, 3);
  arg4 = (int)lua_tonumber(L, 4);
  result = (VStringInputMap *)(arg1)->CreateMap((char const *)arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_VStringInputMap,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VScriptInput_wrapper_CreateMap__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  VScriptInput_wrapper *arg1 = (VScriptInput_wrapper *) 0 ;
  char *arg2 = (char *) 0 ;
  int arg3 ;
  VStringInputMap *result = 0 ;
  
  SWIG_check_num_args("CreateMap",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("CreateMap",1,"VScriptInput_wrapper *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("CreateMap",2,"char const *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("CreateMap",3,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VScriptInput_wrapper,0))){
    SWIG_fail_ptr("VScriptInput_wrapper_CreateMap",1,SWIGTYPE_p_VScriptInput_wrapper);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  arg3 = (int)lua_tonumber(L, 3);
  result = (VStringInputMap *)(arg1)->CreateMap((char const *)arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_VStringInputMap,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VScriptInput_wrapper_CreateMap__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  VScriptInput_wrapper *arg1 = (VScriptInput_wrapper *) 0 ;
  char *arg2 = (char *) 0 ;
  VStringInputMap *result = 0 ;
  
  SWIG_check_num_args("CreateMap",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("CreateMap",1,"VScriptInput_wrapper *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("CreateMap",2,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VScriptInput_wrapper,0))){
    SWIG_fail_ptr("VScriptInput_wrapper_CreateMap",1,SWIGTYPE_p_VScriptInput_wrapper);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  result = (VStringInputMap *)(arg1)->CreateMap((char const *)arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_VStringInputMap,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VScriptInput_wrapper_CreateMap(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VScriptInput_wrapper, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = SWIG_lua_isnilstring(L,argv[1]);
      }
      if (_v) {
        return _wrap_VScriptInput_wrapper_CreateMap__SWIG_2(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VScriptInput_wrapper, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = SWIG_lua_isnilstring(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          return _wrap_VScriptInput_wrapper_CreateMap__SWIG_1(L);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VScriptInput_wrapper, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = SWIG_lua_isnilstring(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_VScriptInput_wrapper_CreateMap__SWIG_0(L);
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'VScriptInput_wrapper_CreateMap'\n"
    "  Possible C/C++ prototypes are:\n"
    "    CreateMap(VScriptInput_wrapper *,char const *,int,int)\n"
    "    CreateMap(VScriptInput_wrapper *,char const *,int)\n"
    "    CreateMap(VScriptInput_wrapper *,char const *)\n");
  lua_error(L);return 0;
}


static int _wrap_VScriptInput_wrapper_GetMap(lua_State* L) {
  int SWIG_arg = 0;
  VScriptInput_wrapper *arg1 = (VScriptInput_wrapper *) 0 ;
  char *arg2 = (char *) 0 ;
  VStringInputMap *result = 0 ;
  
  SWIG_check_num_args("GetMap",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetMap",1,"VScriptInput_wrapper *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("GetMap",2,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VScriptInput_wrapper,0))){
    SWIG_fail_ptr("VScriptInput_wrapper_GetMap",1,SWIGTYPE_p_VScriptInput_wrapper);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  result = (VStringInputMap *)(arg1)->GetMap((char const *)arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_VStringInputMap,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VScriptInput_wrapper_DestroyMap(lua_State* L) {
  int SWIG_arg = 0;
  VScriptInput_wrapper *arg1 = (VScriptInput_wrapper *) 0 ;
  VStringInputMap *arg2 = (VStringInputMap *) 0 ;
  
  SWIG_check_num_args("DestroyMap",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("DestroyMap",1,"VScriptInput_wrapper *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("DestroyMap",2,"VStringInputMap *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VScriptInput_wrapper,0))){
    SWIG_fail_ptr("VScriptInput_wrapper_DestroyMap",1,SWIGTYPE_p_VScriptInput_wrapper);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_VStringInputMap,0))){
    SWIG_fail_ptr("VScriptInput_wrapper_DestroyMap",2,SWIGTYPE_p_VStringInputMap);
  }
  
  (arg1)->DestroyMap(arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VScriptInput_wrapper_CreateVirtualThumbStick(lua_State* L) {
  int SWIG_arg = 0;
  VScriptInput_wrapper *arg1 = (VScriptInput_wrapper *) 0 ;
  
  SWIG_check_num_args("CreateVirtualThumbStick",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("CreateVirtualThumbStick",1,"VScriptInput_wrapper *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VScriptInput_wrapper,0))){
    SWIG_fail_ptr("VScriptInput_wrapper_CreateVirtualThumbStick",1,SWIGTYPE_p_VScriptInput_wrapper);
  }
  
  (arg1)->CreateVirtualThumbStick();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VScriptInput_wrapper_DestroyVirtualThumbStick(lua_State* L) {
  int SWIG_arg = 0;
  VScriptInput_wrapper *arg1 = (VScriptInput_wrapper *) 0 ;
  
  SWIG_check_num_args("DestroyVirtualThumbStick",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("DestroyVirtualThumbStick",1,"VScriptInput_wrapper *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VScriptInput_wrapper,0))){
    SWIG_fail_ptr("VScriptInput_wrapper_DestroyVirtualThumbStick",1,SWIGTYPE_p_VScriptInput_wrapper);
  }
  
  (arg1)->DestroyVirtualThumbStick();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_VScriptInput_wrapper(void *obj) {
VScriptInput_wrapper *arg1 = (VScriptInput_wrapper *) obj;
delete arg1;
}
static swig_lua_method swig_VScriptInput_wrapper_methods[] = {
    { "GetMousePosition",VScriptInput_wrapper_GetMousePosition},
    { "GetMouseDelta",VScriptInput_wrapper_GetMouseDelta},
    {"IsKeyPressed", _wrap_VScriptInput_wrapper_IsKeyPressed}, 
    {"SetKeyAsSingleHit", _wrap_VScriptInput_wrapper_SetKeyAsSingleHit}, 
    {"SetMousePosition", _wrap_VScriptInput_wrapper_SetMousePosition}, 
    {"IsMouseButtonPressed", _wrap_VScriptInput_wrapper_IsMouseButtonPressed}, 
    {"GetMouseWheelDelta", _wrap_VScriptInput_wrapper_GetMouseWheelDelta}, 
    {"CreateMap", _wrap_VScriptInput_wrapper_CreateMap}, 
    {"GetMap", _wrap_VScriptInput_wrapper_GetMap}, 
    {"DestroyMap", _wrap_VScriptInput_wrapper_DestroyMap}, 
    {"CreateVirtualThumbStick", _wrap_VScriptInput_wrapper_CreateVirtualThumbStick}, 
    {"DestroyVirtualThumbStick", _wrap_VScriptInput_wrapper_DestroyVirtualThumbStick}, 
    {0,0}
};
static swig_lua_attribute swig_VScriptInput_wrapper_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_VScriptInput_wrapper_bases[] = {0};
static const char *swig_VScriptInput_wrapper_base_names[] = {0};
static swig_lua_class _wrap_class_VScriptInput_wrapper = { "VScriptInput_wrapper", &SWIGTYPE_p_VScriptInput_wrapper,_wrap_new_VScriptInput_wrapper, swig_delete_VScriptInput_wrapper, swig_VScriptInput_wrapper_methods, swig_VScriptInput_wrapper_attributes, swig_VScriptInput_wrapper_bases, swig_VScriptInput_wrapper_base_names };

static int _wrap_new_VScriptUtil_wrapper(lua_State* L) {
  int SWIG_arg = 0;
  VScriptUtil_wrapper *result = 0 ;
  
  SWIG_check_num_args("VScriptUtil_wrapper",0,0)
  result = (VScriptUtil_wrapper *)new VScriptUtil_wrapper();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_VScriptUtil_wrapper,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VScriptUtil_wrapper_GetRandInt__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  VScriptUtil_wrapper *arg1 = (VScriptUtil_wrapper *) 0 ;
  int arg2 ;
  int result;
  
  SWIG_check_num_args("GetRandInt",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetRandInt",1,"VScriptUtil_wrapper *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("GetRandInt",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VScriptUtil_wrapper,0))){
    SWIG_fail_ptr("VScriptUtil_wrapper_GetRandInt",1,SWIGTYPE_p_VScriptUtil_wrapper);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  result = (int)(arg1)->GetRandInt(arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VScriptUtil_wrapper_GetRandInt__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  VScriptUtil_wrapper *arg1 = (VScriptUtil_wrapper *) 0 ;
  int result;
  
  SWIG_check_num_args("GetRandInt",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetRandInt",1,"VScriptUtil_wrapper *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VScriptUtil_wrapper,0))){
    SWIG_fail_ptr("VScriptUtil_wrapper_GetRandInt",1,SWIGTYPE_p_VScriptUtil_wrapper);
  }
  
  result = (int)(arg1)->GetRandInt();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VScriptUtil_wrapper_GetRandInt(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VScriptUtil_wrapper, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_VScriptUtil_wrapper_GetRandInt__SWIG_1(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VScriptUtil_wrapper, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_VScriptUtil_wrapper_GetRandInt__SWIG_0(L);
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'VScriptUtil_wrapper_GetRandInt'\n"
    "  Possible C/C++ prototypes are:\n"
    "    GetRandInt(VScriptUtil_wrapper *,int)\n"
    "    GetRandInt(VScriptUtil_wrapper *)\n");
  lua_error(L);return 0;
}


static int _wrap_VScriptUtil_wrapper_GetRandIntSym__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  VScriptUtil_wrapper *arg1 = (VScriptUtil_wrapper *) 0 ;
  int arg2 ;
  int result;
  
  SWIG_check_num_args("GetRandIntSym",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetRandIntSym",1,"VScriptUtil_wrapper *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("GetRandIntSym",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VScriptUtil_wrapper,0))){
    SWIG_fail_ptr("VScriptUtil_wrapper_GetRandIntSym",1,SWIGTYPE_p_VScriptUtil_wrapper);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  result = (int)(arg1)->GetRandIntSym(arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VScriptUtil_wrapper_GetRandIntSym__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  VScriptUtil_wrapper *arg1 = (VScriptUtil_wrapper *) 0 ;
  int result;
  
  SWIG_check_num_args("GetRandIntSym",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetRandIntSym",1,"VScriptUtil_wrapper *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VScriptUtil_wrapper,0))){
    SWIG_fail_ptr("VScriptUtil_wrapper_GetRandIntSym",1,SWIGTYPE_p_VScriptUtil_wrapper);
  }
  
  result = (int)(arg1)->GetRandIntSym();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VScriptUtil_wrapper_GetRandIntSym(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VScriptUtil_wrapper, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_VScriptUtil_wrapper_GetRandIntSym__SWIG_1(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VScriptUtil_wrapper, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_VScriptUtil_wrapper_GetRandIntSym__SWIG_0(L);
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'VScriptUtil_wrapper_GetRandIntSym'\n"
    "  Possible C/C++ prototypes are:\n"
    "    GetRandIntSym(VScriptUtil_wrapper *,int)\n"
    "    GetRandIntSym(VScriptUtil_wrapper *)\n");
  lua_error(L);return 0;
}


static int _wrap_VScriptUtil_wrapper_GetRandFloat__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  VScriptUtil_wrapper *arg1 = (VScriptUtil_wrapper *) 0 ;
  float arg2 ;
  float result;
  
  SWIG_check_num_args("GetRandFloat",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetRandFloat",1,"VScriptUtil_wrapper *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("GetRandFloat",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VScriptUtil_wrapper,0))){
    SWIG_fail_ptr("VScriptUtil_wrapper_GetRandFloat",1,SWIGTYPE_p_VScriptUtil_wrapper);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  result = (float)(arg1)->GetRandFloat(arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VScriptUtil_wrapper_GetRandFloat__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  VScriptUtil_wrapper *arg1 = (VScriptUtil_wrapper *) 0 ;
  float result;
  
  SWIG_check_num_args("GetRandFloat",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetRandFloat",1,"VScriptUtil_wrapper *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VScriptUtil_wrapper,0))){
    SWIG_fail_ptr("VScriptUtil_wrapper_GetRandFloat",1,SWIGTYPE_p_VScriptUtil_wrapper);
  }
  
  result = (float)(arg1)->GetRandFloat();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VScriptUtil_wrapper_GetRandFloat(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VScriptUtil_wrapper, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_VScriptUtil_wrapper_GetRandFloat__SWIG_1(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VScriptUtil_wrapper, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_VScriptUtil_wrapper_GetRandFloat__SWIG_0(L);
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'VScriptUtil_wrapper_GetRandFloat'\n"
    "  Possible C/C++ prototypes are:\n"
    "    GetRandFloat(VScriptUtil_wrapper *,float)\n"
    "    GetRandFloat(VScriptUtil_wrapper *)\n");
  lua_error(L);return 0;
}


static int _wrap_VScriptUtil_wrapper_GetRandFloatSym__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  VScriptUtil_wrapper *arg1 = (VScriptUtil_wrapper *) 0 ;
  float arg2 ;
  float result;
  
  SWIG_check_num_args("GetRandFloatSym",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetRandFloatSym",1,"VScriptUtil_wrapper *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("GetRandFloatSym",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VScriptUtil_wrapper,0))){
    SWIG_fail_ptr("VScriptUtil_wrapper_GetRandFloatSym",1,SWIGTYPE_p_VScriptUtil_wrapper);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  result = (float)(arg1)->GetRandFloatSym(arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VScriptUtil_wrapper_GetRandFloatSym__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  VScriptUtil_wrapper *arg1 = (VScriptUtil_wrapper *) 0 ;
  float result;
  
  SWIG_check_num_args("GetRandFloatSym",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetRandFloatSym",1,"VScriptUtil_wrapper *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VScriptUtil_wrapper,0))){
    SWIG_fail_ptr("VScriptUtil_wrapper_GetRandFloatSym",1,SWIGTYPE_p_VScriptUtil_wrapper);
  }
  
  result = (float)(arg1)->GetRandFloatSym();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VScriptUtil_wrapper_GetRandFloatSym(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VScriptUtil_wrapper, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_VScriptUtil_wrapper_GetRandFloatSym__SWIG_1(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VScriptUtil_wrapper, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_VScriptUtil_wrapper_GetRandFloatSym__SWIG_0(L);
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'VScriptUtil_wrapper_GetRandFloatSym'\n"
    "  Possible C/C++ prototypes are:\n"
    "    GetRandFloatSym(VScriptUtil_wrapper *,float)\n"
    "    GetRandFloatSym(VScriptUtil_wrapper *)\n");
  lua_error(L);return 0;
}


static int _wrap_VScriptUtil_wrapper_GetRandVector(lua_State* L) {
  int SWIG_arg = 0;
  VScriptUtil_wrapper *arg1 = (VScriptUtil_wrapper *) 0 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  SwigValueWrapper< hkvVec3 > result;
  
  SWIG_check_num_args("GetRandVector",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetRandVector",1,"VScriptUtil_wrapper *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("GetRandVector",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("GetRandVector",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("GetRandVector",4,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VScriptUtil_wrapper,0))){
    SWIG_fail_ptr("VScriptUtil_wrapper_GetRandVector",1,SWIGTYPE_p_VScriptUtil_wrapper);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4);
  result = (arg1)->GetRandVector(arg2,arg3,arg4);
  {
    hkvVec3 * resultptr = new hkvVec3((const hkvVec3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_hkvVec3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VScriptUtil_wrapper_GetRandVectorSym(lua_State* L) {
  int SWIG_arg = 0;
  VScriptUtil_wrapper *arg1 = (VScriptUtil_wrapper *) 0 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  SwigValueWrapper< hkvVec3 > result;
  
  SWIG_check_num_args("GetRandVectorSym",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetRandVectorSym",1,"VScriptUtil_wrapper *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("GetRandVectorSym",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("GetRandVectorSym",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("GetRandVectorSym",4,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VScriptUtil_wrapper,0))){
    SWIG_fail_ptr("VScriptUtil_wrapper_GetRandVectorSym",1,SWIGTYPE_p_VScriptUtil_wrapper);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4);
  result = (arg1)->GetRandVectorSym(arg2,arg3,arg4);
  {
    hkvVec3 * resultptr = new hkvVec3((const hkvVec3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_hkvVec3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VScriptUtil_wrapper_Round__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  VScriptUtil_wrapper *arg1 = (VScriptUtil_wrapper *) 0 ;
  float arg2 ;
  int result;
  
  SWIG_check_num_args("Round",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Round",1,"VScriptUtil_wrapper *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Round",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VScriptUtil_wrapper,0))){
    SWIG_fail_ptr("VScriptUtil_wrapper_Round",1,SWIGTYPE_p_VScriptUtil_wrapper);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  result = (int)(arg1)->Round(arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VScriptUtil_wrapper_Round__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  VScriptUtil_wrapper *arg1 = (VScriptUtil_wrapper *) 0 ;
  float arg2 ;
  int arg3 ;
  float result;
  
  SWIG_check_num_args("Round",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Round",1,"VScriptUtil_wrapper *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Round",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Round",3,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VScriptUtil_wrapper,0))){
    SWIG_fail_ptr("VScriptUtil_wrapper_Round",1,SWIGTYPE_p_VScriptUtil_wrapper);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (int)lua_tonumber(L, 3);
  result = (float)(arg1)->Round(arg2,arg3);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VScriptUtil_wrapper_Round(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VScriptUtil_wrapper, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_VScriptUtil_wrapper_Round__SWIG_0(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VScriptUtil_wrapper, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          return _wrap_VScriptUtil_wrapper_Round__SWIG_1(L);
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'VScriptUtil_wrapper_Round'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Round(VScriptUtil_wrapper *,float)\n"
    "    Round(VScriptUtil_wrapper *,float,int)\n");
  lua_error(L);return 0;
}


static int _wrap_VScriptUtil_wrapper_RadToDeg(lua_State* L) {
  int SWIG_arg = 0;
  VScriptUtil_wrapper *arg1 = (VScriptUtil_wrapper *) 0 ;
  float arg2 ;
  float result;
  
  SWIG_check_num_args("RadToDeg",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("RadToDeg",1,"VScriptUtil_wrapper *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("RadToDeg",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VScriptUtil_wrapper,0))){
    SWIG_fail_ptr("VScriptUtil_wrapper_RadToDeg",1,SWIGTYPE_p_VScriptUtil_wrapper);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  result = (float)(arg1)->RadToDeg(arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VScriptUtil_wrapper_DegToRad(lua_State* L) {
  int SWIG_arg = 0;
  VScriptUtil_wrapper *arg1 = (VScriptUtil_wrapper *) 0 ;
  float arg2 ;
  float result;
  
  SWIG_check_num_args("DegToRad",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("DegToRad",1,"VScriptUtil_wrapper *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("DegToRad",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VScriptUtil_wrapper,0))){
    SWIG_fail_ptr("VScriptUtil_wrapper_DegToRad",1,SWIGTYPE_p_VScriptUtil_wrapper);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  result = (float)(arg1)->DegToRad(arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VScriptUtil_wrapper_AngleBetweenVectors(lua_State* L) {
  int SWIG_arg = 0;
  VScriptUtil_wrapper *arg1 = (VScriptUtil_wrapper *) 0 ;
  hkvVec3 *arg2 = 0 ;
  hkvVec3 *arg3 = 0 ;
  float result;
  
  SWIG_check_num_args("AngleBetweenVectors",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("AngleBetweenVectors",1,"VScriptUtil_wrapper *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("AngleBetweenVectors",2,"hkvVec3 const &");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("AngleBetweenVectors",3,"hkvVec3 const &");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VScriptUtil_wrapper,0))){
    SWIG_fail_ptr("VScriptUtil_wrapper_AngleBetweenVectors",1,SWIGTYPE_p_VScriptUtil_wrapper);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("VScriptUtil_wrapper_AngleBetweenVectors",2,SWIGTYPE_p_hkvVec3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("VScriptUtil_wrapper_AngleBetweenVectors",3,SWIGTYPE_p_hkvVec3);
  }
  
  result = (float)(arg1)->AngleBetweenVectors((hkvVec3 const &)*arg2,(hkvVec3 const &)*arg3);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VScriptUtil_wrapper_CreateLookAtMatrix__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  VScriptUtil_wrapper *arg1 = (VScriptUtil_wrapper *) 0 ;
  hkvVec3 *arg2 = (hkvVec3 *) 0 ;
  hkvVec3 *arg3 = (hkvVec3 *) 0 ;
  hkvVec3 *arg4 = (hkvVec3 *) 0 ;
  SwigValueWrapper< hkvMat3 > result;
  
  SWIG_check_num_args("CreateLookAtMatrix",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("CreateLookAtMatrix",1,"VScriptUtil_wrapper *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("CreateLookAtMatrix",2,"hkvVec3 const *");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("CreateLookAtMatrix",3,"hkvVec3 const *");
  if(!SWIG_isptrtype(L,4)) SWIG_fail_arg("CreateLookAtMatrix",4,"hkvVec3 const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VScriptUtil_wrapper,0))){
    SWIG_fail_ptr("VScriptUtil_wrapper_CreateLookAtMatrix",1,SWIGTYPE_p_VScriptUtil_wrapper);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("VScriptUtil_wrapper_CreateLookAtMatrix",2,SWIGTYPE_p_hkvVec3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("VScriptUtil_wrapper_CreateLookAtMatrix",3,SWIGTYPE_p_hkvVec3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("VScriptUtil_wrapper_CreateLookAtMatrix",4,SWIGTYPE_p_hkvVec3);
  }
  
  result = (arg1)->CreateLookAtMatrix((hkvVec3 const *)arg2,(hkvVec3 const *)arg3,(hkvVec3 const *)arg4);
  {
    hkvMat3 * resultptr = new hkvMat3((const hkvMat3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_hkvMat3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VScriptUtil_wrapper_CreateLookAtMatrix__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  VScriptUtil_wrapper *arg1 = (VScriptUtil_wrapper *) 0 ;
  hkvVec3 *arg2 = (hkvVec3 *) 0 ;
  hkvVec3 *arg3 = (hkvVec3 *) 0 ;
  SwigValueWrapper< hkvMat3 > result;
  
  SWIG_check_num_args("CreateLookAtMatrix",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("CreateLookAtMatrix",1,"VScriptUtil_wrapper *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("CreateLookAtMatrix",2,"hkvVec3 const *");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("CreateLookAtMatrix",3,"hkvVec3 const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VScriptUtil_wrapper,0))){
    SWIG_fail_ptr("VScriptUtil_wrapper_CreateLookAtMatrix",1,SWIGTYPE_p_VScriptUtil_wrapper);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("VScriptUtil_wrapper_CreateLookAtMatrix",2,SWIGTYPE_p_hkvVec3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_hkvVec3,0))){
    SWIG_fail_ptr("VScriptUtil_wrapper_CreateLookAtMatrix",3,SWIGTYPE_p_hkvVec3);
  }
  
  result = (arg1)->CreateLookAtMatrix((hkvVec3 const *)arg2,(hkvVec3 const *)arg3);
  {
    hkvMat3 * resultptr = new hkvMat3((const hkvMat3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_hkvMat3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VScriptUtil_wrapper_CreateLookAtMatrix(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VScriptUtil_wrapper, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_hkvVec3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          void *ptr;
          if (SWIG_isptrtype(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_hkvVec3, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          return _wrap_VScriptUtil_wrapper_CreateLookAtMatrix__SWIG_1(L);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VScriptUtil_wrapper, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_hkvVec3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          void *ptr;
          if (SWIG_isptrtype(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_hkvVec3, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          {
            void *ptr;
            if (SWIG_isptrtype(L,argv[3])==0 || SWIG_ConvertPtr(L,argv[3], (void **) &ptr, SWIGTYPE_p_hkvVec3, 0)) {
              _v = 0;
            } else {
              _v = 1;
            }
          }
          if (_v) {
            return _wrap_VScriptUtil_wrapper_CreateLookAtMatrix__SWIG_0(L);
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'VScriptUtil_wrapper_CreateLookAtMatrix'\n"
    "  Possible C/C++ prototypes are:\n"
    "    CreateLookAtMatrix(VScriptUtil_wrapper *,hkvVec3 const *,hkvVec3 const *,hkvVec3 const *)\n"
    "    CreateLookAtMatrix(VScriptUtil_wrapper *,hkvVec3 const *,hkvVec3 const *)\n");
  lua_error(L);return 0;
}


static void swig_delete_VScriptUtil_wrapper(void *obj) {
VScriptUtil_wrapper *arg1 = (VScriptUtil_wrapper *) obj;
delete arg1;
}
static swig_lua_method swig_VScriptUtil_wrapper_methods[] = {
    {"GetRandInt", _wrap_VScriptUtil_wrapper_GetRandInt}, 
    {"GetRandIntSym", _wrap_VScriptUtil_wrapper_GetRandIntSym}, 
    {"GetRandFloat", _wrap_VScriptUtil_wrapper_GetRandFloat}, 
    {"GetRandFloatSym", _wrap_VScriptUtil_wrapper_GetRandFloatSym}, 
    {"GetRandVector", _wrap_VScriptUtil_wrapper_GetRandVector}, 
    {"GetRandVectorSym", _wrap_VScriptUtil_wrapper_GetRandVectorSym}, 
    {"Round", _wrap_VScriptUtil_wrapper_Round}, 
    {"RadToDeg", _wrap_VScriptUtil_wrapper_RadToDeg}, 
    {"DegToRad", _wrap_VScriptUtil_wrapper_DegToRad}, 
    {"AngleBetweenVectors", _wrap_VScriptUtil_wrapper_AngleBetweenVectors}, 
    {"CreateLookAtMatrix", _wrap_VScriptUtil_wrapper_CreateLookAtMatrix}, 
    {0,0}
};
static swig_lua_attribute swig_VScriptUtil_wrapper_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_VScriptUtil_wrapper_bases[] = {0};
static const char *swig_VScriptUtil_wrapper_base_names[] = {0};
static swig_lua_class _wrap_class_VScriptUtil_wrapper = { "VScriptUtil_wrapper", &SWIGTYPE_p_VScriptUtil_wrapper,_wrap_new_VScriptUtil_wrapper, swig_delete_VScriptUtil_wrapper, swig_VScriptUtil_wrapper_methods, swig_VScriptUtil_wrapper_attributes, swig_VScriptUtil_wrapper_bases, swig_VScriptUtil_wrapper_base_names };

static int _wrap_new_VScriptRenderer_wrapper(lua_State* L) {
  int SWIG_arg = 0;
  VScriptRenderer_wrapper *result = 0 ;
  
  SWIG_check_num_args("VScriptRenderer_wrapper",0,0)
  result = (VScriptRenderer_wrapper *)new VScriptRenderer_wrapper();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_VScriptRenderer_wrapper,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VScriptRenderer_wrapper_Draw_set(lua_State* L) {
  int SWIG_arg = 0;
  VScriptRenderer_wrapper *arg1 = (VScriptRenderer_wrapper *) 0 ;
  VScriptDraw_wrapper *arg2 = (VScriptDraw_wrapper *) 0 ;
  
  SWIG_check_num_args("Draw",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Draw",1,"VScriptRenderer_wrapper *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Draw",2,"VScriptDraw_wrapper *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VScriptRenderer_wrapper,0))){
    SWIG_fail_ptr("VScriptRenderer_wrapper_Draw_set",1,SWIGTYPE_p_VScriptRenderer_wrapper);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_VScriptDraw_wrapper,0))){
    SWIG_fail_ptr("VScriptRenderer_wrapper_Draw_set",2,SWIGTYPE_p_VScriptDraw_wrapper);
  }
  
  if (arg1) (arg1)->Draw = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VScriptRenderer_wrapper_Draw_get(lua_State* L) {
  int SWIG_arg = 0;
  VScriptRenderer_wrapper *arg1 = (VScriptRenderer_wrapper *) 0 ;
  VScriptDraw_wrapper *result = 0 ;
  
  SWIG_check_num_args("Draw",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Draw",1,"VScriptRenderer_wrapper *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VScriptRenderer_wrapper,0))){
    SWIG_fail_ptr("VScriptRenderer_wrapper_Draw_get",1,SWIGTYPE_p_VScriptRenderer_wrapper);
  }
  
  result = (VScriptDraw_wrapper *)& ((arg1)->Draw);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_VScriptDraw_wrapper,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VScriptRenderer_wrapper_GetTimeOfDayHandler(lua_State* L) {
  int SWIG_arg = 0;
  VScriptRenderer_wrapper *arg1 = (VScriptRenderer_wrapper *) 0 ;
  IVTimeOfDay *result = 0 ;
  
  SWIG_check_num_args("GetTimeOfDayHandler",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetTimeOfDayHandler",1,"VScriptRenderer_wrapper *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VScriptRenderer_wrapper,0))){
    SWIG_fail_ptr("VScriptRenderer_wrapper_GetTimeOfDayHandler",1,SWIGTYPE_p_VScriptRenderer_wrapper);
  }
  
  result = (IVTimeOfDay *)VScriptRenderer_wrapper_GetTimeOfDayHandler(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_IVTimeOfDay,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VScriptRenderer_wrapper_GetRendererNode__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  VScriptRenderer_wrapper *arg1 = (VScriptRenderer_wrapper *) 0 ;
  int arg2 ;
  IVRendererNode *result = 0 ;
  
  SWIG_check_num_args("GetRendererNode",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetRendererNode",1,"VScriptRenderer_wrapper *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("GetRendererNode",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VScriptRenderer_wrapper,0))){
    SWIG_fail_ptr("VScriptRenderer_wrapper_GetRendererNode",1,SWIGTYPE_p_VScriptRenderer_wrapper);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  result = (IVRendererNode *)VScriptRenderer_wrapper_GetRendererNode__SWIG_0(arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_IVRendererNode,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VScriptRenderer_wrapper_GetRendererNode__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  VScriptRenderer_wrapper *arg1 = (VScriptRenderer_wrapper *) 0 ;
  IVRendererNode *result = 0 ;
  
  SWIG_check_num_args("GetRendererNode",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetRendererNode",1,"VScriptRenderer_wrapper *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VScriptRenderer_wrapper,0))){
    SWIG_fail_ptr("VScriptRenderer_wrapper_GetRendererNode",1,SWIGTYPE_p_VScriptRenderer_wrapper);
  }
  
  result = (IVRendererNode *)VScriptRenderer_wrapper_GetRendererNode__SWIG_0(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_IVRendererNode,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VScriptRenderer_wrapper_GetRendererNode(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VScriptRenderer_wrapper, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_VScriptRenderer_wrapper_GetRendererNode__SWIG_1(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VScriptRenderer_wrapper, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_VScriptRenderer_wrapper_GetRendererNode__SWIG_0(L);
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'VScriptRenderer_wrapper_GetRendererNode'\n"
    "  Possible C/C++ prototypes are:\n"
    "    GetRendererNode(VScriptRenderer_wrapper *,int)\n"
    "    GetRendererNode(VScriptRenderer_wrapper *)\n");
  lua_error(L);return 0;
}


static int _wrap_VScriptRenderer_wrapper_SetGlobalAmbientColor(lua_State* L) {
  int SWIG_arg = 0;
  VScriptRenderer_wrapper *arg1 = (VScriptRenderer_wrapper *) 0 ;
  VColorRef arg2 ;
  VColorRef *argp2 ;
  
  SWIG_check_num_args("SetGlobalAmbientColor",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetGlobalAmbientColor",1,"VScriptRenderer_wrapper *");
  if(!lua_isuserdata(L,2)) SWIG_fail_arg("SetGlobalAmbientColor",2,"VColorRef");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VScriptRenderer_wrapper,0))){
    SWIG_fail_ptr("VScriptRenderer_wrapper_SetGlobalAmbientColor",1,SWIGTYPE_p_VScriptRenderer_wrapper);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_VColorRef,0))){
    SWIG_fail_ptr("VScriptRenderer_wrapper_SetGlobalAmbientColor",2,SWIGTYPE_p_VColorRef);
  }
  arg2 = *argp2;
  
  VScriptRenderer_wrapper_SetGlobalAmbientColor(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VScriptRenderer_wrapper_SetWireframeMode(lua_State* L) {
  int SWIG_arg = 0;
  VScriptRenderer_wrapper *arg1 = (VScriptRenderer_wrapper *) 0 ;
  bool arg2 ;
  
  SWIG_check_num_args("SetWireframeMode",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SetWireframeMode",1,"VScriptRenderer_wrapper *");
  if(!lua_isboolean(L,2)) SWIG_fail_arg("SetWireframeMode",2,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VScriptRenderer_wrapper,0))){
    SWIG_fail_ptr("VScriptRenderer_wrapper_SetWireframeMode",1,SWIGTYPE_p_VScriptRenderer_wrapper);
  }
  
  arg2 = (lua_toboolean(L, 2)!=0);
  VScriptRenderer_wrapper_SetWireframeMode(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VScriptRenderer_wrapper_GetWireframeMode(lua_State* L) {
  int SWIG_arg = 0;
  VScriptRenderer_wrapper *arg1 = (VScriptRenderer_wrapper *) 0 ;
  bool result;
  
  SWIG_check_num_args("GetWireframeMode",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetWireframeMode",1,"VScriptRenderer_wrapper *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VScriptRenderer_wrapper,0))){
    SWIG_fail_ptr("VScriptRenderer_wrapper_GetWireframeMode",1,SWIGTYPE_p_VScriptRenderer_wrapper);
  }
  
  result = (bool)VScriptRenderer_wrapper_GetWireframeMode(arg1);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VScriptRenderer_wrapper_GetVertexShaderVersion(lua_State* L) {
  int SWIG_arg = 0;
  VScriptRenderer_wrapper *arg1 = (VScriptRenderer_wrapper *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("GetVertexShaderVersion",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetVertexShaderVersion",1,"VScriptRenderer_wrapper *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VScriptRenderer_wrapper,0))){
    SWIG_fail_ptr("VScriptRenderer_wrapper_GetVertexShaderVersion",1,SWIGTYPE_p_VScriptRenderer_wrapper);
  }
  
  result = (char *)VScriptRenderer_wrapper_GetVertexShaderVersion(arg1);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_VScriptRenderer_wrapper(void *obj) {
VScriptRenderer_wrapper *arg1 = (VScriptRenderer_wrapper *) obj;
delete arg1;
}
static swig_lua_method swig_VScriptRenderer_wrapper_methods[] = {
    {"GetTimeOfDayHandler", _wrap_VScriptRenderer_wrapper_GetTimeOfDayHandler}, 
    {"GetRendererNode", _wrap_VScriptRenderer_wrapper_GetRendererNode}, 
    {"SetGlobalAmbientColor", _wrap_VScriptRenderer_wrapper_SetGlobalAmbientColor}, 
    {"SetWireframeMode", _wrap_VScriptRenderer_wrapper_SetWireframeMode}, 
    {"GetWireframeMode", _wrap_VScriptRenderer_wrapper_GetWireframeMode}, 
    {"GetVertexShaderVersion", _wrap_VScriptRenderer_wrapper_GetVertexShaderVersion}, 
    {0,0}
};
static swig_lua_attribute swig_VScriptRenderer_wrapper_attributes[] = {
    { "Draw", _wrap_VScriptRenderer_wrapper_Draw_get, _wrap_VScriptRenderer_wrapper_Draw_set},
    {0,0,0}
};
static swig_lua_class *swig_VScriptRenderer_wrapper_bases[] = {0};
static const char *swig_VScriptRenderer_wrapper_base_names[] = {0};
static swig_lua_class _wrap_class_VScriptRenderer_wrapper = { "VScriptRenderer_wrapper", &SWIGTYPE_p_VScriptRenderer_wrapper,_wrap_new_VScriptRenderer_wrapper, swig_delete_VScriptRenderer_wrapper, swig_VScriptRenderer_wrapper_methods, swig_VScriptRenderer_wrapper_attributes, swig_VScriptRenderer_wrapper_bases, swig_VScriptRenderer_wrapper_base_names };

static int _wrap_new_VScriptScreen_wrapper(lua_State* L) {
  int SWIG_arg = 0;
  VScriptScreen_wrapper *result = 0 ;
  
  SWIG_check_num_args("VScriptScreen_wrapper",0,0)
  result = (VScriptScreen_wrapper *)new VScriptScreen_wrapper();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_VScriptScreen_wrapper,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VScriptScreen_wrapper_PickPoint__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  VScriptScreen_wrapper *arg1 = (VScriptScreen_wrapper *) 0 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  bool arg5 ;
  bool arg6 ;
  hkvVec3 *result = 0 ;
  
  SWIG_check_num_args("PickPoint",6,6)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("PickPoint",1,"VScriptScreen_wrapper *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("PickPoint",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("PickPoint",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("PickPoint",4,"float");
  if(!lua_isboolean(L,5)) SWIG_fail_arg("PickPoint",5,"bool");
  if(!lua_isboolean(L,6)) SWIG_fail_arg("PickPoint",6,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VScriptScreen_wrapper,0))){
    SWIG_fail_ptr("VScriptScreen_wrapper_PickPoint",1,SWIGTYPE_p_VScriptScreen_wrapper);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4);
  arg5 = (lua_toboolean(L, 5)!=0);
  arg6 = (lua_toboolean(L, 6)!=0);
  result = (hkvVec3 *)(arg1)->PickPoint(arg2,arg3,arg4,arg5,arg6);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_hkvVec3,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VScriptScreen_wrapper_PickPoint__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  VScriptScreen_wrapper *arg1 = (VScriptScreen_wrapper *) 0 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  bool arg5 ;
  hkvVec3 *result = 0 ;
  
  SWIG_check_num_args("PickPoint",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("PickPoint",1,"VScriptScreen_wrapper *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("PickPoint",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("PickPoint",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("PickPoint",4,"float");
  if(!lua_isboolean(L,5)) SWIG_fail_arg("PickPoint",5,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VScriptScreen_wrapper,0))){
    SWIG_fail_ptr("VScriptScreen_wrapper_PickPoint",1,SWIGTYPE_p_VScriptScreen_wrapper);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4);
  arg5 = (lua_toboolean(L, 5)!=0);
  result = (hkvVec3 *)(arg1)->PickPoint(arg2,arg3,arg4,arg5);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_hkvVec3,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VScriptScreen_wrapper_PickPoint__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  VScriptScreen_wrapper *arg1 = (VScriptScreen_wrapper *) 0 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  hkvVec3 *result = 0 ;
  
  SWIG_check_num_args("PickPoint",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("PickPoint",1,"VScriptScreen_wrapper *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("PickPoint",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("PickPoint",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("PickPoint",4,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VScriptScreen_wrapper,0))){
    SWIG_fail_ptr("VScriptScreen_wrapper_PickPoint",1,SWIGTYPE_p_VScriptScreen_wrapper);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4);
  result = (hkvVec3 *)(arg1)->PickPoint(arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_hkvVec3,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VScriptScreen_wrapper_PickPoint__SWIG_3(lua_State* L) {
  int SWIG_arg = 0;
  VScriptScreen_wrapper *arg1 = (VScriptScreen_wrapper *) 0 ;
  float arg2 ;
  float arg3 ;
  hkvVec3 *result = 0 ;
  
  SWIG_check_num_args("PickPoint",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("PickPoint",1,"VScriptScreen_wrapper *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("PickPoint",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("PickPoint",3,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VScriptScreen_wrapper,0))){
    SWIG_fail_ptr("VScriptScreen_wrapper_PickPoint",1,SWIGTYPE_p_VScriptScreen_wrapper);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  result = (hkvVec3 *)(arg1)->PickPoint(arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_hkvVec3,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VScriptScreen_wrapper_PickPoint(lua_State* L) {
  int argc;
  int argv[7]={
    1,2,3,4,5,6,7
  };
  
  argc = lua_gettop(L);
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VScriptScreen_wrapper, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          return _wrap_VScriptScreen_wrapper_PickPoint__SWIG_3(L);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VScriptScreen_wrapper, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_VScriptScreen_wrapper_PickPoint__SWIG_2(L);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VScriptScreen_wrapper, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isboolean(L,argv[4]);
            }
            if (_v) {
              return _wrap_VScriptScreen_wrapper_PickPoint__SWIG_1(L);
            }
          }
        }
      }
    }
  }
  if (argc == 6) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VScriptScreen_wrapper, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isboolean(L,argv[4]);
            }
            if (_v) {
              {
                _v = lua_isboolean(L,argv[5]);
              }
              if (_v) {
                return _wrap_VScriptScreen_wrapper_PickPoint__SWIG_0(L);
              }
            }
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'VScriptScreen_wrapper_PickPoint'\n"
    "  Possible C/C++ prototypes are:\n"
    "    PickPoint(VScriptScreen_wrapper *,float,float,float,bool,bool)\n"
    "    PickPoint(VScriptScreen_wrapper *,float,float,float,bool)\n"
    "    PickPoint(VScriptScreen_wrapper *,float,float,float)\n"
    "    PickPoint(VScriptScreen_wrapper *,float,float)\n");
  lua_error(L);return 0;
}


static int _wrap_VScriptScreen_wrapper_Project3D(lua_State* L) {
  int SWIG_arg = 0;
  VScriptScreen_wrapper *arg1 = (VScriptScreen_wrapper *) 0 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  hkvVec3 *result = 0 ;
  
  SWIG_check_num_args("Project3D",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Project3D",1,"VScriptScreen_wrapper *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Project3D",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Project3D",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("Project3D",4,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VScriptScreen_wrapper,0))){
    SWIG_fail_ptr("VScriptScreen_wrapper_Project3D",1,SWIGTYPE_p_VScriptScreen_wrapper);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4);
  result = (hkvVec3 *)(arg1)->Project3D(arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_hkvVec3,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VScriptScreen_wrapper_PickEntity__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  VScriptScreen_wrapper *arg1 = (VScriptScreen_wrapper *) 0 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  bool arg5 ;
  VisBaseEntity_cl *result = 0 ;
  
  SWIG_check_num_args("PickEntity",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("PickEntity",1,"VScriptScreen_wrapper *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("PickEntity",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("PickEntity",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("PickEntity",4,"float");
  if(!lua_isboolean(L,5)) SWIG_fail_arg("PickEntity",5,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VScriptScreen_wrapper,0))){
    SWIG_fail_ptr("VScriptScreen_wrapper_PickEntity",1,SWIGTYPE_p_VScriptScreen_wrapper);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4);
  arg5 = (lua_toboolean(L, 5)!=0);
  result = (VisBaseEntity_cl *)(arg1)->PickEntity(arg2,arg3,arg4,arg5);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_VisBaseEntity_cl,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VScriptScreen_wrapper_PickEntity__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  VScriptScreen_wrapper *arg1 = (VScriptScreen_wrapper *) 0 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  VisBaseEntity_cl *result = 0 ;
  
  SWIG_check_num_args("PickEntity",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("PickEntity",1,"VScriptScreen_wrapper *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("PickEntity",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("PickEntity",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("PickEntity",4,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VScriptScreen_wrapper,0))){
    SWIG_fail_ptr("VScriptScreen_wrapper_PickEntity",1,SWIGTYPE_p_VScriptScreen_wrapper);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4);
  result = (VisBaseEntity_cl *)(arg1)->PickEntity(arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_VisBaseEntity_cl,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VScriptScreen_wrapper_PickEntity__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  VScriptScreen_wrapper *arg1 = (VScriptScreen_wrapper *) 0 ;
  float arg2 ;
  float arg3 ;
  VisBaseEntity_cl *result = 0 ;
  
  SWIG_check_num_args("PickEntity",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("PickEntity",1,"VScriptScreen_wrapper *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("PickEntity",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("PickEntity",3,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VScriptScreen_wrapper,0))){
    SWIG_fail_ptr("VScriptScreen_wrapper_PickEntity",1,SWIGTYPE_p_VScriptScreen_wrapper);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  result = (VisBaseEntity_cl *)(arg1)->PickEntity(arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_VisBaseEntity_cl,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VScriptScreen_wrapper_PickEntity(lua_State* L) {
  int argc;
  int argv[6]={
    1,2,3,4,5,6
  };
  
  argc = lua_gettop(L);
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VScriptScreen_wrapper, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          return _wrap_VScriptScreen_wrapper_PickEntity__SWIG_2(L);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VScriptScreen_wrapper, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_VScriptScreen_wrapper_PickEntity__SWIG_1(L);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VScriptScreen_wrapper, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            {
              _v = lua_isboolean(L,argv[4]);
            }
            if (_v) {
              return _wrap_VScriptScreen_wrapper_PickEntity__SWIG_0(L);
            }
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'VScriptScreen_wrapper_PickEntity'\n"
    "  Possible C/C++ prototypes are:\n"
    "    PickEntity(VScriptScreen_wrapper *,float,float,float,bool)\n"
    "    PickEntity(VScriptScreen_wrapper *,float,float,float)\n"
    "    PickEntity(VScriptScreen_wrapper *,float,float)\n");
  lua_error(L);return 0;
}


static int _wrap_VScriptScreen_wrapper_SaveToFile__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  VScriptScreen_wrapper *arg1 = (VScriptScreen_wrapper *) 0 ;
  char *arg2 = (char *) 0 ;
  bool arg3 ;
  bool result;
  
  SWIG_check_num_args("SaveToFile",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SaveToFile",1,"VScriptScreen_wrapper *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("SaveToFile",2,"char const *");
  if(!lua_isboolean(L,3)) SWIG_fail_arg("SaveToFile",3,"bool");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VScriptScreen_wrapper,0))){
    SWIG_fail_ptr("VScriptScreen_wrapper_SaveToFile",1,SWIGTYPE_p_VScriptScreen_wrapper);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  arg3 = (lua_toboolean(L, 3)!=0);
  result = (bool)(arg1)->SaveToFile((char const *)arg2,arg3);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VScriptScreen_wrapper_SaveToFile__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  VScriptScreen_wrapper *arg1 = (VScriptScreen_wrapper *) 0 ;
  char *arg2 = (char *) 0 ;
  bool result;
  
  SWIG_check_num_args("SaveToFile",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SaveToFile",1,"VScriptScreen_wrapper *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("SaveToFile",2,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VScriptScreen_wrapper,0))){
    SWIG_fail_ptr("VScriptScreen_wrapper_SaveToFile",1,SWIGTYPE_p_VScriptScreen_wrapper);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  result = (bool)(arg1)->SaveToFile((char const *)arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VScriptScreen_wrapper_SaveToFile__SWIG_2(lua_State* L) {
  int SWIG_arg = 0;
  VScriptScreen_wrapper *arg1 = (VScriptScreen_wrapper *) 0 ;
  bool result;
  
  SWIG_check_num_args("SaveToFile",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SaveToFile",1,"VScriptScreen_wrapper *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VScriptScreen_wrapper,0))){
    SWIG_fail_ptr("VScriptScreen_wrapper_SaveToFile",1,SWIGTYPE_p_VScriptScreen_wrapper);
  }
  
  result = (bool)(arg1)->SaveToFile();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VScriptScreen_wrapper_SaveToFile(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VScriptScreen_wrapper, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_VScriptScreen_wrapper_SaveToFile__SWIG_2(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VScriptScreen_wrapper, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = SWIG_lua_isnilstring(L,argv[1]);
      }
      if (_v) {
        return _wrap_VScriptScreen_wrapper_SaveToFile__SWIG_1(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VScriptScreen_wrapper, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = SWIG_lua_isnilstring(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isboolean(L,argv[2]);
        }
        if (_v) {
          return _wrap_VScriptScreen_wrapper_SaveToFile__SWIG_0(L);
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'VScriptScreen_wrapper_SaveToFile'\n"
    "  Possible C/C++ prototypes are:\n"
    "    SaveToFile(VScriptScreen_wrapper *,char const *,bool)\n"
    "    SaveToFile(VScriptScreen_wrapper *,char const *)\n"
    "    SaveToFile(VScriptScreen_wrapper *)\n");
  lua_error(L);return 0;
}


static int _wrap_VScriptScreen_wrapper_GetDeviceDpi(lua_State* L) {
  int SWIG_arg = 0;
  VScriptScreen_wrapper *arg1 = (VScriptScreen_wrapper *) 0 ;
  float result;
  
  SWIG_check_num_args("GetDeviceDpi",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetDeviceDpi",1,"VScriptScreen_wrapper *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VScriptScreen_wrapper,0))){
    SWIG_fail_ptr("VScriptScreen_wrapper_GetDeviceDpi",1,SWIGTYPE_p_VScriptScreen_wrapper);
  }
  
  result = (float)(arg1)->GetDeviceDpi();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_VScriptScreen_wrapper(void *obj) {
VScriptScreen_wrapper *arg1 = (VScriptScreen_wrapper *) obj;
delete arg1;
}
static swig_lua_method swig_VScriptScreen_wrapper_methods[] = {
    { "Project2D",VScriptScreen_wrapper_Project2D},
    { "GetViewportSize",VScriptScreen_wrapper_GetViewportSize},
    {"PickPoint", _wrap_VScriptScreen_wrapper_PickPoint}, 
    {"Project3D", _wrap_VScriptScreen_wrapper_Project3D}, 
    {"PickEntity", _wrap_VScriptScreen_wrapper_PickEntity}, 
    {"SaveToFile", _wrap_VScriptScreen_wrapper_SaveToFile}, 
    {"GetDeviceDpi", _wrap_VScriptScreen_wrapper_GetDeviceDpi}, 
    {0,0}
};
static swig_lua_attribute swig_VScriptScreen_wrapper_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_VScriptScreen_wrapper_bases[] = {0};
static const char *swig_VScriptScreen_wrapper_base_names[] = {0};
static swig_lua_class _wrap_class_VScriptScreen_wrapper = { "VScriptScreen_wrapper", &SWIGTYPE_p_VScriptScreen_wrapper,_wrap_new_VScriptScreen_wrapper, swig_delete_VScriptScreen_wrapper, swig_VScriptScreen_wrapper_methods, swig_VScriptScreen_wrapper_attributes, swig_VScriptScreen_wrapper_bases, swig_VScriptScreen_wrapper_base_names };

static int _wrap_VScriptFileSystem_wrapper_Exists__SWIG_0(lua_State* L) {
  int SWIG_arg = 0;
  VScriptFileSystem_wrapper *arg1 = (VScriptFileSystem_wrapper *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  bool result;
  
  SWIG_check_num_args("Exists",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Exists",1,"VScriptFileSystem_wrapper *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("Exists",2,"char const *");
  if(!SWIG_lua_isnilstring(L,3)) SWIG_fail_arg("Exists",3,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VScriptFileSystem_wrapper,0))){
    SWIG_fail_ptr("VScriptFileSystem_wrapper_Exists",1,SWIGTYPE_p_VScriptFileSystem_wrapper);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  arg3 = (char *)lua_tostring(L, 3);
  result = (bool)(arg1)->Exists((char const *)arg2,(char const *)arg3);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VScriptFileSystem_wrapper_Exists__SWIG_1(lua_State* L) {
  int SWIG_arg = 0;
  VScriptFileSystem_wrapper *arg1 = (VScriptFileSystem_wrapper *) 0 ;
  char *arg2 = (char *) 0 ;
  bool result;
  
  SWIG_check_num_args("Exists",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Exists",1,"VScriptFileSystem_wrapper *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("Exists",2,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VScriptFileSystem_wrapper,0))){
    SWIG_fail_ptr("VScriptFileSystem_wrapper_Exists",1,SWIGTYPE_p_VScriptFileSystem_wrapper);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  result = (bool)(arg1)->Exists((char const *)arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VScriptFileSystem_wrapper_Exists(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VScriptFileSystem_wrapper, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = SWIG_lua_isnilstring(L,argv[1]);
      }
      if (_v) {
        return _wrap_VScriptFileSystem_wrapper_Exists__SWIG_1(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_VScriptFileSystem_wrapper, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = SWIG_lua_isnilstring(L,argv[1]);
      }
      if (_v) {
        {
          _v = SWIG_lua_isnilstring(L,argv[2]);
        }
        if (_v) {
          return _wrap_VScriptFileSystem_wrapper_Exists__SWIG_0(L);
        }
      }
    }
  }
  
  lua_pushstring(L,"Wrong arguments for overloaded function 'VScriptFileSystem_wrapper_Exists'\n"
    "  Possible C/C++ prototypes are:\n"
    "    Exists(VScriptFileSystem_wrapper *,char const *,char const *)\n"
    "    Exists(VScriptFileSystem_wrapper *,char const *)\n");
  lua_error(L);return 0;
}


static swig_lua_method swig_VScriptFileSystem_wrapper_methods[] = {
    { "GetDataDirs",VScriptFileSystem_wrapper_GetDataDirs},
    { "GetAbsDir",VScriptFileSystem_wrapper_GetAbsDir},
    {"Exists", _wrap_VScriptFileSystem_wrapper_Exists}, 
    {0,0}
};
static swig_lua_attribute swig_VScriptFileSystem_wrapper_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_VScriptFileSystem_wrapper_bases[] = {0};
static const char *swig_VScriptFileSystem_wrapper_base_names[] = {0};
static swig_lua_class _wrap_class_VScriptFileSystem_wrapper = { "VScriptFileSystem_wrapper", &SWIGTYPE_p_VScriptFileSystem_wrapper,0,0, swig_VScriptFileSystem_wrapper_methods, swig_VScriptFileSystem_wrapper_attributes, swig_VScriptFileSystem_wrapper_bases, swig_VScriptFileSystem_wrapper_base_names };

static int _wrap_new_VScriptApp_wrapper(lua_State* L) {
  int SWIG_arg = 0;
  VScriptApp_wrapper *result = 0 ;
  
  SWIG_check_num_args("VScriptApp_wrapper",0,0)
  result = (VScriptApp_wrapper *)new VScriptApp_wrapper();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_VScriptApp_wrapper,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VScriptApp_wrapper_FileSystem_set(lua_State* L) {
  int SWIG_arg = 0;
  VScriptApp_wrapper *arg1 = (VScriptApp_wrapper *) 0 ;
  VScriptFileSystem_wrapper *arg2 = (VScriptFileSystem_wrapper *) 0 ;
  
  SWIG_check_num_args("FileSystem",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("FileSystem",1,"VScriptApp_wrapper *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("FileSystem",2,"VScriptFileSystem_wrapper *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VScriptApp_wrapper,0))){
    SWIG_fail_ptr("VScriptApp_wrapper_FileSystem_set",1,SWIGTYPE_p_VScriptApp_wrapper);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_VScriptFileSystem_wrapper,0))){
    SWIG_fail_ptr("VScriptApp_wrapper_FileSystem_set",2,SWIGTYPE_p_VScriptFileSystem_wrapper);
  }
  
  if (arg1) (arg1)->FileSystem = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VScriptApp_wrapper_FileSystem_get(lua_State* L) {
  int SWIG_arg = 0;
  VScriptApp_wrapper *arg1 = (VScriptApp_wrapper *) 0 ;
  VScriptFileSystem_wrapper *result = 0 ;
  
  SWIG_check_num_args("FileSystem",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("FileSystem",1,"VScriptApp_wrapper *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VScriptApp_wrapper,0))){
    SWIG_fail_ptr("VScriptApp_wrapper_FileSystem_get",1,SWIGTYPE_p_VScriptApp_wrapper);
  }
  
  result = (VScriptFileSystem_wrapper *)& ((arg1)->FileSystem);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_VScriptFileSystem_wrapper,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VScriptApp_wrapper_LoadScene(lua_State* L) {
  int SWIG_arg = 0;
  VScriptApp_wrapper *arg1 = (VScriptApp_wrapper *) 0 ;
  char *arg2 = (char *) 0 ;
  bool result;
  
  SWIG_check_num_args("LoadScene",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("LoadScene",1,"VScriptApp_wrapper *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("LoadScene",2,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VScriptApp_wrapper,0))){
    SWIG_fail_ptr("VScriptApp_wrapper_LoadScene",1,SWIGTYPE_p_VScriptApp_wrapper);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  result = (bool)(arg1)->LoadScene((char const *)arg2);
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VScriptApp_wrapper_UnloadScene(lua_State* L) {
  int SWIG_arg = 0;
  VScriptApp_wrapper *arg1 = (VScriptApp_wrapper *) 0 ;
  
  SWIG_check_num_args("UnloadScene",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("UnloadScene",1,"VScriptApp_wrapper *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VScriptApp_wrapper,0))){
    SWIG_fail_ptr("VScriptApp_wrapper_UnloadScene",1,SWIGTYPE_p_VScriptApp_wrapper);
  }
  
  (arg1)->UnloadScene();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VScriptApp_wrapper_ClearScene(lua_State* L) {
  int SWIG_arg = 0;
  VScriptApp_wrapper *arg1 = (VScriptApp_wrapper *) 0 ;
  
  SWIG_check_num_args("ClearScene",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ClearScene",1,"VScriptApp_wrapper *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VScriptApp_wrapper,0))){
    SWIG_fail_ptr("VScriptApp_wrapper_ClearScene",1,SWIGTYPE_p_VScriptApp_wrapper);
  }
  
  (arg1)->ClearScene();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VScriptApp_wrapper_IsInEditor(lua_State* L) {
  int SWIG_arg = 0;
  VScriptApp_wrapper *arg1 = (VScriptApp_wrapper *) 0 ;
  bool result;
  
  SWIG_check_num_args("IsInEditor",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("IsInEditor",1,"VScriptApp_wrapper *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VScriptApp_wrapper,0))){
    SWIG_fail_ptr("VScriptApp_wrapper_IsInEditor",1,SWIGTYPE_p_VScriptApp_wrapper);
  }
  
  result = (bool)(arg1)->IsInEditor();
  lua_pushboolean(L,(int)(result!=0)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VScriptApp_wrapper_GetEditorMode(lua_State* L) {
  int SWIG_arg = 0;
  VScriptApp_wrapper *arg1 = (VScriptApp_wrapper *) 0 ;
  int result;
  
  SWIG_check_num_args("GetEditorMode",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetEditorMode",1,"VScriptApp_wrapper *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VScriptApp_wrapper,0))){
    SWIG_fail_ptr("VScriptApp_wrapper_GetEditorMode",1,SWIGTYPE_p_VScriptApp_wrapper);
  }
  
  result = (int)(arg1)->GetEditorMode();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VScriptApp_wrapper_GetPlatformName(lua_State* L) {
  int SWIG_arg = 0;
  VScriptApp_wrapper *arg1 = (VScriptApp_wrapper *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("GetPlatformName",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GetPlatformName",1,"VScriptApp_wrapper *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_VScriptApp_wrapper,0))){
    SWIG_fail_ptr("VScriptApp_wrapper_GetPlatformName",1,SWIGTYPE_p_VScriptApp_wrapper);
  }
  
  result = (char *)(arg1)->GetPlatformName();
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_VScriptApp_wrapper(void *obj) {
VScriptApp_wrapper *arg1 = (VScriptApp_wrapper *) obj;
delete arg1;
}
static swig_lua_method swig_VScriptApp_wrapper_methods[] = {
    { "LoadScript",VScriptApp_wrapper_LoadScript},
    {"LoadScene", _wrap_VScriptApp_wrapper_LoadScene}, 
    {"UnloadScene", _wrap_VScriptApp_wrapper_UnloadScene}, 
    {"ClearScene", _wrap_VScriptApp_wrapper_ClearScene}, 
    {"IsInEditor", _wrap_VScriptApp_wrapper_IsInEditor}, 
    {"GetEditorMode", _wrap_VScriptApp_wrapper_GetEditorMode}, 
    {"GetPlatformName", _wrap_VScriptApp_wrapper_GetPlatformName}, 
    {0,0}
};
static swig_lua_attribute swig_VScriptApp_wrapper_attributes[] = {
    { "FileSystem", _wrap_VScriptApp_wrapper_FileSystem_get, _wrap_VScriptApp_wrapper_FileSystem_set},
    {0,0,0}
};
static swig_lua_class *swig_VScriptApp_wrapper_bases[] = {0};
static const char *swig_VScriptApp_wrapper_base_names[] = {0};
static swig_lua_class _wrap_class_VScriptApp_wrapper = { "VScriptApp_wrapper", &SWIGTYPE_p_VScriptApp_wrapper,_wrap_new_VScriptApp_wrapper, swig_delete_VScriptApp_wrapper, swig_VScriptApp_wrapper_methods, swig_VScriptApp_wrapper_attributes, swig_VScriptApp_wrapper_bases, swig_VScriptApp_wrapper_base_names };

#ifdef __cplusplus
}
#endif

static const struct luaL_reg swig_commands[] = {
    { "VisTriggerSourceComponent_cl_Cast", _wrap_VisTriggerSourceComponent_cl_Cast},
    { "VisTriggerTargetComponent_cl_Cast", _wrap_VisTriggerTargetComponent_cl_Cast},
    { "VTransitionStateMachine_Cast", _wrap_VTransitionStateMachine_Cast},
    { "VAnimationComponent_Cast", _wrap_VAnimationComponent_Cast},
    { "VTimedValueComponent_Cast", _wrap_VTimedValueComponent_Cast},
    { "Assert",Vision_Assert},
    {0,0}
};

static swig_lua_var_info swig_variables[] = {
    { "LIGHT_POINT", _wrap_LIGHT_POINT_get, SWIG_Lua_set_immutable },
    { "LIGHT_DIRECTED", _wrap_LIGHT_DIRECTED_get, SWIG_Lua_set_immutable },
    { "LIGHT_SPOT", _wrap_LIGHT_SPOT_get, SWIG_Lua_set_immutable },
    { "CORONA_NO_SCALE", _wrap_CORONA_NO_SCALE_get, SWIG_Lua_set_immutable },
    { "CORONA_DISTANCE_SCALE", _wrap_CORONA_DISTANCE_SCALE_get, SWIG_Lua_set_immutable },
    { "CORONA_AREA_SCALE", _wrap_CORONA_AREA_SCALE_get, SWIG_Lua_set_immutable },
    { "CORONA_FADEOUT_SCALE", _wrap_CORONA_FADEOUT_SCALE_get, SWIG_Lua_set_immutable },
    { "CORONA_ROTATING_SCALE", _wrap_CORONA_ROTATING_SCALE_get, SWIG_Lua_set_immutable },
    { "GUI_STATE_DISABLED", _wrap_GUI_STATE_DISABLED_get, SWIG_Lua_set_immutable },
    { "GUI_STATE_NORMAL", _wrap_GUI_STATE_NORMAL_get, SWIG_Lua_set_immutable },
    { "GUI_STATE_MOUSEOVER", _wrap_GUI_STATE_MOUSEOVER_get, SWIG_Lua_set_immutable },
    { "GUI_STATE_SELECTED", _wrap_GUI_STATE_SELECTED_get, SWIG_Lua_set_immutable },
    { "GUI_ALIGN_ABSOLUTE", _wrap_GUI_ALIGN_ABSOLUTE_get, SWIG_Lua_set_immutable },
    { "GUI_ALIGN_CENTER", _wrap_GUI_ALIGN_CENTER_get, SWIG_Lua_set_immutable },
    { "GUI_ALIGN_PARENT", _wrap_GUI_ALIGN_PARENT_get, SWIG_Lua_set_immutable },
    { "GUI_ALIGN_PARENT_CENTER", _wrap_GUI_ALIGN_PARENT_CENTER_get, SWIG_Lua_set_immutable },
    { "TRACE_IGNORE", _wrap_TRACE_IGNORE_get, SWIG_Lua_set_immutable },
    { "TRACE_AABOX", _wrap_TRACE_AABOX_get, SWIG_Lua_set_immutable },
    { "TRACE_OBOX", _wrap_TRACE_OBOX_get, SWIG_Lua_set_immutable },
    { "TRACE_SPHERE", _wrap_TRACE_SPHERE_get, SWIG_Lua_set_immutable },
    { "TRACE_POLYGON", _wrap_TRACE_POLYGON_get, SWIG_Lua_set_immutable },
    { "EDITOR_NONE", _wrap_EDITOR_NONE_get, SWIG_Lua_set_immutable },
    { "EDITOR_ANIMATING", _wrap_EDITOR_ANIMATING_get, SWIG_Lua_set_immutable },
    { "EDITOR_RUN", _wrap_EDITOR_RUN_get, SWIG_Lua_set_immutable },
    { "EDITOR_PLAY", _wrap_EDITOR_PLAY_get, SWIG_Lua_set_immutable },
    { "VRAND_MAX", _wrap_VRAND_MAX_get, SWIG_Lua_set_immutable },
    { "VRAND_MAX_INV", _wrap_VRAND_MAX_INV_get, SWIG_Lua_set_immutable },
    { "VRAND_MAX_2", _wrap_VRAND_MAX_2_get, SWIG_Lua_set_immutable },
    { "TEXTURE_TYPE_DIFFUSE", _wrap_TEXTURE_TYPE_DIFFUSE_get, SWIG_Lua_set_immutable },
    { "TEXTURE_TYPE_NORMAL_MAP", _wrap_TEXTURE_TYPE_NORMAL_MAP_get, SWIG_Lua_set_immutable },
    { "TEXTURE_TYPE_SPEC_MAP", _wrap_TEXTURE_TYPE_SPEC_MAP_get, SWIG_Lua_set_immutable },
    { "BLEND_OPAQUE", _wrap_BLEND_OPAQUE_get, SWIG_Lua_set_immutable },
    { "BLEND_MULTIPLY", _wrap_BLEND_MULTIPLY_get, SWIG_Lua_set_immutable },
    { "BLEND_ADDITIVE", _wrap_BLEND_ADDITIVE_get, SWIG_Lua_set_immutable },
    { "BLEND_ADDITIVE_NOALPHA", _wrap_BLEND_ADDITIVE_NOALPHA_get, SWIG_Lua_set_immutable },
    { "BLEND_ALPHA", _wrap_BLEND_ALPHA_get, SWIG_Lua_set_immutable },
    { "BLEND_ALPHA_TEST", _wrap_BLEND_ALPHA_TEST_get, SWIG_Lua_set_immutable },
    { "BLEND_ADD_MODULATE", _wrap_BLEND_ADD_MODULATE_get, SWIG_Lua_set_immutable },
    { "MATH_SMALL_EPSILON", _wrap_MATH_SMALL_EPSILON_get, SWIG_Lua_set_immutable },
    { "MATH_DEFAULT_EPSILON", _wrap_MATH_DEFAULT_EPSILON_get, SWIG_Lua_set_immutable },
    { "MATH_LARGE_EPSILON", _wrap_MATH_LARGE_EPSILON_get, SWIG_Lua_set_immutable },
    { "MATH_HUGE_EPSILON", _wrap_MATH_HUGE_EPSILON_get, SWIG_Lua_set_immutable },
    { "MATH_GIGANTIC_EPSILON", _wrap_MATH_GIGANTIC_EPSILON_get, SWIG_Lua_set_immutable },
    { "V_RGBA_WHITE", _wrap_V_RGBA_WHITE_get, SWIG_Lua_set_immutable },
    { "V_RGBA_GREY", _wrap_V_RGBA_GREY_get, SWIG_Lua_set_immutable },
    { "V_RGBA_BLACK", _wrap_V_RGBA_BLACK_get, SWIG_Lua_set_immutable },
    { "V_RGBA_RED", _wrap_V_RGBA_RED_get, SWIG_Lua_set_immutable },
    { "V_RGBA_YELLOW", _wrap_V_RGBA_YELLOW_get, SWIG_Lua_set_immutable },
    { "V_RGBA_GREEN", _wrap_V_RGBA_GREEN_get, SWIG_Lua_set_immutable },
    { "V_RGBA_CYAN", _wrap_V_RGBA_CYAN_get, SWIG_Lua_set_immutable },
    { "V_RGBA_BLUE", _wrap_V_RGBA_BLUE_get, SWIG_Lua_set_immutable },
    { "V_RGBA_PURPLE", _wrap_V_RGBA_PURPLE_get, SWIG_Lua_set_immutable },
    { "EVENT_TRANSITION_STARTED", _wrap_EVENT_TRANSITION_STARTED_get, SWIG_Lua_set_immutable },
    { "EVENT_TRANSITION_FINISHED", _wrap_EVENT_TRANSITION_FINISHED_get, SWIG_Lua_set_immutable },
    { "EVENT_SEQUENCE_STARTED", _wrap_EVENT_SEQUENCE_STARTED_get, SWIG_Lua_set_immutable },
    { "EVENT_SEQUENCE_FINISHED", _wrap_EVENT_SEQUENCE_FINISHED_get, SWIG_Lua_set_immutable },
    { "EVENT_TRANSITION_START_REACHED", _wrap_EVENT_TRANSITION_START_REACHED_get, SWIG_Lua_set_immutable },
    { "KEY_UNKNOWN", _wrap_KEY_UNKNOWN_get, SWIG_Lua_set_immutable },
    { "KEY_LSHIFT", _wrap_KEY_LSHIFT_get, SWIG_Lua_set_immutable },
    { "KEY_RSHIFT", _wrap_KEY_RSHIFT_get, SWIG_Lua_set_immutable },
    { "KEY_LCTRL", _wrap_KEY_LCTRL_get, SWIG_Lua_set_immutable },
    { "KEY_RCTRL", _wrap_KEY_RCTRL_get, SWIG_Lua_set_immutable },
    { "KEY_LALT", _wrap_KEY_LALT_get, SWIG_Lua_set_immutable },
    { "KEY_RALT", _wrap_KEY_RALT_get, SWIG_Lua_set_immutable },
    { "KEY_ALTGR", _wrap_KEY_ALTGR_get, SWIG_Lua_set_immutable },
    { "KEY_BACKSPACE", _wrap_KEY_BACKSPACE_get, SWIG_Lua_set_immutable },
    { "KEY_TAB", _wrap_KEY_TAB_get, SWIG_Lua_set_immutable },
    { "KEY_LWIN", _wrap_KEY_LWIN_get, SWIG_Lua_set_immutable },
    { "KEY_RWIN", _wrap_KEY_RWIN_get, SWIG_Lua_set_immutable },
    { "KEY_APPS", _wrap_KEY_APPS_get, SWIG_Lua_set_immutable },
    { "KEY_ENTER", _wrap_KEY_ENTER_get, SWIG_Lua_set_immutable },
    { "KEY_LCOM", _wrap_KEY_LCOM_get, SWIG_Lua_set_immutable },
    { "KEY_RCOM", _wrap_KEY_RCOM_get, SWIG_Lua_set_immutable },
    { "KEY_MAC", _wrap_KEY_MAC_get, SWIG_Lua_set_immutable },
    { "KEY_LMETA", _wrap_KEY_LMETA_get, SWIG_Lua_set_immutable },
    { "KEY_RMETA", _wrap_KEY_RMETA_get, SWIG_Lua_set_immutable },
    { "KEY_INS", _wrap_KEY_INS_get, SWIG_Lua_set_immutable },
    { "KEY_DEL", _wrap_KEY_DEL_get, SWIG_Lua_set_immutable },
    { "KEY_HOME", _wrap_KEY_HOME_get, SWIG_Lua_set_immutable },
    { "KEY_END", _wrap_KEY_END_get, SWIG_Lua_set_immutable },
    { "KEY_PAGEUP", _wrap_KEY_PAGEUP_get, SWIG_Lua_set_immutable },
    { "KEY_PAGEDOWN", _wrap_KEY_PAGEDOWN_get, SWIG_Lua_set_immutable },
    { "KEY_ESC", _wrap_KEY_ESC_get, SWIG_Lua_set_immutable },
    { "KEY_UP", _wrap_KEY_UP_get, SWIG_Lua_set_immutable },
    { "KEY_DOWN", _wrap_KEY_DOWN_get, SWIG_Lua_set_immutable },
    { "KEY_LEFT", _wrap_KEY_LEFT_get, SWIG_Lua_set_immutable },
    { "KEY_RIGHT", _wrap_KEY_RIGHT_get, SWIG_Lua_set_immutable },
    { "KEY_SPACE", _wrap_KEY_SPACE_get, SWIG_Lua_set_immutable },
    { "KEY_COMMA", _wrap_KEY_COMMA_get, SWIG_Lua_set_immutable },
    { "KEY_PERIOD", _wrap_KEY_PERIOD_get, SWIG_Lua_set_immutable },
    { "KEY_MINUS", _wrap_KEY_MINUS_get, SWIG_Lua_set_immutable },
    { "KEY_GRAVE", _wrap_KEY_GRAVE_get, SWIG_Lua_set_immutable },
    { "KEY_0", _wrap_KEY_0_get, SWIG_Lua_set_immutable },
    { "KEY_1", _wrap_KEY_1_get, SWIG_Lua_set_immutable },
    { "KEY_2", _wrap_KEY_2_get, SWIG_Lua_set_immutable },
    { "KEY_3", _wrap_KEY_3_get, SWIG_Lua_set_immutable },
    { "KEY_4", _wrap_KEY_4_get, SWIG_Lua_set_immutable },
    { "KEY_5", _wrap_KEY_5_get, SWIG_Lua_set_immutable },
    { "KEY_6", _wrap_KEY_6_get, SWIG_Lua_set_immutable },
    { "KEY_7", _wrap_KEY_7_get, SWIG_Lua_set_immutable },
    { "KEY_8", _wrap_KEY_8_get, SWIG_Lua_set_immutable },
    { "KEY_9", _wrap_KEY_9_get, SWIG_Lua_set_immutable },
    { "KEY_CAPS", _wrap_KEY_CAPS_get, SWIG_Lua_set_immutable },
    { "KEY_SCROLL", _wrap_KEY_SCROLL_get, SWIG_Lua_set_immutable },
    { "KEY_NUM", _wrap_KEY_NUM_get, SWIG_Lua_set_immutable },
    { "KEY_PRINTSCREEN", _wrap_KEY_PRINTSCREEN_get, SWIG_Lua_set_immutable },
    { "KEY_PAUSE", _wrap_KEY_PAUSE_get, SWIG_Lua_set_immutable },
    { "KEY_A", _wrap_KEY_A_get, SWIG_Lua_set_immutable },
    { "KEY_B", _wrap_KEY_B_get, SWIG_Lua_set_immutable },
    { "KEY_C", _wrap_KEY_C_get, SWIG_Lua_set_immutable },
    { "KEY_D", _wrap_KEY_D_get, SWIG_Lua_set_immutable },
    { "KEY_E", _wrap_KEY_E_get, SWIG_Lua_set_immutable },
    { "KEY_F", _wrap_KEY_F_get, SWIG_Lua_set_immutable },
    { "KEY_G", _wrap_KEY_G_get, SWIG_Lua_set_immutable },
    { "KEY_H", _wrap_KEY_H_get, SWIG_Lua_set_immutable },
    { "KEY_I", _wrap_KEY_I_get, SWIG_Lua_set_immutable },
    { "KEY_J", _wrap_KEY_J_get, SWIG_Lua_set_immutable },
    { "KEY_K", _wrap_KEY_K_get, SWIG_Lua_set_immutable },
    { "KEY_L", _wrap_KEY_L_get, SWIG_Lua_set_immutable },
    { "KEY_M", _wrap_KEY_M_get, SWIG_Lua_set_immutable },
    { "KEY_N", _wrap_KEY_N_get, SWIG_Lua_set_immutable },
    { "KEY_O", _wrap_KEY_O_get, SWIG_Lua_set_immutable },
    { "KEY_P", _wrap_KEY_P_get, SWIG_Lua_set_immutable },
    { "KEY_Q", _wrap_KEY_Q_get, SWIG_Lua_set_immutable },
    { "KEY_R", _wrap_KEY_R_get, SWIG_Lua_set_immutable },
    { "KEY_S", _wrap_KEY_S_get, SWIG_Lua_set_immutable },
    { "KEY_T", _wrap_KEY_T_get, SWIG_Lua_set_immutable },
    { "KEY_U", _wrap_KEY_U_get, SWIG_Lua_set_immutable },
    { "KEY_V", _wrap_KEY_V_get, SWIG_Lua_set_immutable },
    { "KEY_W", _wrap_KEY_W_get, SWIG_Lua_set_immutable },
    { "KEY_X", _wrap_KEY_X_get, SWIG_Lua_set_immutable },
    { "KEY_Y", _wrap_KEY_Y_get, SWIG_Lua_set_immutable },
    { "KEY_Z", _wrap_KEY_Z_get, SWIG_Lua_set_immutable },
    { "KEYPAD_SLASH", _wrap_KEYPAD_SLASH_get, SWIG_Lua_set_immutable },
    { "KEYPAD_MUL", _wrap_KEYPAD_MUL_get, SWIG_Lua_set_immutable },
    { "KEYPAD_MINUS", _wrap_KEYPAD_MINUS_get, SWIG_Lua_set_immutable },
    { "KEYPAD_PLUS", _wrap_KEYPAD_PLUS_get, SWIG_Lua_set_immutable },
    { "KEYPAD_ENTER", _wrap_KEYPAD_ENTER_get, SWIG_Lua_set_immutable },
    { "KEYPAD_PERIOD", _wrap_KEYPAD_PERIOD_get, SWIG_Lua_set_immutable },
    { "KEYPAD_DEL", _wrap_KEYPAD_DEL_get, SWIG_Lua_set_immutable },
    { "KEYPAD_0", _wrap_KEYPAD_0_get, SWIG_Lua_set_immutable },
    { "KEYPAD_INS", _wrap_KEYPAD_INS_get, SWIG_Lua_set_immutable },
    { "KEYPAD_1", _wrap_KEYPAD_1_get, SWIG_Lua_set_immutable },
    { "KEYPAD_END", _wrap_KEYPAD_END_get, SWIG_Lua_set_immutable },
    { "KEYPAD_2", _wrap_KEYPAD_2_get, SWIG_Lua_set_immutable },
    { "KEYPAD_DOWN", _wrap_KEYPAD_DOWN_get, SWIG_Lua_set_immutable },
    { "KEYPAD_3", _wrap_KEYPAD_3_get, SWIG_Lua_set_immutable },
    { "KEYPAD_PAGEDOWN", _wrap_KEYPAD_PAGEDOWN_get, SWIG_Lua_set_immutable },
    { "KEYPAD_4", _wrap_KEYPAD_4_get, SWIG_Lua_set_immutable },
    { "KEYPAD_LEFT", _wrap_KEYPAD_LEFT_get, SWIG_Lua_set_immutable },
    { "KEYPAD_5", _wrap_KEYPAD_5_get, SWIG_Lua_set_immutable },
    { "KEYPAD_6", _wrap_KEYPAD_6_get, SWIG_Lua_set_immutable },
    { "KEYPAD_RIGHT", _wrap_KEYPAD_RIGHT_get, SWIG_Lua_set_immutable },
    { "KEYPAD_7", _wrap_KEYPAD_7_get, SWIG_Lua_set_immutable },
    { "KEYPAD_HOME", _wrap_KEYPAD_HOME_get, SWIG_Lua_set_immutable },
    { "KEYPAD_8", _wrap_KEYPAD_8_get, SWIG_Lua_set_immutable },
    { "KEYPAD_UP", _wrap_KEYPAD_UP_get, SWIG_Lua_set_immutable },
    { "KEYPAD_9", _wrap_KEYPAD_9_get, SWIG_Lua_set_immutable },
    { "KEYPAD_PGAGEUP", _wrap_KEYPAD_PGAGEUP_get, SWIG_Lua_set_immutable },
    { "KEY_F1", _wrap_KEY_F1_get, SWIG_Lua_set_immutable },
    { "KEY_F2", _wrap_KEY_F2_get, SWIG_Lua_set_immutable },
    { "KEY_F3", _wrap_KEY_F3_get, SWIG_Lua_set_immutable },
    { "KEY_F4", _wrap_KEY_F4_get, SWIG_Lua_set_immutable },
    { "KEY_F5", _wrap_KEY_F5_get, SWIG_Lua_set_immutable },
    { "KEY_F6", _wrap_KEY_F6_get, SWIG_Lua_set_immutable },
    { "KEY_F7", _wrap_KEY_F7_get, SWIG_Lua_set_immutable },
    { "KEY_F8", _wrap_KEY_F8_get, SWIG_Lua_set_immutable },
    { "KEY_F9", _wrap_KEY_F9_get, SWIG_Lua_set_immutable },
    { "KEY_F10", _wrap_KEY_F10_get, SWIG_Lua_set_immutable },
    { "KEY_F11", _wrap_KEY_F11_get, SWIG_Lua_set_immutable },
    { "KEY_F12", _wrap_KEY_F12_get, SWIG_Lua_set_immutable },
    { "KEY_EQUAL", _wrap_KEY_EQUAL_get, SWIG_Lua_set_immutable },
    { "KEY_LSQBRK", _wrap_KEY_LSQBRK_get, SWIG_Lua_set_immutable },
    { "KEY_RSQBRK", _wrap_KEY_RSQBRK_get, SWIG_Lua_set_immutable },
    { "KEY_SEMICL", _wrap_KEY_SEMICL_get, SWIG_Lua_set_immutable },
    { "KEY_APOSTR", _wrap_KEY_APOSTR_get, SWIG_Lua_set_immutable },
    { "KEY_BACKSL", _wrap_KEY_BACKSL_get, SWIG_Lua_set_immutable },
    { "KEY_SLASH", _wrap_KEY_SLASH_get, SWIG_Lua_set_immutable },
    { "KEY_DE_SS", _wrap_KEY_DE_SS_get, SWIG_Lua_set_immutable },
    { "KEY_DE_ACCENT", _wrap_KEY_DE_ACCENT_get, SWIG_Lua_set_immutable },
    { "KEY_DE_UE", _wrap_KEY_DE_UE_get, SWIG_Lua_set_immutable },
    { "KEY_DE_PLUS", _wrap_KEY_DE_PLUS_get, SWIG_Lua_set_immutable },
    { "KEY_DE_OE", _wrap_KEY_DE_OE_get, SWIG_Lua_set_immutable },
    { "KEY_DE_AE", _wrap_KEY_DE_AE_get, SWIG_Lua_set_immutable },
    { "KEY_DE_HASH", _wrap_KEY_DE_HASH_get, SWIG_Lua_set_immutable },
    { "KEY_DE_LT", _wrap_KEY_DE_LT_get, SWIG_Lua_set_immutable },
    { "KEY_DE_CIRC", _wrap_KEY_DE_CIRC_get, SWIG_Lua_set_immutable },
    { "KEY_FR_UGRAVE", _wrap_KEY_FR_UGRAVE_get, SWIG_Lua_set_immutable },
    { "KEY_FR_MULTIPLY", _wrap_KEY_FR_MULTIPLY_get, SWIG_Lua_set_immutable },
    { "KEY_FR_COMMA", _wrap_KEY_FR_COMMA_get, SWIG_Lua_set_immutable },
    { "KEY_FR_SEMICL", _wrap_KEY_FR_SEMICL_get, SWIG_Lua_set_immutable },
    { "KEY_FR_COLON", _wrap_KEY_FR_COLON_get, SWIG_Lua_set_immutable },
    { "KEY_FR_SS", _wrap_KEY_FR_SS_get, SWIG_Lua_set_immutable },
    { "KEY_FR_RBRACKET", _wrap_KEY_FR_RBRACKET_get, SWIG_Lua_set_immutable },
    { "KEY_FR_EQUAL", _wrap_KEY_FR_EQUAL_get, SWIG_Lua_set_immutable },
    { "KEY_FR_DOLL", _wrap_KEY_FR_DOLL_get, SWIG_Lua_set_immutable },
    { "BUTTON_LEFT", _wrap_BUTTON_LEFT_get, SWIG_Lua_set_immutable },
    { "BUTTON_MIDDLE", _wrap_BUTTON_MIDDLE_get, SWIG_Lua_set_immutable },
    { "BUTTON_RIGHT", _wrap_BUTTON_RIGHT_get, SWIG_Lua_set_immutable },
    {0,0,0}
};

static swig_lua_const_info swig_constants[] = {
    {0,0,0,0,0,0}
};

/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (BEGIN) -------- */

static void *_p_VisParticleEffect_clTo_p_VisTypedEngineObject_cl(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((VisTypedEngineObject_cl *) (VisObject3D_cl *) ((VisParticleEffect_cl *) x));
}
static void *_p_VTransitionStateMachineTo_p_VisTypedEngineObject_cl(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((VisTypedEngineObject_cl *) (IVObjectComponent *) ((VTransitionStateMachine *) x));
}
static void *_p_VDialogTo_p_VisTypedEngineObject_cl(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((VisTypedEngineObject_cl *) (VWindowBase *) ((VDialog *) x));
}
static void *_p_TriggerBoxEntity_clTo_p_VisTypedEngineObject_cl(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((VisTypedEngineObject_cl *) (VisObject3D_cl *)(VisBaseEntity_cl *) ((TriggerBoxEntity_cl *) x));
}
static void *_p_VisBaseEntity_clTo_p_VisTypedEngineObject_cl(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((VisTypedEngineObject_cl *) (VisObject3D_cl *) ((VisBaseEntity_cl *) x));
}
static void *_p_VisPath_clTo_p_VisTypedEngineObject_cl(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((VisTypedEngineObject_cl *) (VisObject3D_cl *) ((VisPath_cl *) x));
}
static void *_p_IVRendererNodeTo_p_VisTypedEngineObject_cl(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((VisTypedEngineObject_cl *)  ((IVRendererNode *) x));
}
static void *_p_VPostProcessingBaseComponentTo_p_VisTypedEngineObject_cl(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((VisTypedEngineObject_cl *) (IVObjectComponent *) ((VPostProcessingBaseComponent *) x));
}
static void *_p_IVObjectComponentTo_p_VisTypedEngineObject_cl(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((VisTypedEngineObject_cl *)  ((IVObjectComponent *) x));
}
static void *_p_VAnimationComponentTo_p_VisTypedEngineObject_cl(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((VisTypedEngineObject_cl *) (IVObjectComponent *) ((VAnimationComponent *) x));
}
static void *_p_VTimedValueComponentTo_p_VisTypedEngineObject_cl(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((VisTypedEngineObject_cl *) (IVObjectComponent *) ((VTimedValueComponent *) x));
}
static void *_p_VisContextCamera_clTo_p_VisTypedEngineObject_cl(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((VisTypedEngineObject_cl *) (VisObject3D_cl *) ((VisContextCamera_cl *) x));
}
static void *_p_VisStaticMeshInstance_clTo_p_VisTypedEngineObject_cl(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((VisTypedEngineObject_cl *)  ((VisStaticMeshInstance_cl *) x));
}
static void *_p_IVisTriggerBaseComponent_clTo_p_VisTypedEngineObject_cl(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((VisTypedEngineObject_cl *) (IVObjectComponent *) ((IVisTriggerBaseComponent_cl *) x));
}
static void *_p_VisTriggerSourceComponent_clTo_p_VisTypedEngineObject_cl(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((VisTypedEngineObject_cl *) (IVObjectComponent *)(IVisTriggerBaseComponent_cl *) ((VisTriggerSourceComponent_cl *) x));
}
static void *_p_VisTriggerTargetComponent_clTo_p_VisTypedEngineObject_cl(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((VisTypedEngineObject_cl *) (IVObjectComponent *)(IVisTriggerBaseComponent_cl *) ((VisTriggerTargetComponent_cl *) x));
}
static void *_p_VisObject3D_clTo_p_VisTypedEngineObject_cl(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((VisTypedEngineObject_cl *)  ((VisObject3D_cl *) x));
}
static void *_p_CubeMapHandle_clTo_p_VisTypedEngineObject_cl(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((VisTypedEngineObject_cl *) (VisObject3D_cl *)(VisBaseEntity_cl *) ((CubeMapHandle_cl *) x));
}
static void *_p_PathCameraEntityTo_p_VisTypedEngineObject_cl(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((VisTypedEngineObject_cl *) (VisObject3D_cl *)(VisBaseEntity_cl *) ((PathCameraEntity *) x));
}
static void *_p_IVTimeOfDayTo_p_VisTypedEngineObject_cl(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((VisTypedEngineObject_cl *)  ((IVTimeOfDay *) x));
}
static void *_p_VWindowBaseTo_p_VisTypedEngineObject_cl(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((VisTypedEngineObject_cl *)  ((VWindowBase *) x));
}
static void *_p_VisLightSource_clTo_p_VisTypedEngineObject_cl(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((VisTypedEngineObject_cl *) (VisObject3D_cl *) ((VisLightSource_cl *) x));
}
static void *_p_VisTriggerSourceComponent_clTo_p_IVisTriggerBaseComponent_cl(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IVisTriggerBaseComponent_cl *)  ((VisTriggerSourceComponent_cl *) x));
}
static void *_p_VisTriggerTargetComponent_clTo_p_IVisTriggerBaseComponent_cl(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IVisTriggerBaseComponent_cl *)  ((VisTriggerTargetComponent_cl *) x));
}
static void *_p_VisStaticMeshInstance_clTo_p_VisObjectKey_cl(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((VisObjectKey_cl *)  ((VisStaticMeshInstance_cl *) x));
}
static void *_p_VisPathNode_clTo_p_VisObjectKey_cl(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((VisObjectKey_cl *)  ((VisPathNode_cl *) x));
}
static void *_p_VisLightSource_clTo_p_VisObjectKey_cl(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((VisObjectKey_cl *) (VisObject3D_cl *) ((VisLightSource_cl *) x));
}
static void *_p_VisBaseEntity_clTo_p_VisObjectKey_cl(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((VisObjectKey_cl *) (VisObject3D_cl *) ((VisBaseEntity_cl *) x));
}
static void *_p_TriggerBoxEntity_clTo_p_VisObjectKey_cl(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((VisObjectKey_cl *) (VisObject3D_cl *)(VisBaseEntity_cl *) ((TriggerBoxEntity_cl *) x));
}
static void *_p_VisContextCamera_clTo_p_VisObjectKey_cl(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((VisObjectKey_cl *) (VisObject3D_cl *) ((VisContextCamera_cl *) x));
}
static void *_p_CubeMapHandle_clTo_p_VisObjectKey_cl(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((VisObjectKey_cl *) (VisObject3D_cl *)(VisBaseEntity_cl *) ((CubeMapHandle_cl *) x));
}
static void *_p_PathCameraEntityTo_p_VisObjectKey_cl(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((VisObjectKey_cl *) (VisObject3D_cl *)(VisBaseEntity_cl *) ((PathCameraEntity *) x));
}
static void *_p_VisObject3D_clTo_p_VisObjectKey_cl(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((VisObjectKey_cl *)  ((VisObject3D_cl *) x));
}
static void *_p_VisPath_clTo_p_VisObjectKey_cl(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((VisObjectKey_cl *) (VisObject3D_cl *) ((VisPath_cl *) x));
}
static void *_p_VisParticleEffect_clTo_p_VisObjectKey_cl(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((VisObjectKey_cl *) (VisObject3D_cl *) ((VisParticleEffect_cl *) x));
}
static void *_p_VPostProcessingBaseComponentTo_p_IVObjectComponent(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IVObjectComponent *)  ((VPostProcessingBaseComponent *) x));
}
static void *_p_VTransitionStateMachineTo_p_IVObjectComponent(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IVObjectComponent *)  ((VTransitionStateMachine *) x));
}
static void *_p_VAnimationComponentTo_p_IVObjectComponent(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IVObjectComponent *)  ((VAnimationComponent *) x));
}
static void *_p_VTimedValueComponentTo_p_IVObjectComponent(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IVObjectComponent *)  ((VTimedValueComponent *) x));
}
static void *_p_IVisTriggerBaseComponent_clTo_p_IVObjectComponent(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IVObjectComponent *)  ((IVisTriggerBaseComponent_cl *) x));
}
static void *_p_VisTriggerSourceComponent_clTo_p_IVObjectComponent(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IVObjectComponent *) (IVisTriggerBaseComponent_cl *) ((VisTriggerSourceComponent_cl *) x));
}
static void *_p_VisTriggerTargetComponent_clTo_p_IVObjectComponent(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((IVObjectComponent *) (IVisTriggerBaseComponent_cl *) ((VisTriggerTargetComponent_cl *) x));
}
static void *_p_TriggerBoxEntity_clTo_p_VisBaseEntity_cl(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((VisBaseEntity_cl *)  ((TriggerBoxEntity_cl *) x));
}
static void *_p_CubeMapHandle_clTo_p_VisBaseEntity_cl(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((VisBaseEntity_cl *)  ((CubeMapHandle_cl *) x));
}
static void *_p_PathCameraEntityTo_p_VisBaseEntity_cl(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((VisBaseEntity_cl *)  ((PathCameraEntity *) x));
}
static void *_p_VisParticleEffect_clTo_p_VTypedObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((VTypedObject *) (VisTypedEngineObject_cl *)(VisObject3D_cl *) ((VisParticleEffect_cl *) x));
}
static void *_p_VisTypedEngineObject_clTo_p_VTypedObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((VTypedObject *)  ((VisTypedEngineObject_cl *) x));
}
static void *_p_VTransitionStateMachineTo_p_VTypedObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((VTypedObject *) (VisTypedEngineObject_cl *)(IVObjectComponent *) ((VTransitionStateMachine *) x));
}
static void *_p_VDialogTo_p_VTypedObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((VTypedObject *) (VisTypedEngineObject_cl *)(VWindowBase *) ((VDialog *) x));
}
static void *_p_TriggerBoxEntity_clTo_p_VTypedObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((VTypedObject *) (VisTypedEngineObject_cl *)(VisObject3D_cl *)(VisBaseEntity_cl *) ((TriggerBoxEntity_cl *) x));
}
static void *_p_VisBaseEntity_clTo_p_VTypedObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((VTypedObject *) (VisTypedEngineObject_cl *)(VisObject3D_cl *) ((VisBaseEntity_cl *) x));
}
static void *_p_VisPath_clTo_p_VTypedObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((VTypedObject *) (VisTypedEngineObject_cl *)(VisObject3D_cl *) ((VisPath_cl *) x));
}
static void *_p_IVRendererNodeTo_p_VTypedObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((VTypedObject *) (VisTypedEngineObject_cl *) ((IVRendererNode *) x));
}
static void *_p_VPostProcessingBaseComponentTo_p_VTypedObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((VTypedObject *) (VisTypedEngineObject_cl *)(IVObjectComponent *) ((VPostProcessingBaseComponent *) x));
}
static void *_p_IVObjectComponentTo_p_VTypedObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((VTypedObject *) (VisTypedEngineObject_cl *) ((IVObjectComponent *) x));
}
static void *_p_VAnimationComponentTo_p_VTypedObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((VTypedObject *) (VisTypedEngineObject_cl *)(IVObjectComponent *) ((VAnimationComponent *) x));
}
static void *_p_VTimedValueComponentTo_p_VTypedObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((VTypedObject *) (VisTypedEngineObject_cl *)(IVObjectComponent *) ((VTimedValueComponent *) x));
}
static void *_p_VisContextCamera_clTo_p_VTypedObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((VTypedObject *) (VisTypedEngineObject_cl *)(VisObject3D_cl *) ((VisContextCamera_cl *) x));
}
static void *_p_VisStaticMeshInstance_clTo_p_VTypedObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((VTypedObject *) (VisTypedEngineObject_cl *) ((VisStaticMeshInstance_cl *) x));
}
static void *_p_IVisTriggerBaseComponent_clTo_p_VTypedObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((VTypedObject *) (VisTypedEngineObject_cl *)(IVObjectComponent *) ((IVisTriggerBaseComponent_cl *) x));
}
static void *_p_VisTriggerSourceComponent_clTo_p_VTypedObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((VTypedObject *) (VisTypedEngineObject_cl *)(IVObjectComponent *)(IVisTriggerBaseComponent_cl *) ((VisTriggerSourceComponent_cl *) x));
}
static void *_p_VisTriggerTargetComponent_clTo_p_VTypedObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((VTypedObject *) (VisTypedEngineObject_cl *)(IVObjectComponent *)(IVisTriggerBaseComponent_cl *) ((VisTriggerTargetComponent_cl *) x));
}
static void *_p_VisObject3D_clTo_p_VTypedObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((VTypedObject *) (VisTypedEngineObject_cl *) ((VisObject3D_cl *) x));
}
static void *_p_CubeMapHandle_clTo_p_VTypedObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((VTypedObject *) (VisTypedEngineObject_cl *)(VisObject3D_cl *)(VisBaseEntity_cl *) ((CubeMapHandle_cl *) x));
}
static void *_p_PathCameraEntityTo_p_VTypedObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((VTypedObject *) (VisTypedEngineObject_cl *)(VisObject3D_cl *)(VisBaseEntity_cl *) ((PathCameraEntity *) x));
}
static void *_p_IVTimeOfDayTo_p_VTypedObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((VTypedObject *) (VisTypedEngineObject_cl *) ((IVTimeOfDay *) x));
}
static void *_p_VWindowBaseTo_p_VTypedObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((VTypedObject *) (VisTypedEngineObject_cl *) ((VWindowBase *) x));
}
static void *_p_VisLightSource_clTo_p_VTypedObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((VTypedObject *) (VisTypedEngineObject_cl *)(VisObject3D_cl *) ((VisLightSource_cl *) x));
}
static void *_p_VDialogTo_p_VWindowBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((VWindowBase *)  ((VDialog *) x));
}
static void *_p_VisLightSource_clTo_p_VisObject3D_cl(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((VisObject3D_cl *)  ((VisLightSource_cl *) x));
}
static void *_p_VisBaseEntity_clTo_p_VisObject3D_cl(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((VisObject3D_cl *)  ((VisBaseEntity_cl *) x));
}
static void *_p_TriggerBoxEntity_clTo_p_VisObject3D_cl(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((VisObject3D_cl *) (VisBaseEntity_cl *) ((TriggerBoxEntity_cl *) x));
}
static void *_p_VisContextCamera_clTo_p_VisObject3D_cl(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((VisObject3D_cl *)  ((VisContextCamera_cl *) x));
}
static void *_p_CubeMapHandle_clTo_p_VisObject3D_cl(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((VisObject3D_cl *) (VisBaseEntity_cl *) ((CubeMapHandle_cl *) x));
}
static void *_p_PathCameraEntityTo_p_VisObject3D_cl(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((VisObject3D_cl *) (VisBaseEntity_cl *) ((PathCameraEntity *) x));
}
static void *_p_VisPath_clTo_p_VisObject3D_cl(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((VisObject3D_cl *)  ((VisPath_cl *) x));
}
static void *_p_VisParticleEffect_clTo_p_VisObject3D_cl(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((VisObject3D_cl *)  ((VisParticleEffect_cl *) x));
}
static swig_type_info _swigt__p_CubeMapHandle_cl = {"_p_CubeMapHandle_cl", "CubeMapHandle_cl *", 0, 0, (void*)&_wrap_class_CubeMapHandle_cl, 0};
static swig_type_info _swigt__p_IVConsoleManager = {"_p_IVConsoleManager", "IVConsoleManager *", 0, 0, (void*)&_wrap_class_IVConsoleManager, 0};
static swig_type_info _swigt__p_IVObjectComponent = {"_p_IVObjectComponent", "IVObjectComponent *", 0, 0, (void*)&_wrap_class_IVObjectComponent, 0};
static swig_type_info _swigt__p_IVRendererNode = {"_p_IVRendererNode", "IVRendererNode *", 0, 0, (void*)&_wrap_class_IVRendererNode, 0};
static swig_type_info _swigt__p_IVTimeOfDay = {"_p_IVTimeOfDay", "IVTimeOfDay *", 0, 0, (void*)&_wrap_class_IVTimeOfDay, 0};
static swig_type_info _swigt__p_IVTimer = {"_p_IVTimer", "IVTimer *", 0, 0, (void*)&_wrap_class_IVTimer, 0};
static swig_type_info _swigt__p_IVisTriggerBaseComponent_cl = {"_p_IVisTriggerBaseComponent_cl", "IVisTriggerBaseComponent_cl *", 0, 0, (void*)&_wrap_class_IVisTriggerBaseComponent_cl, 0};
static swig_type_info _swigt__p_PathCameraEntity = {"_p_PathCameraEntity", "PathCameraEntity *", 0, 0, (void*)&_wrap_class_PathCameraEntity, 0};
static swig_type_info _swigt__p_TriggerBoxEntity_cl = {"_p_TriggerBoxEntity_cl", "TriggerBoxEntity_cl *", 0, 0, (void*)&_wrap_class_TriggerBoxEntity_cl, 0};
static swig_type_info _swigt__p_VAnimationComponent = {"_p_VAnimationComponent", "VAnimationComponent *", 0, 0, (void*)&_wrap_class_VAnimationComponent, 0};
static swig_type_info _swigt__p_VBitmask = {"_p_VBitmask", "VBitmask *", 0, 0, (void*)&_wrap_class_VBitmask, 0};
static swig_type_info _swigt__p_VColorRef = {"_p_VColorRef", "VColorRef *", 0, 0, (void*)&_wrap_class_VColorRef, 0};
static swig_type_info _swigt__p_VDialog = {"_p_VDialog", "VDialog *", 0, 0, (void*)&_wrap_class_VDialog, 0};
static swig_type_info _swigt__p_VDynamicMesh = {"_p_VDynamicMesh", "VDynamicMesh *", 0, 0, (void*)&_wrap_class_VDynamicMesh, 0};
static swig_type_info _swigt__p_VGUIManager = {"_p_VGUIManager", "VGUIManager *", 0, 0, (void*)&_wrap_class_VGUIManager, 0};
static swig_type_info _swigt__p_VPostProcessingBaseComponent = {"_p_VPostProcessingBaseComponent", "VPostProcessingBaseComponent *", 0, 0, (void*)&_wrap_class_VPostProcessingBaseComponent, 0};
static swig_type_info _swigt__p_VScriptApp_wrapper = {"_p_VScriptApp_wrapper", "VScriptApp_wrapper *", 0, 0, (void*)&_wrap_class_VScriptApp_wrapper, 0};
static swig_type_info _swigt__p_VScriptDebug_wrapper = {"_p_VScriptDebug_wrapper", "VScriptDebug_wrapper *", 0, 0, (void*)&_wrap_class_VScriptDebug_wrapper, 0};
static swig_type_info _swigt__p_VScriptDraw_wrapper = {"_p_VScriptDraw_wrapper", "VScriptDraw_wrapper *", 0, 0, (void*)&_wrap_class_VScriptDraw_wrapper, 0};
static swig_type_info _swigt__p_VScriptFileSystem_wrapper = {"_p_VScriptFileSystem_wrapper", "VScriptFileSystem_wrapper *", 0, 0, (void*)&_wrap_class_VScriptFileSystem_wrapper, 0};
static swig_type_info _swigt__p_VScriptInput_wrapper = {"_p_VScriptInput_wrapper", "VScriptInput_wrapper *", 0, 0, (void*)&_wrap_class_VScriptInput_wrapper, 0};
static swig_type_info _swigt__p_VScriptRenderer_wrapper = {"_p_VScriptRenderer_wrapper", "VScriptRenderer_wrapper *", 0, 0, (void*)&_wrap_class_VScriptRenderer_wrapper, 0};
static swig_type_info _swigt__p_VScriptScreen_wrapper = {"_p_VScriptScreen_wrapper", "VScriptScreen_wrapper *", 0, 0, (void*)&_wrap_class_VScriptScreen_wrapper, 0};
static swig_type_info _swigt__p_VScriptUtil_wrapper = {"_p_VScriptUtil_wrapper", "VScriptUtil_wrapper *", 0, 0, (void*)&_wrap_class_VScriptUtil_wrapper, 0};
static swig_type_info _swigt__p_VStringInputMap = {"_p_VStringInputMap", "VStringInputMap *", 0, 0, (void*)&_wrap_class_VStringInputMap, 0};
static swig_type_info _swigt__p_VTextureObject = {"_p_VTextureObject", "VTextureObject *", 0, 0, (void*)&_wrap_class_VTextureObject, 0};
static swig_type_info _swigt__p_VTimedValueComponent = {"_p_VTimedValueComponent", "VTimedValueComponent *", 0, 0, (void*)&_wrap_class_VTimedValueComponent, 0};
static swig_type_info _swigt__p_VTransitionStateMachine = {"_p_VTransitionStateMachine", "VTransitionStateMachine *", 0, 0, (void*)&_wrap_class_VTransitionStateMachine, 0};
static swig_type_info _swigt__p_VTypedObject = {"_p_VTypedObject", "VTypedObject *", 0, 0, (void*)&_wrap_class_VTypedObject, 0};
static swig_type_info _swigt__p_VWindowBase = {"_p_VWindowBase", "VWindowBase *", 0, 0, (void*)&_wrap_class_VWindowBase, 0};
static swig_type_info _swigt__p_VisBaseEntity_cl = {"_p_VisBaseEntity_cl", "VisBaseEntity_cl *", 0, 0, (void*)&_wrap_class_VisBaseEntity_cl, 0};
static swig_type_info _swigt__p_VisContextCamera_cl = {"_p_VisContextCamera_cl", "VisContextCamera_cl *", 0, 0, (void*)&_wrap_class_VisContextCamera_cl, 0};
static swig_type_info _swigt__p_VisGame_cl = {"_p_VisGame_cl", "VisGame_cl *", 0, 0, (void*)&_wrap_class_VisGame_cl, 0};
static swig_type_info _swigt__p_VisLightSource_cl = {"_p_VisLightSource_cl", "VisLightSource_cl *", 0, 0, (void*)&_wrap_class_VisLightSource_cl, 0};
static swig_type_info _swigt__p_VisObject3D_cl = {"_p_VisObject3D_cl", "VisObject3D_cl *", 0, 0, (void*)&_wrap_class_VisObject3D_cl, 0};
static swig_type_info _swigt__p_VisObjectKey_cl = {"_p_VisObjectKey_cl", "VisObjectKey_cl *", 0, 0, (void*)&_wrap_class_VisObjectKey_cl, 0};
static swig_type_info _swigt__p_VisParticleEffect_cl = {"_p_VisParticleEffect_cl", "VisParticleEffect_cl *", 0, 0, (void*)&_wrap_class_VisParticleEffect_cl, 0};
static swig_type_info _swigt__p_VisPathNode_cl = {"_p_VisPathNode_cl", "VisPathNode_cl *", 0, 0, (void*)&_wrap_class_VisPathNode_cl, 0};
static swig_type_info _swigt__p_VisPath_cl = {"_p_VisPath_cl", "VisPath_cl *", 0, 0, (void*)&_wrap_class_VisPath_cl, 0};
static swig_type_info _swigt__p_VisScreenMask_cl = {"_p_VisScreenMask_cl", "VisScreenMask_cl *", 0, 0, (void*)&_wrap_class_VisScreenMask_cl, 0};
static swig_type_info _swigt__p_VisStaticMeshInstance_cl = {"_p_VisStaticMeshInstance_cl", "VisStaticMeshInstance_cl *", 0, 0, (void*)&_wrap_class_VisStaticMeshInstance_cl, 0};
static swig_type_info _swigt__p_VisSurface_cl = {"_p_VisSurface_cl", "VisSurface_cl *", 0, 0, (void*)&_wrap_class_VisSurface_cl, 0};
static swig_type_info _swigt__p_VisTriggerSourceComponent_cl = {"_p_VisTriggerSourceComponent_cl", "VisTriggerSourceComponent_cl *", 0, 0, (void*)&_wrap_class_VisTriggerSourceComponent_cl, 0};
static swig_type_info _swigt__p_VisTriggerTargetComponent_cl = {"_p_VisTriggerTargetComponent_cl", "VisTriggerTargetComponent_cl *", 0, 0, (void*)&_wrap_class_VisTriggerTargetComponent_cl, 0};
static swig_type_info _swigt__p_VisTypedEngineObject_cl = {"_p_VisTypedEngineObject_cl", "VisTypedEngineObject_cl *", 0, 0, (void*)&_wrap_class_VisTypedEngineObject_cl, 0};
static swig_type_info _swigt__p___int64 = {"_p___int64", "__int64 *|LONGLONG *|LONG64 *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_char = {"_p_char", "CHAR *|TCHAR *|char *|CCHAR *|SBYTE *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_float = {"_p_float", "FLOAT *|float *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_hkvAlignedBBox = {"_p_hkvAlignedBBox", "hkvAlignedBBox *", 0, 0, (void*)&_wrap_class_hkvAlignedBBox, 0};
static swig_type_info _swigt__p_hkvMat3 = {"_p_hkvMat3", "hkvMat3 *", 0, 0, (void*)&_wrap_class_hkvMat3, 0};
static swig_type_info _swigt__p_hkvVec3 = {"_p_hkvVec3", "hkvVec3 *", 0, 0, (void*)&_wrap_class_hkvVec3, 0};
static swig_type_info _swigt__p_int = {"_p_int", "BOOL *|INT32 *|VBool *|int *|INT *|INT_PTR *|LONG32 *|SINT *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_long = {"_p_long", "SHANDLE_PTR *|LONG_PTR *|LONG *|HRESULT *|RETVAL *|long *|SLONG *|SSIZE_T *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_VDynamicMesh = {"_p_p_VDynamicMesh", "VDynamicMesh **", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_char = {"_p_p_char", "PTCH *|PCTSTR *|LPCTSTR *|LPTCH *|PUTSTR *|LPUTSTR *|PCUTSTR *|LPCUTSTR *|char **|PTSTR *|LPTSTR *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_unsigned_long = {"_p_p_unsigned_long", "unsigned long **|PLCID *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_short = {"_p_short", "HALF_PTR *|short *|SHORT *|SSHORT *|INT16 *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_signed___int64 = {"_p_signed___int64", "INT64 *|signed __int64 *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_signed_char = {"_p_signed_char", "signed char *|INT8 *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_unsigned___int64 = {"_p_unsigned___int64", "UINT64 *|DWORD64 *|unsigned __int64 *|DWORDLONG *|ULONGLONG *|ULONG64 *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_unsigned_char = {"_p_unsigned_char", "FCHAR *|unsigned char *|UCHAR *|BYTE *|TBYTE *|UINT8 *|UBYTE *|BOOLEAN *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_unsigned_int = {"_p_unsigned_int", "UINT32 *|DWORD32 *|UINT *|unsigned int *|UINT_PTR *|ULONG32 *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_unsigned_long = {"_p_unsigned_long", "HANDLE_PTR *|DWORD *|ULONG_PTR *|DWORD_PTR *|FLONG *|unsigned long *|ULONG *|SIZE_T *|LCID *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_unsigned_short = {"_p_unsigned_short", "WORD *|UHALF_PTR *|unsigned short *|USHORT *|FSHORT *|LANGID *|UINT16 *", 0, 0, (void*)0, 0};

static swig_type_info *swig_type_initial[] = {
  &_swigt__p_CubeMapHandle_cl,
  &_swigt__p_IVConsoleManager,
  &_swigt__p_IVObjectComponent,
  &_swigt__p_IVRendererNode,
  &_swigt__p_IVTimeOfDay,
  &_swigt__p_IVTimer,
  &_swigt__p_IVisTriggerBaseComponent_cl,
  &_swigt__p_PathCameraEntity,
  &_swigt__p_TriggerBoxEntity_cl,
  &_swigt__p_VAnimationComponent,
  &_swigt__p_VBitmask,
  &_swigt__p_VColorRef,
  &_swigt__p_VDialog,
  &_swigt__p_VDynamicMesh,
  &_swigt__p_VGUIManager,
  &_swigt__p_VPostProcessingBaseComponent,
  &_swigt__p_VScriptApp_wrapper,
  &_swigt__p_VScriptDebug_wrapper,
  &_swigt__p_VScriptDraw_wrapper,
  &_swigt__p_VScriptFileSystem_wrapper,
  &_swigt__p_VScriptInput_wrapper,
  &_swigt__p_VScriptRenderer_wrapper,
  &_swigt__p_VScriptScreen_wrapper,
  &_swigt__p_VScriptUtil_wrapper,
  &_swigt__p_VStringInputMap,
  &_swigt__p_VTextureObject,
  &_swigt__p_VTimedValueComponent,
  &_swigt__p_VTransitionStateMachine,
  &_swigt__p_VTypedObject,
  &_swigt__p_VWindowBase,
  &_swigt__p_VisBaseEntity_cl,
  &_swigt__p_VisContextCamera_cl,
  &_swigt__p_VisGame_cl,
  &_swigt__p_VisLightSource_cl,
  &_swigt__p_VisObject3D_cl,
  &_swigt__p_VisObjectKey_cl,
  &_swigt__p_VisParticleEffect_cl,
  &_swigt__p_VisPathNode_cl,
  &_swigt__p_VisPath_cl,
  &_swigt__p_VisScreenMask_cl,
  &_swigt__p_VisStaticMeshInstance_cl,
  &_swigt__p_VisSurface_cl,
  &_swigt__p_VisTriggerSourceComponent_cl,
  &_swigt__p_VisTriggerTargetComponent_cl,
  &_swigt__p_VisTypedEngineObject_cl,
  &_swigt__p___int64,
  &_swigt__p_char,
  &_swigt__p_float,
  &_swigt__p_hkvAlignedBBox,
  &_swigt__p_hkvMat3,
  &_swigt__p_hkvVec3,
  &_swigt__p_int,
  &_swigt__p_long,
  &_swigt__p_p_VDynamicMesh,
  &_swigt__p_p_char,
  &_swigt__p_p_unsigned_long,
  &_swigt__p_short,
  &_swigt__p_signed___int64,
  &_swigt__p_signed_char,
  &_swigt__p_unsigned___int64,
  &_swigt__p_unsigned_char,
  &_swigt__p_unsigned_int,
  &_swigt__p_unsigned_long,
  &_swigt__p_unsigned_short,
};

static swig_cast_info _swigc__p_CubeMapHandle_cl[] = {  {&_swigt__p_CubeMapHandle_cl, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IVConsoleManager[] = {  {&_swigt__p_IVConsoleManager, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IVObjectComponent[] = {  {&_swigt__p_IVObjectComponent, 0, 0, 0},  {&_swigt__p_VPostProcessingBaseComponent, _p_VPostProcessingBaseComponentTo_p_IVObjectComponent, 0, 0},  {&_swigt__p_VTransitionStateMachine, _p_VTransitionStateMachineTo_p_IVObjectComponent, 0, 0},  {&_swigt__p_VAnimationComponent, _p_VAnimationComponentTo_p_IVObjectComponent, 0, 0},  {&_swigt__p_VTimedValueComponent, _p_VTimedValueComponentTo_p_IVObjectComponent, 0, 0},  {&_swigt__p_IVisTriggerBaseComponent_cl, _p_IVisTriggerBaseComponent_clTo_p_IVObjectComponent, 0, 0},  {&_swigt__p_VisTriggerSourceComponent_cl, _p_VisTriggerSourceComponent_clTo_p_IVObjectComponent, 0, 0},  {&_swigt__p_VisTriggerTargetComponent_cl, _p_VisTriggerTargetComponent_clTo_p_IVObjectComponent, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IVRendererNode[] = {  {&_swigt__p_IVRendererNode, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IVTimeOfDay[] = {  {&_swigt__p_IVTimeOfDay, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IVTimer[] = {  {&_swigt__p_IVTimer, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IVisTriggerBaseComponent_cl[] = {  {&_swigt__p_IVisTriggerBaseComponent_cl, 0, 0, 0},  {&_swigt__p_VisTriggerSourceComponent_cl, _p_VisTriggerSourceComponent_clTo_p_IVisTriggerBaseComponent_cl, 0, 0},  {&_swigt__p_VisTriggerTargetComponent_cl, _p_VisTriggerTargetComponent_clTo_p_IVisTriggerBaseComponent_cl, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_PathCameraEntity[] = {  {&_swigt__p_PathCameraEntity, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_TriggerBoxEntity_cl[] = {  {&_swigt__p_TriggerBoxEntity_cl, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_VAnimationComponent[] = {  {&_swigt__p_VAnimationComponent, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_VBitmask[] = {  {&_swigt__p_VBitmask, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_VColorRef[] = {  {&_swigt__p_VColorRef, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_VDialog[] = {  {&_swigt__p_VDialog, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_VDynamicMesh[] = {  {&_swigt__p_VDynamicMesh, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_VGUIManager[] = {  {&_swigt__p_VGUIManager, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_VPostProcessingBaseComponent[] = {  {&_swigt__p_VPostProcessingBaseComponent, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_VScriptApp_wrapper[] = {  {&_swigt__p_VScriptApp_wrapper, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_VScriptDebug_wrapper[] = {  {&_swigt__p_VScriptDebug_wrapper, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_VScriptDraw_wrapper[] = {  {&_swigt__p_VScriptDraw_wrapper, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_VScriptFileSystem_wrapper[] = {  {&_swigt__p_VScriptFileSystem_wrapper, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_VScriptInput_wrapper[] = {  {&_swigt__p_VScriptInput_wrapper, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_VScriptRenderer_wrapper[] = {  {&_swigt__p_VScriptRenderer_wrapper, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_VScriptScreen_wrapper[] = {  {&_swigt__p_VScriptScreen_wrapper, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_VScriptUtil_wrapper[] = {  {&_swigt__p_VScriptUtil_wrapper, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_VStringInputMap[] = {  {&_swigt__p_VStringInputMap, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_VTextureObject[] = {  {&_swigt__p_VTextureObject, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_VTimedValueComponent[] = {  {&_swigt__p_VTimedValueComponent, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_VTransitionStateMachine[] = {  {&_swigt__p_VTransitionStateMachine, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_VTypedObject[] = {  {&_swigt__p_VisParticleEffect_cl, _p_VisParticleEffect_clTo_p_VTypedObject, 0, 0},  {&_swigt__p_VisTypedEngineObject_cl, _p_VisTypedEngineObject_clTo_p_VTypedObject, 0, 0},  {&_swigt__p_VTypedObject, 0, 0, 0},  {&_swigt__p_VTransitionStateMachine, _p_VTransitionStateMachineTo_p_VTypedObject, 0, 0},  {&_swigt__p_VDialog, _p_VDialogTo_p_VTypedObject, 0, 0},  {&_swigt__p_TriggerBoxEntity_cl, _p_TriggerBoxEntity_clTo_p_VTypedObject, 0, 0},  {&_swigt__p_VisBaseEntity_cl, _p_VisBaseEntity_clTo_p_VTypedObject, 0, 0},  {&_swigt__p_VisPath_cl, _p_VisPath_clTo_p_VTypedObject, 0, 0},  {&_swigt__p_IVRendererNode, _p_IVRendererNodeTo_p_VTypedObject, 0, 0},  {&_swigt__p_IVObjectComponent, _p_IVObjectComponentTo_p_VTypedObject, 0, 0},  {&_swigt__p_VAnimationComponent, _p_VAnimationComponentTo_p_VTypedObject, 0, 0},  {&_swigt__p_VTimedValueComponent, _p_VTimedValueComponentTo_p_VTypedObject, 0, 0},  {&_swigt__p_VPostProcessingBaseComponent, _p_VPostProcessingBaseComponentTo_p_VTypedObject, 0, 0},  {&_swigt__p_VisContextCamera_cl, _p_VisContextCamera_clTo_p_VTypedObject, 0, 0},  {&_swigt__p_IVisTriggerBaseComponent_cl, _p_IVisTriggerBaseComponent_clTo_p_VTypedObject, 0, 0},  {&_swigt__p_VisTriggerSourceComponent_cl, _p_VisTriggerSourceComponent_clTo_p_VTypedObject, 0, 0},  {&_swigt__p_VisTriggerTargetComponent_cl, _p_VisTriggerTargetComponent_clTo_p_VTypedObject, 0, 0},  {&_swigt__p_VisStaticMeshInstance_cl, _p_VisStaticMeshInstance_clTo_p_VTypedObject, 0, 0},  {&_swigt__p_CubeMapHandle_cl, _p_CubeMapHandle_clTo_p_VTypedObject, 0, 0},  {&_swigt__p_VisObject3D_cl, _p_VisObject3D_clTo_p_VTypedObject, 0, 0},  {&_swigt__p_PathCameraEntity, _p_PathCameraEntityTo_p_VTypedObject, 0, 0},  {&_swigt__p_IVTimeOfDay, _p_IVTimeOfDayTo_p_VTypedObject, 0, 0},  {&_swigt__p_VWindowBase, _p_VWindowBaseTo_p_VTypedObject, 0, 0},  {&_swigt__p_VisLightSource_cl, _p_VisLightSource_clTo_p_VTypedObject, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_VWindowBase[] = {  {&_swigt__p_VDialog, _p_VDialogTo_p_VWindowBase, 0, 0},  {&_swigt__p_VWindowBase, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_VisBaseEntity_cl[] = {  {&_swigt__p_VisBaseEntity_cl, 0, 0, 0},  {&_swigt__p_TriggerBoxEntity_cl, _p_TriggerBoxEntity_clTo_p_VisBaseEntity_cl, 0, 0},  {&_swigt__p_CubeMapHandle_cl, _p_CubeMapHandle_clTo_p_VisBaseEntity_cl, 0, 0},  {&_swigt__p_PathCameraEntity, _p_PathCameraEntityTo_p_VisBaseEntity_cl, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_VisContextCamera_cl[] = {  {&_swigt__p_VisContextCamera_cl, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_VisGame_cl[] = {  {&_swigt__p_VisGame_cl, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_VisLightSource_cl[] = {  {&_swigt__p_VisLightSource_cl, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_VisObject3D_cl[] = {  {&_swigt__p_VisLightSource_cl, _p_VisLightSource_clTo_p_VisObject3D_cl, 0, 0},  {&_swigt__p_VisBaseEntity_cl, _p_VisBaseEntity_clTo_p_VisObject3D_cl, 0, 0},  {&_swigt__p_TriggerBoxEntity_cl, _p_TriggerBoxEntity_clTo_p_VisObject3D_cl, 0, 0},  {&_swigt__p_CubeMapHandle_cl, _p_CubeMapHandle_clTo_p_VisObject3D_cl, 0, 0},  {&_swigt__p_PathCameraEntity, _p_PathCameraEntityTo_p_VisObject3D_cl, 0, 0},  {&_swigt__p_VisContextCamera_cl, _p_VisContextCamera_clTo_p_VisObject3D_cl, 0, 0},  {&_swigt__p_VisObject3D_cl, 0, 0, 0},  {&_swigt__p_VisPath_cl, _p_VisPath_clTo_p_VisObject3D_cl, 0, 0},  {&_swigt__p_VisParticleEffect_cl, _p_VisParticleEffect_clTo_p_VisObject3D_cl, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_VisObjectKey_cl[] = {  {&_swigt__p_VisStaticMeshInstance_cl, _p_VisStaticMeshInstance_clTo_p_VisObjectKey_cl, 0, 0},  {&_swigt__p_VisPathNode_cl, _p_VisPathNode_clTo_p_VisObjectKey_cl, 0, 0},  {&_swigt__p_VisObjectKey_cl, 0, 0, 0},  {&_swigt__p_VisLightSource_cl, _p_VisLightSource_clTo_p_VisObjectKey_cl, 0, 0},  {&_swigt__p_VisBaseEntity_cl, _p_VisBaseEntity_clTo_p_VisObjectKey_cl, 0, 0},  {&_swigt__p_TriggerBoxEntity_cl, _p_TriggerBoxEntity_clTo_p_VisObjectKey_cl, 0, 0},  {&_swigt__p_CubeMapHandle_cl, _p_CubeMapHandle_clTo_p_VisObjectKey_cl, 0, 0},  {&_swigt__p_PathCameraEntity, _p_PathCameraEntityTo_p_VisObjectKey_cl, 0, 0},  {&_swigt__p_VisContextCamera_cl, _p_VisContextCamera_clTo_p_VisObjectKey_cl, 0, 0},  {&_swigt__p_VisObject3D_cl, _p_VisObject3D_clTo_p_VisObjectKey_cl, 0, 0},  {&_swigt__p_VisPath_cl, _p_VisPath_clTo_p_VisObjectKey_cl, 0, 0},  {&_swigt__p_VisParticleEffect_cl, _p_VisParticleEffect_clTo_p_VisObjectKey_cl, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_VisParticleEffect_cl[] = {  {&_swigt__p_VisParticleEffect_cl, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_VisPathNode_cl[] = {  {&_swigt__p_VisPathNode_cl, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_VisPath_cl[] = {  {&_swigt__p_VisPath_cl, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_VisScreenMask_cl[] = {  {&_swigt__p_VisScreenMask_cl, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_VisStaticMeshInstance_cl[] = {  {&_swigt__p_VisStaticMeshInstance_cl, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_VisSurface_cl[] = {  {&_swigt__p_VisSurface_cl, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_VisTriggerSourceComponent_cl[] = {  {&_swigt__p_VisTriggerSourceComponent_cl, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_VisTriggerTargetComponent_cl[] = {  {&_swigt__p_VisTriggerTargetComponent_cl, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_VisTypedEngineObject_cl[] = {  {&_swigt__p_VisParticleEffect_cl, _p_VisParticleEffect_clTo_p_VisTypedEngineObject_cl, 0, 0},  {&_swigt__p_VisTypedEngineObject_cl, 0, 0, 0},  {&_swigt__p_VTransitionStateMachine, _p_VTransitionStateMachineTo_p_VisTypedEngineObject_cl, 0, 0},  {&_swigt__p_VDialog, _p_VDialogTo_p_VisTypedEngineObject_cl, 0, 0},  {&_swigt__p_TriggerBoxEntity_cl, _p_TriggerBoxEntity_clTo_p_VisTypedEngineObject_cl, 0, 0},  {&_swigt__p_VisBaseEntity_cl, _p_VisBaseEntity_clTo_p_VisTypedEngineObject_cl, 0, 0},  {&_swigt__p_VisPath_cl, _p_VisPath_clTo_p_VisTypedEngineObject_cl, 0, 0},  {&_swigt__p_IVRendererNode, _p_IVRendererNodeTo_p_VisTypedEngineObject_cl, 0, 0},  {&_swigt__p_VPostProcessingBaseComponent, _p_VPostProcessingBaseComponentTo_p_VisTypedEngineObject_cl, 0, 0},  {&_swigt__p_IVObjectComponent, _p_IVObjectComponentTo_p_VisTypedEngineObject_cl, 0, 0},  {&_swigt__p_VAnimationComponent, _p_VAnimationComponentTo_p_VisTypedEngineObject_cl, 0, 0},  {&_swigt__p_VTimedValueComponent, _p_VTimedValueComponentTo_p_VisTypedEngineObject_cl, 0, 0},  {&_swigt__p_VisContextCamera_cl, _p_VisContextCamera_clTo_p_VisTypedEngineObject_cl, 0, 0},  {&_swigt__p_IVisTriggerBaseComponent_cl, _p_IVisTriggerBaseComponent_clTo_p_VisTypedEngineObject_cl, 0, 0},  {&_swigt__p_VisTriggerSourceComponent_cl, _p_VisTriggerSourceComponent_clTo_p_VisTypedEngineObject_cl, 0, 0},  {&_swigt__p_VisTriggerTargetComponent_cl, _p_VisTriggerTargetComponent_clTo_p_VisTypedEngineObject_cl, 0, 0},  {&_swigt__p_VisStaticMeshInstance_cl, _p_VisStaticMeshInstance_clTo_p_VisTypedEngineObject_cl, 0, 0},  {&_swigt__p_CubeMapHandle_cl, _p_CubeMapHandle_clTo_p_VisTypedEngineObject_cl, 0, 0},  {&_swigt__p_VisObject3D_cl, _p_VisObject3D_clTo_p_VisTypedEngineObject_cl, 0, 0},  {&_swigt__p_PathCameraEntity, _p_PathCameraEntityTo_p_VisTypedEngineObject_cl, 0, 0},  {&_swigt__p_IVTimeOfDay, _p_IVTimeOfDayTo_p_VisTypedEngineObject_cl, 0, 0},  {&_swigt__p_VWindowBase, _p_VWindowBaseTo_p_VisTypedEngineObject_cl, 0, 0},  {&_swigt__p_VisLightSource_cl, _p_VisLightSource_clTo_p_VisTypedEngineObject_cl, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p___int64[] = {  {&_swigt__p___int64, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_char[] = {  {&_swigt__p_char, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_float[] = {  {&_swigt__p_float, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_hkvAlignedBBox[] = {  {&_swigt__p_hkvAlignedBBox, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_hkvMat3[] = {  {&_swigt__p_hkvMat3, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_hkvVec3[] = {  {&_swigt__p_hkvVec3, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_int[] = {  {&_swigt__p_int, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_long[] = {  {&_swigt__p_long, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_VDynamicMesh[] = {  {&_swigt__p_p_VDynamicMesh, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_char[] = {  {&_swigt__p_p_char, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_unsigned_long[] = {  {&_swigt__p_p_unsigned_long, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_short[] = {  {&_swigt__p_short, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_signed___int64[] = {  {&_swigt__p_signed___int64, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_signed_char[] = {  {&_swigt__p_signed_char, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_unsigned___int64[] = {  {&_swigt__p_unsigned___int64, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_unsigned_char[] = {  {&_swigt__p_unsigned_char, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_unsigned_int[] = {  {&_swigt__p_unsigned_int, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_unsigned_long[] = {  {&_swigt__p_unsigned_long, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_unsigned_short[] = {  {&_swigt__p_unsigned_short, 0, 0, 0},{0, 0, 0, 0}};

static swig_cast_info *swig_cast_initial[] = {
  _swigc__p_CubeMapHandle_cl,
  _swigc__p_IVConsoleManager,
  _swigc__p_IVObjectComponent,
  _swigc__p_IVRendererNode,
  _swigc__p_IVTimeOfDay,
  _swigc__p_IVTimer,
  _swigc__p_IVisTriggerBaseComponent_cl,
  _swigc__p_PathCameraEntity,
  _swigc__p_TriggerBoxEntity_cl,
  _swigc__p_VAnimationComponent,
  _swigc__p_VBitmask,
  _swigc__p_VColorRef,
  _swigc__p_VDialog,
  _swigc__p_VDynamicMesh,
  _swigc__p_VGUIManager,
  _swigc__p_VPostProcessingBaseComponent,
  _swigc__p_VScriptApp_wrapper,
  _swigc__p_VScriptDebug_wrapper,
  _swigc__p_VScriptDraw_wrapper,
  _swigc__p_VScriptFileSystem_wrapper,
  _swigc__p_VScriptInput_wrapper,
  _swigc__p_VScriptRenderer_wrapper,
  _swigc__p_VScriptScreen_wrapper,
  _swigc__p_VScriptUtil_wrapper,
  _swigc__p_VStringInputMap,
  _swigc__p_VTextureObject,
  _swigc__p_VTimedValueComponent,
  _swigc__p_VTransitionStateMachine,
  _swigc__p_VTypedObject,
  _swigc__p_VWindowBase,
  _swigc__p_VisBaseEntity_cl,
  _swigc__p_VisContextCamera_cl,
  _swigc__p_VisGame_cl,
  _swigc__p_VisLightSource_cl,
  _swigc__p_VisObject3D_cl,
  _swigc__p_VisObjectKey_cl,
  _swigc__p_VisParticleEffect_cl,
  _swigc__p_VisPathNode_cl,
  _swigc__p_VisPath_cl,
  _swigc__p_VisScreenMask_cl,
  _swigc__p_VisStaticMeshInstance_cl,
  _swigc__p_VisSurface_cl,
  _swigc__p_VisTriggerSourceComponent_cl,
  _swigc__p_VisTriggerTargetComponent_cl,
  _swigc__p_VisTypedEngineObject_cl,
  _swigc__p___int64,
  _swigc__p_char,
  _swigc__p_float,
  _swigc__p_hkvAlignedBBox,
  _swigc__p_hkvMat3,
  _swigc__p_hkvVec3,
  _swigc__p_int,
  _swigc__p_long,
  _swigc__p_p_VDynamicMesh,
  _swigc__p_p_char,
  _swigc__p_p_unsigned_long,
  _swigc__p_short,
  _swigc__p_signed___int64,
  _swigc__p_signed_char,
  _swigc__p_unsigned___int64,
  _swigc__p_unsigned_char,
  _swigc__p_unsigned_int,
  _swigc__p_unsigned_long,
  _swigc__p_unsigned_short,
};


/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (END) -------- */

/* -----------------------------------------------------------------------------
 * Type initialization:
 * This problem is tough by the requirement that no dynamic 
 * memory is used. Also, since swig_type_info structures store pointers to 
 * swig_cast_info structures and swig_cast_info structures store pointers back
 * to swig_type_info structures, we need some lookup code at initialization. 
 * The idea is that swig generates all the structures that are needed. 
 * The runtime then collects these partially filled structures. 
 * The SWIG_InitializeModule function takes these initial arrays out of 
 * swig_module, and does all the lookup, filling in the swig_module.types
 * array with the correct data and linking the correct swig_cast_info
 * structures together.
 *
 * The generated swig_type_info structures are assigned staticly to an initial 
 * array. We just loop through that array, and handle each type individually.
 * First we lookup if this type has been already loaded, and if so, use the
 * loaded structure instead of the generated one. Then we have to fill in the
 * cast linked list. The cast data is initially stored in something like a
 * two-dimensional array. Each row corresponds to a type (there are the same
 * number of rows as there are in the swig_type_initial array). Each entry in
 * a column is one of the swig_cast_info structures for that type.
 * The cast_initial array is actually an array of arrays, because each row has
 * a variable number of columns. So to actually build the cast linked list,
 * we find the array of casts associated with the type, and loop through it 
 * adding the casts to the list. The one last trick we need to do is making
 * sure the type pointer in the swig_cast_info struct is correct.
 *
 * First off, we lookup the cast->type name to see if it is already loaded. 
 * There are three cases to handle:
 *  1) If the cast->type has already been loaded AND the type we are adding
 *     casting info to has not been loaded (it is in this module), THEN we
 *     replace the cast->type pointer with the type pointer that has already
 *     been loaded.
 *  2) If BOTH types (the one we are adding casting info to, and the 
 *     cast->type) are loaded, THEN the cast info has already been loaded by
 *     the previous module so we just ignore it.
 *  3) Finally, if cast->type has not already been loaded, then we add that
 *     swig_cast_info to the linked list (because the cast->type) pointer will
 *     be correct.
 * ----------------------------------------------------------------------------- */

#ifdef __cplusplus
extern "C" {
#if 0
} /* c-mode */
#endif
#endif

#if 0
#define SWIGRUNTIME_DEBUG
#endif


SWIGRUNTIME void
SWIG_InitializeModule(void *clientdata) {
  size_t i;
  swig_module_info *module_head, *iter;
  int found, init;

  clientdata = clientdata;

  /* check to see if the circular list has been setup, if not, set it up */
  if (swig_module.next==0) {
    /* Initialize the swig_module */
    swig_module.type_initial = swig_type_initial;
    swig_module.cast_initial = swig_cast_initial;
    swig_module.next = &swig_module;
    init = 1;
  } else {
    init = 0;
  }

  /* Try and load any already created modules */
  module_head = SWIG_GetModule(clientdata);
  if (!module_head) {
    /* This is the first module loaded for this interpreter */
    /* so set the swig module into the interpreter */
    SWIG_SetModule(clientdata, &swig_module);
    module_head = &swig_module;
  } else {
    /* the interpreter has loaded a SWIG module, but has it loaded this one? */
    found=0;
    iter=module_head;
    do {
      if (iter==&swig_module) {
        found=1;
        break;
      }
      iter=iter->next;
    } while (iter!= module_head);

    /* if the is found in the list, then all is done and we may leave */
    if (found) return;
    /* otherwise we must add out module into the list */
    swig_module.next = module_head->next;
    module_head->next = &swig_module;
  }

  /* When multiple interpeters are used, a module could have already been initialized in
     a different interpreter, but not yet have a pointer in this interpreter.
     In this case, we do not want to continue adding types... everything should be
     set up already */
  if (init == 0) return;

  /* Now work on filling in swig_module.types */
#ifdef SWIGRUNTIME_DEBUG
  printf("SWIG_InitializeModule: size %d\n", swig_module.size);
#endif
  for (i = 0; i < swig_module.size; ++i) {
    swig_type_info *type = 0;
    swig_type_info *ret;
    swig_cast_info *cast;
  
#ifdef SWIGRUNTIME_DEBUG
    printf("SWIG_InitializeModule: type %d %s\n", i, swig_module.type_initial[i]->name);
#endif

    /* if there is another module already loaded */
    if (swig_module.next != &swig_module) {
      type = SWIG_MangledTypeQueryModule(swig_module.next, &swig_module, swig_module.type_initial[i]->name);
    }
    if (type) {
      /* Overwrite clientdata field */
#ifdef SWIGRUNTIME_DEBUG
      printf("SWIG_InitializeModule: found type %s\n", type->name);
#endif
      if (swig_module.type_initial[i]->clientdata) {
	type->clientdata = swig_module.type_initial[i]->clientdata;
#ifdef SWIGRUNTIME_DEBUG
      printf("SWIG_InitializeModule: found and overwrite type %s \n", type->name);
#endif
      }
    } else {
      type = swig_module.type_initial[i];
    }

    /* Insert casting types */
    cast = swig_module.cast_initial[i];
    while (cast->type) {
    
      /* Don't need to add information already in the list */
      ret = 0;
#ifdef SWIGRUNTIME_DEBUG
      printf("SWIG_InitializeModule: look cast %s\n", cast->type->name);
#endif
      if (swig_module.next != &swig_module) {
        ret = SWIG_MangledTypeQueryModule(swig_module.next, &swig_module, cast->type->name);
#ifdef SWIGRUNTIME_DEBUG
	if (ret) printf("SWIG_InitializeModule: found cast %s\n", ret->name);
#endif
      }
      if (ret) {
	if (type == swig_module.type_initial[i]) {
#ifdef SWIGRUNTIME_DEBUG
	  printf("SWIG_InitializeModule: skip old type %s\n", ret->name);
#endif
	  cast->type = ret;
	  ret = 0;
	} else {
	  /* Check for casting already in the list */
	  swig_cast_info *ocast = SWIG_TypeCheck(ret->name, type);
#ifdef SWIGRUNTIME_DEBUG
	  if (ocast) printf("SWIG_InitializeModule: skip old cast %s\n", ret->name);
#endif
	  if (!ocast) ret = 0;
	}
      }

      if (!ret) {
#ifdef SWIGRUNTIME_DEBUG
	printf("SWIG_InitializeModule: adding cast %s\n", cast->type->name);
#endif
        if (type->cast) {
          type->cast->prev = cast;
          cast->next = type->cast;
        }
        type->cast = cast;
      }
      cast++;
    }
    /* Set entry in modules->types array equal to the type */
    swig_module.types[i] = type;
  }
  swig_module.types[i] = 0;

#ifdef SWIGRUNTIME_DEBUG
  printf("**** SWIG_InitializeModule: Cast List ******\n");
  for (i = 0; i < swig_module.size; ++i) {
    int j = 0;
    swig_cast_info *cast = swig_module.cast_initial[i];
    printf("SWIG_InitializeModule: type %d %s\n", i, swig_module.type_initial[i]->name);
    while (cast->type) {
      printf("SWIG_InitializeModule: cast type %s\n", cast->type->name);
      cast++;
      ++j;
    }
  printf("---- Total casts: %d\n",j);
  }
  printf("**** SWIG_InitializeModule: Cast List ******\n");
#endif
}

/* This function will propagate the clientdata field of type to
* any new swig_type_info structures that have been added into the list
* of equivalent types.  It is like calling
* SWIG_TypeClientData(type, clientdata) a second time.
*/

SWIGRUNTIME void
SWIG_PropagateClientData(void) {
  size_t i;
  swig_cast_info *equiv;

  for (i = 0; i < swig_module.size; i++) {
    if (swig_module.types[i]->clientdata) {
      equiv = swig_module.types[i]->cast;
      while (equiv) {
        if (!equiv->converter) {
          if (equiv->type && !equiv->type->clientdata)
            SWIG_TypeClientData(equiv->type, swig_module.types[i]->clientdata);
        }
        equiv = equiv->next;
      }
    }
  }
}

#ifdef __cplusplus
#if 0
{ /* c-mode */
#endif
}
#endif



/* Forward declaration of where the user's %init{} gets inserted */
void SWIG_init_user(lua_State* L );
/* this is the initialization function
  added at the very end of the code
  the function is always called SWIG_init, but an eariler #define will rename it
*/
int SWIG_init(lua_State* L)
{
  int i;

  ////////////////////////////////////////////
  //           Vision Extension             //
 
  if(strcmp(SWIG_name, "Vision")!=0)
  {
    swig_module_info *module_head = SWIG_GetModule((void *)L); //the module head is always the VisionLuaModule
   
    if(module_head!=0)
    {
      swig_module_info *iter=module_head;
      do {
        if (iter==&swig_module) {
          return 1; //the module has been loaded, no need to do anything
        }
        iter=iter->next;
      }while (iter!= module_head);
    }
  }
  
	static bool hasSavedClientData = false;
	const int numTypes = sizeof(swig_type_initial) / sizeof(swig_type_info*);
	static swig_type_info* savedClientData[numTypes];
	if ( !hasSavedClientData )
	{
		// Save client data so we can restore it
		hasSavedClientData = true;
		for (int k = 0; k < numTypes; k++)
		{
      if(swig_type_initial[k]!=0)
			  savedClientData[k] = (swig_type_info*)swig_type_initial[k]->clientdata;
      else
        savedClientData[k] = 0;
		}
	}
	else
	{
		// Restore saved client data
		for (int k = 0; k < numTypes; k++)
		{
			if(swig_type_initial[k]!=0)
			{	
				swig_type_initial[k]->clientdata = savedClientData[k];
			}
		}
	}
  
  swig_module.next = 0;

  for (i = 0; i < numTypes; i++)
  {
    if(swig_type_initial[i]!=0)
    {
      swig_type_initial[i]->cast = 0;
      swig_type_initial[i]->dcast = 0;
    }
      
    if(swig_cast_initial[i]!=0)
    {
      for (int castIndex  = 0; swig_cast_initial[i][castIndex].type!=0; castIndex++)
      {
        //reset initial values
        swig_cast_initial[i][castIndex].next = 0;
        swig_cast_initial[i][castIndex].prev = 0;
      }
    }
 
    swig_module.types[i] = 0;
  }

  //            End of Extension            //
  ////////////////////////////////////////////

  /* start with global table */
  lua_pushvalue(L,LUA_GLOBALSINDEX);
  /* SWIG's internal initalisation */
  SWIG_InitializeModule((void*)L);
  SWIG_PropagateClientData();
  /* add a global fn */
  SWIG_Lua_add_function(L,"swig_type",SWIG_Lua_type);
  SWIG_Lua_add_function(L,"swig_equals",SWIG_Lua_equal);
  /* begin the module (its a table with the same name as the module) */
  SWIG_Lua_module_begin(L,SWIG_name);
  /* add commands/functions */
  for (i = 0; swig_commands[i].name; i++){
    SWIG_Lua_module_add_function(L,swig_commands[i].name,swig_commands[i].func);
  }
  /* add variables */
  for (i = 0; swig_variables[i].name; i++){
    SWIG_Lua_module_add_variable(L,swig_variables[i].name,swig_variables[i].get,swig_variables[i].set);
  }
  /* set up base class pointers (the hierachy) */
  for (i = 0; swig_types[i]; i++){
    if (swig_types[i]->clientdata){
      SWIG_Lua_init_base_class(L,(swig_lua_class*)(swig_types[i]->clientdata));
    }
  }
  /* additional registration structs & classes in lua */
  for (i = 0; swig_types[i]; i++){
    if (swig_types[i]->clientdata){
      SWIG_Lua_class_register(L,(swig_lua_class*)(swig_types[i]->clientdata));
    }
  }
  /* constants */
  SWIG_Lua_InstallConstants(L,swig_constants);
  /* invoke user-specific initialization */
  SWIG_init_user(L);
  /* end module */
  lua_pop(L,1);  /* tidy stack (remove module table)*/
  lua_pop(L,1);  /* tidy stack (remove global table)*/
  return 1;
}


const char* SWIG_LUACODE=
  "";

void SWIG_init_user(lua_State* L)
{
  /* exec Lua code if applicable */
  SWIG_Lua_dostring(L,SWIG_LUACODE);
}

void VSWIG_Lua_get_class_registry(lua_State* L){ SWIG_Lua_get_class_registry(L); }
int  VSWIG_Lua_ConvertPtr(lua_State* L,int index,void** ptr,swig_type_info *type,int flags){ return SWIG_Lua_ConvertPtr(L,index,ptr,type,flags); }
void VSWIG_Lua_NewPointerObj(lua_State* L,void* ptr,swig_type_info *type, int own){ SWIG_Lua_NewPointerObj(L,ptr,type,own); }
void * VSWIG_TypeCast(swig_cast_info *ty, void *ptr, int *newmemory){ return SWIG_TypeCast(ty,ptr,newmemory); }
swig_cast_info *VSWIG_TypeCheckStruct(swig_type_info *from, swig_type_info *ty){ return SWIG_TypeCheckStruct(from,ty); }
void VSWIG_VisionLuaClassSet(lua_State* L) { VisionLuaClassSet(L); }
void VSWIG_VisionLuaClassGet(lua_State* L) { VisionLuaClassGet(L); }
swig_cast_info *VSWIG_TypeCheck(const char * fromName, swig_type_info *ty) { return SWIG_TypeCheck(fromName,ty); }
const char *VSWIG_Lua_typename(lua_State *L, int tp){ return SWIG_Lua_typename(L, tp); }

#if defined (__SNC__)
#pragma diag_pop
#pragma diag_pop
#pragma diag_pop
#endif

#if defined(__ghs__)
#pragma ghs endnowarning
#endif

#endif // _VISION_DOC
