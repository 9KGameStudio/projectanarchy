/*
 *
 * Confidential Information of Telekinesys Research Limited (t/a Havok). Not for disclosure or distribution without Havok's
 * prior written consent. This software contains code, techniques and know-how which is confidential and proprietary to Havok.
 * Product and Trade Secret source code contains trade secrets of Havok. Havok Software (C) Copyright 1999-2014 Telekinesys Research Limited t/a Havok. All Rights Reserved. Use of this software is subject to the terms of an end user license agreement.
 *
 */

/* -----------------------------------------------------------------------------
 * vision.i
 *
 * SWIG library file to support Vision types (windows.i is still required).
 * ----------------------------------------------------------------------------- */
 
typedef long SLONG;
typedef long RETVAL;
typedef short SSHORT;
typedef int VBool;
typedef char SBYTE;
typedef unsigned char UBYTE;
typedef int SINT;

%{
  // Redefine SWIG_fail_* macros to make them display file and line information
  // See http://stackoverflow.com/questions/14664541/line-number-where-swig-runtimeerror-occurs
  SWIGRUNTIME void SWIG_push_fail_arg_info(lua_State* L, const char* func_name, int argnum, const char* expected, const char* actual)
  {
    lua_Debug ar;
    lua_getstack(L, 1, &ar);
    lua_getinfo(L, "nSl", &ar);
    lua_pushfstring(L,"Error (%s:%d) in %s (arg %d), expected '%s' got '%s'", ar.source,ar.currentline,func_name,argnum,expected,actual);
  }
  
  SWIGRUNTIME void SWIG_push_fail_check_num_args_info(lua_State* L, const char* func_name, int a, int b, int c)
  {
    lua_Debug ar;
    lua_getstack(L, 1, &ar);
    lua_getinfo(L, "nSl", &ar);
    lua_pushfstring(L,"Error (%s:%d) in %s expected %d..%d args, got %d",ar.source,ar.currentline,func_name,a,b,lua_gettop(L));
  }
  
  #undef SWIG_fail_arg
  #define SWIG_fail_arg(func_name,argnum,type) \
    {SWIG_push_fail_arg_info(L,func_name,argnum,type,SWIG_Lua_typename(L,argnum));\
    goto fail;}
  
  #undef SWIG_check_num_args
  #define SWIG_check_num_args(func_name,a,b) \
    if (lua_gettop(L)<a || lua_gettop(L)>b) \
    { SWIG_push_fail_check_num_args_info(L,func_name,a,b,lua_gettop(L));\
    goto fail;}
%}

// Override out typemap for all pointer types.
// If derived from VTypedObject, go via our object proxy implementation which will automatically push the most derived type instead.
%typemap(out) SWIGTYPE *
%{
  if(VTraits::IsBaseOf<VTypedObject, $*1_type>::value)
  {
    LUA_PushObjectProxy(L, (VTypedObject*)$1); SWIG_arg++;
  }
  else
  {
    SWIG_NewPointerObj(L,$1,$descriptor,$owner); SWIG_arg++;
  }
%}

// Check that this != NULL for objects derived from VTypedObject - this happens when a Lua wrapper references an already deleted object
%typemap(check) SWIGTYPE *self %{
  if (VTraits::IsBaseOf<VTypedObject, $*1_type>::value && !$1) {
    SWIG_push_fail_arg_info(L, "$symname", 1, "$1_type", "deleted native object");
    SWIG_fail;
  }
%}

// hkvResult is converted to boolean
%typemap(out) hkvResult %{
  lua_pushboolean(L, $1 == HKV_SUCCESS); SWIG_arg++;
%}

// Typemaps for VMap inputs
%typemap(in) const VMap<VString,VString>& (VMap<VString,VString> temp)
%{
  $1 = &temp;
  lua_pushnil(L);
  while(lua_next(L, $argnum) != 0)
  {
    if(!lua_isstring(L, -2))
    {
      SWIG_push_fail_arg_info(L, "$symname", $argnum, "table of string keys", "table entry with non-string key");
      SWIG_fail;
    }

    if(!lua_isstring(L, -1))
    {
      SWIG_push_fail_arg_info(L, "$symname", $argnum, "table of string values", "table entry with non-string value");
      SWIG_fail;
    }

    // Duplicate key because lua_tostring changes the value on the stack, confusing lua_next
    lua_pushvalue(L, -2);
    (*$1)[lua_tostring(L, -1)] = lua_tostring(L, -2);
    lua_pop(L, 2);
  }
%}

%typemap(typecheck,precedence=SWIG_TYPECHECK_POINTER) const VMap<VString,VString>& {
   $1 = lua_istable(L, $argnum);
}

// Typemaps for VMap outputs - only defined for OUTPUT parameters to avoid copying return values
%typemap(in, numinputs=0) VMap<VString,VString>& OUTPUT(VMap<VString,VString> temp)
%{
  $1 = &temp;
%}

%typemap(argout) VMap<VString,VString>& OUTPUT(VString key, VString value, VPOSITION pos)
%{
  lua_createtable(L, 0, $1->GetCount());
  
  pos = $1->GetStartPosition();
  while(pos)
  {
    $1->GetNextPair(pos, key, value);
    lua_pushstring(L, value);
    lua_setfield(L, -2, key);
  }
  SWIG_arg++;
%}


%define VSWIG_DECLARE_POD(CLASS)
  
  // Disable SwigValueWrapper which allocates memory for each copied intermediate object
  %feature("novaluewrapper") CLASS;

  // Push object onto the stack, but allocate user data and object in one allocation.
  // The object pointer of the user data points into itself, so it is fully compatible
  // with the user data generated by SWIG_NewPointerObj.
  %typemap(out) CLASS
  %{
    SWIG_Lua_NewPodObj(L,&$1,$descriptor(CLASS*)); SWIG_arg++;
  %}
  %typemap(out) CLASS const
  %{
    SWIG_Lua_NewPodObj(L,&$1,$descriptor(CLASS*)); SWIG_arg++;
  %}

  // Same as above, but if the object has already been newed anyway, just use the existing pointer
  %typemap(out) CLASS*
  %{
    if($owner) // Owned by Lua, wrap the pointer
    {
      SWIG_NewPointerObj(L,$1,$descriptor,$owner); SWIG_arg++;
    }
    else // Not owned by Lua, copy the contents
    {
      SWIG_Lua_NewPodObj(L,$1,$descriptor); SWIG_arg++;
    }
  %}

  %typemap(out) CLASS* const
  %{
    if($owner) // Owned by Lua, wrap the pointer
    {
      SWIG_NewPointerObj(L,$1,$descriptor,$owner); SWIG_arg++;
    }
    else // Not owned by Lua, copy the contents
    {
      SWIG_Lua_NewPodObj(L,$1,$descriptor); SWIG_arg++;
    }
  %}

  // Parameters named OUTPUT are converted to return values - adapted from SWIG's implementation for primitive types in typemaps.i.
  %typemap(in, numinputs=0) CLASS *OUTPUT (CLASS temp)
  %{
    $1 = &temp;
  %}
  %typemap(argout) CLASS *OUTPUT
  %{
    SWIG_Lua_NewPodObj(L,$1,$descriptor); SWIG_arg++;
  %}

  %typemap(in) CLASS &OUTPUT = CLASS *OUTPUT;
  %typemap(argout) CLASS &OUTPUT = CLASS *OUTPUT;
  
%enddef

VSWIG_DECLARE_POD(hkvVec2);
VSWIG_DECLARE_POD(hkvVec3);
VSWIG_DECLARE_POD(hkvVec4);
VSWIG_DECLARE_POD(hkvMat3);
VSWIG_DECLARE_POD(hkvMat4);
VSWIG_DECLARE_POD(hkvPlane);
VSWIG_DECLARE_POD(hkvQuat);
VSWIG_DECLARE_POD(hkvAlignedBBox);
VSWIG_DECLARE_POD(hkvBoundingSphere);
VSWIG_DECLARE_POD(VColorRef);

%define VSWIG_CREATE_CAST_UNSAFE(CAST_TO_CLASS)

  static CAST_TO_CLASS* Cast(unsigned long * lObject) 
  {
    return (CAST_TO_CLASS *) lObject;
  }
  
%enddef

%define VSWIG_CONVERT_BOOL_GETTER_CONST(METHOD_NAME)
  bool METHOD_NAME() const
  {
    return self->METHOD_NAME()==TRUE;
  }
%enddef

%define VSWIG_CONVERT_BOOL_GETTER(METHOD_NAME)
  bool METHOD_NAME()
  {
    return self->METHOD_NAME()==TRUE;
  }
%enddef

%define VSWIG_CONVERT_BOOL_SETTER(METHOD_NAME)
  void METHOD_NAME(bool bValue)
  {
    self->METHOD_NAME(bValue);
  }
%enddef

%define VSWIG_BITMASK_GETTER_CONST(METHOD_NAME)
  VBitmask METHOD_NAME() const
  {
    return VBitmask(self->METHOD_NAME());
  }
%enddef

%define VSWIG_BITMASK_GETTER_CONST_RENAME(METHOD_NAME, RENAME_TO)
  VBitmask RENAME_TO() const
  {
    return VBitmask(self->METHOD_NAME());
  }
%enddef

%define VSWIG_BITMASK_SETTER(METHOD_NAME)
  void METHOD_NAME(VBitmask * pBitmask)
  {
    if(pBitmask) self->METHOD_NAME(pBitmask->Get());
  }
%enddef

%define VSWIG_BITMASK_SETTER_RENAME(METHOD_NAME, RENAME_TO)
  void RENAME_TO(VBitmask * pBitmask)
  {
    if(pBitmask) self->METHOD_NAME(pBitmask->Get());
  }
%enddef

%define VSWIG_RETURN_BY_VALUE_CONST(TYPE, METHOD_NAME)
  TYPE METHOD_NAME() const
  {
    return TYPE(self->METHOD_NAME());
  }
%enddef

%define VSWIG_ENSURE_GUI_CONTEXT(MANAGER, CONTEXT)
  IVGUIContext *CONTEXT = MANAGER->Contexts().Count()>0 ? MANAGER->Contexts().GetAt(0) : new VGUIMainContext(MANAGER);
  VASSERT_MSG(CONTEXT!=NULL, "Could not find or create GUI context!");
  CONTEXT->SetActivate(true);
%enddef

%define VSWIG_CREATE_CONCAT(TYPE, SIZE, FORMAT_STRING, ...)
%native(TYPE##___concat) int TYPE##_Concat(lua_State *L);
%{
  SWIGINTERN int TYPE##_Concat(lua_State *L)
  {
    //this will move this function to the method table of the specified class
    IS_MEMBER_OF(TYPE)
    
    bool ARGS_OK = true;
    
    const char *pszString = NULL;
    int iIndex = -1;
    
    //The concat operator allows "foo"..self and self.."bar" so that
    //we have to consider self as first and as second stack element.
    
    //handle string as first (top) element
    if(lua_isstring(L,iIndex))
    {
      pszString = lua_tostring(L,iIndex);
      iIndex--;
    }
    
    SWIG_CONVERT_POINTER(L, iIndex, TYPE, self)
    iIndex--;
    
    //handle string as second element
    if(iIndex==-2)
    {
      pszString = lua_tostring(L,iIndex);
    }
        
    unsigned int uiLen = (unsigned int) strlen(pszString);
    char *pszBuffer = new char[uiLen+SIZE];
   
    sprintf(pszBuffer, FORMAT_STRING, ##__VA_ARGS__); //format as requested
    
    //the new buffer should have the size of the old string and the new format string
    VASSERT_MSG(SIZE>(strlen(pszBuffer)+uiLen), "Please increase your temp buffer size!");
    
    //append or prepend old buffer buffer (depending on the position inside the lua stack)
    if(iIndex==-3) //append old string
    {
      memcpy(pszBuffer+strlen(pszBuffer),pszString,uiLen+1); //also copy the terminator at the end
    }
    else //prepend old string
    {
      memmove(pszBuffer+uiLen,pszBuffer, strlen(pszBuffer)+1); //also move the terminator at the end
      memcpy(pszBuffer,pszString,uiLen); //insert the old string
    }

    lua_pushstring(L, pszBuffer);
  
    V_SAFE_DELETE_ARRAY(pszBuffer);

    return 1;
  }
%}
%enddef

%define VSWIG_CREATE_TOSTRING(TYPE, FORMAT_STRING, ...)
%native(TYPE##___tostring) int TYPE##_ToString(lua_State *L);
%{
  SWIGINTERN int TYPE##_ToString(lua_State *L)
  {
    //this will move this function to the method table of the specified class
    IS_MEMBER_OF(TYPE)
    
    SWIG_CONVERT_POINTER(L, -1, TYPE, self)
    
    char pszBuffer[1024];
    
    sprintf(pszBuffer, FORMAT_STRING, ##__VA_ARGS__); //format as requested
      
    lua_pushstring(L, pszBuffer);
    
    return 1;
  }
%}
%enddef

%define VSWIG_CREATE_TOSTRING_EX(TYPE, COMMANDS, FORMAT_STRING, ...)
%native(TYPE##___tostring) int TYPE##_ToString(lua_State *L);
%{
  SWIGINTERN int TYPE##_ToString(lua_State *L)
  {
    //this will move this function to the method table of the specified class
    IS_MEMBER_OF(TYPE)
    
    SWIG_CONVERT_POINTER(L, -1, TYPE, self)
    
    char pszBuffer[1024];
    
    COMMANDS
    
    sprintf(pszBuffer, FORMAT_STRING, ##__VA_ARGS__); //format as requested
      
    lua_pushstring(L, pszBuffer);
    
    return 1;
  }
%}
%enddef

%typemap(in, numinputs=0) VCaptureSwigEnvironment*(VCaptureSwigEnvironment temp(L, SWIG_arg))
{
  $1 = &temp;
}

%typemap(argout) VCaptureSwigEnvironment*
{
   if($1->HasFailed())
   {
     lua_Debug ar;
     lua_getstack(L, 1, &ar);
     lua_getinfo(L, "nSl", &ar);
     lua_pushfstring(L,"Error (%s:%d) in %s, %s", ar.source, ar.currentline, "$symname", $1->GetErrorMessage());
     SWIG_fail;
   }
}

/*
 * Havok SDK - Base file, BUILD(#20140618)
 * 
 * Confidential Information of Havok.  (C) Copyright 1999-2014
 * Telekinesys Research Limited t/a Havok. All Rights Reserved. The Havok
 * Logo, and the Havok buzzsaw logo are trademarks of Havok.  Title, ownership
 * rights, and intellectual property rights in the Havok software remain in
 * Havok and/or its suppliers.
 * 
 * Use of this software for evaluation purposes is subject to and indicates
 * acceptance of the End User licence Agreement for this product. A copy of
 * the license is included with this software and is also available from salesteam@havok.com.
 * 
 */
