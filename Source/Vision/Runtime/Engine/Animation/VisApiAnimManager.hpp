/*
 *
 * Confidential Information of Telekinesys Research Limited (t/a Havok). Not for disclosure or distribution without Havok's
 * prior written consent. This software contains code, techniques and know-how which is confidential and proprietary to Havok.
 * Product and Trade Secret source code contains trade secrets of Havok. Havok Software (C) Copyright 1999-2013 Telekinesys Research Limited t/a Havok. All Rights Reserved. Use of this software is subject to the terms of an end user license agreement.
 *
 */

/// \file VisApiAnimManager.hpp

#ifndef VIS_ANIM_MANAGER_HPP_INCLUDED
#define VIS_ANIM_MANAGER_HPP_INCLUDED

#include <Vision/Runtime/Engine/Mesh/VisApiModel.hpp>

class VisAnimSequenceSetManager_cl;
class VisVertexAnimResult_cl;

#define EVENTIDFLAG_STRING  0x80000000

/// \brief
///   Manager that keeps global animation data like GlobalTempVertexBuffer and SequenceSetManager.
/// 
/// Functions can be globally accessed via the static Vision::Animations instance.
/// 
/// GlobalTempVertexBuffer and GlobalTempTangentBuffer is a temporary buffer used by all animated
/// entities to do vertex animations and skinning.
/// 
/// SequenceSetManager handles the resource management for all loaded animationset files.
class VisAnimManager_cl
{
public:

  ///
  /// @name Constructor / Destructor
  /// @{
  ///

  /// \brief
  ///   Constructor of the animation manager class.
  VISION_APIFUNC VisAnimManager_cl();


  /// \brief
  ///   Destructor
  VISION_APIFUNC ~VisAnimManager_cl();

  ///
  /// @}
  ///

  ///
  /// @name Access Global Vertex Buffers
  /// @{
  ///


  /// \brief
  ///   Returns a pointer to the global vertex buffer.
  /// 
  /// Do not cache the results in this buffer.
  /// 
  /// \return
  ///   SkinningVertex_t* pBuffer: pointer to an array of vertices.
  VISION_APIFUNC SkinningVertex_t* GetGlobalVertexBuffer(void);

  /// \brief
  ///   Returns a pointer to the global sequence set resource manager.
  /// 
  /// The sequence set manager of class VisAnimSequenceSetManager_cl is a resource manager that
  /// handles all loaded animation (.anim) files.
  /// 
  /// \return
  ///   VisAnimSequenceSetManager_cl* pManager: pointer to sequence set manager.
  inline VisAnimSequenceSetManager_cl* GetSequenceSetManager(void) 
  {
    return &g_SequenceSetManager;
  }


  /// \brief
  ///   Returns the temporary matrix array that is used for skinning matrices.
  /// 
  /// Do not cache the results in this buffer.
  /// 
  /// \return
  ///   hkvMat4* pBuffer: pointer to global skinning matrix array.
  VISION_APIFUNC hkvMat4* GetGlobalSkinningMatrices(void);
  
  ///
  /// @}
  ///

  ///
  /// @name Animation Events
  /// @{
  ///


  /// \brief
  ///   Converts the passed event key string into an integer event ID.
  /// 
  /// The function first tries to find an event of the same name (case insensitive) and returns its
  /// id.
  /// 
  /// The IDs remain registered until the engine is de-initialized.
  /// 
  /// \param szEvent
  ///   string that defines the event.
  /// 
  /// \return
  ///   int iID: registration id for the event string.
  inline int RegisterEvent(const char* szEvent)
  {
    VASSERT(szEvent); 
    return m_EventList.AddUniqueString(szEvent)|EVENTIDFLAG_STRING;
  }


  /// \brief
  ///   Searches for an existing event string (case insensitive) and returns its id.
  /// 
  /// The ID is a nonzero value and has the highest bit set. The return value is 0 in case the
  /// string is not a registered event.
  /// 
  /// \param szEvent
  ///   string to search for.
  /// 
  /// \return
  ///   int iID: registration id for the event string.
  inline int LookUpEvent(const char* szEvent)
  {
    VASSERT(szEvent); 
    int iID = m_EventList.FindString(szEvent);
    if (iID>=0)
      return iID|EVENTIDFLAG_STRING;
    return 0; ///< not found
  }


  /// \brief
  ///   Returns the corresponding event string for the specified ID.
  /// 
  /// The ID must be a string ID generated by the RegisterEvent function.
  /// 
  /// \param iEventID
  ///   registration ID for the event string. The ID must be in valid range.
  /// 
  /// \return
  ///   const char* szEvent: string that represents this ID.
  inline const char* GetEventString(int iEventID)
  {
    VASSERT(IsStringEvent(iEventID)); 
    return m_EventList[iEventID&(~EVENTIDFLAG_STRING)];
  }

  /// \brief
  ///   Indicates whether the passed ID represents a string event or an absolute ID
  inline bool IsStringEvent(int iEventID) const
  {
    return (iEventID & EVENTIDFLAG_STRING)!=0;
  }

  /// \brief
  ///   Checks whether the passed ID is a valid event ID
  /// 
  /// valid string IDs have to be registered via the RegisterEvent function, absolute IDs must not
  /// have the highest bit set
  /// 
  /// \param iEventID
  ///   Event ID to test
  /// 
  /// \return
  ///   bool bResult : true if ID is valid
  inline bool IsValidEventID(int iEventID) const 
  {
    if (IsStringEvent(iEventID))
    {
      iEventID &= (~EVENTIDFLAG_STRING);
      return (iEventID>=0 && iEventID<m_EventList.GetLength());
    }
    return true;
  }

  /// \brief
  ///   Clears the list of all registered events. Do not use.
  /// 
  /// Should not be called because it messes with all IDs that are still being used.
  /// 
  /// \return
  ///   Nothing.
  inline void RemoveAllEventRegistrations(void)
  {
    m_EventList.Reset();
  }


  /// \brief
  ///   Returns the global status of using separate system memory buffers for each animation
  ///   config.
  /// 
  /// If the status is true, each config uses its own buffer to perform the skinning, otherwise one
  /// global buffer is used.
  /// 
  /// \return
  ///   bool bStatus: indicating whether unique buffers are used
  inline bool GetForceConfigsToUseExtraVertexBuffer(void)
  {
    return m_bForceConfigsUseExtraVertexBuffer;
  }


  /// \brief
  ///   Sets the global status of using separate system memory buffers for each animation config.
  /// 
  /// If the status is true, each config uses its own buffer to perform the skinning, otherwise one
  /// global buffer is used.
  /// 
  /// The default is set to false.
  /// 
  /// \param bForce
  ///   The new status.
  /// 
  /// \return
  ///   Nothing.
  inline void SetForceConfigsToUseExtraVertexBuffer(bool bForce=true)
  {
    m_bForceConfigsUseExtraVertexBuffer = bForce;
  }


  /// \brief
  ///   Returns the global status of using separate collision buffers for each animation config.
  /// 
  /// \return
  ///   bool bStatus: indicating whether unique buffers are used
  inline bool GetForceConfigsToUseCollisionBuffer(void)
  {
    return m_bForceConfigsUseCollisionBuffer;
  }


  /// \brief
  ///   Sets the global status of using separate collision buffers for each animation config.
  /// 
  /// The default is set to false.
  /// 
  /// \param bForce
  ///   The new status.
  inline void SetForceConfigsToUseCollisionBuffer(bool bForce=true) 
  {
    m_bForceConfigsUseCollisionBuffer = bForce;
  }

protected:
  // global sequence set manager; accessible via GetSequenceSetManager
  VISION_APIDATA static VisAnimSequenceSetManager_cl g_SequenceSetManager;

  unsigned int m_iCurrentGlobalVertexBufferSize;// max number of vertices
  SkinningVertex_t* m_pGlobalVertexBuffer;      ///< vertex position/normal

  // buffer to hold final skinning matrices
  hkvMat4* m_pGlobalSkinningMatrices;
  int m_iGlobalSkinningMatricesCount;

  VStrList m_EventList;

  bool m_bForceConfigsUseExtraVertexBuffer;  ///< forces every config to use it's own vertexbuffer and not the global one 
  bool m_bForceConfigsUseCollisionBuffer;

  ///
  /// @}
  ///

};

#endif //VIS_ANIM_MANAGER_HPP_INCLUDED

/*
 * Havok SDK - Base file, BUILD(#20131019)
 * 
 * Confidential Information of Havok.  (C) Copyright 1999-2013
 * Telekinesys Research Limited t/a Havok. All Rights Reserved. The Havok
 * Logo, and the Havok buzzsaw logo are trademarks of Havok.  Title, ownership
 * rights, and intellectual property rights in the Havok software remain in
 * Havok and/or its suppliers.
 * 
 * Use of this software for evaluation purposes is subject to and indicates
 * acceptance of the End User licence Agreement for this product. A copy of
 * the license is included with this software and is also available from salesteam@havok.com.
 * 
 */
