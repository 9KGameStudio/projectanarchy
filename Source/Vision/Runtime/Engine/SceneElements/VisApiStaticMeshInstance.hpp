/*
 *
 * Confidential Information of Telekinesys Research Limited (t/a Havok). Not for disclosure or distribution without Havok's
 * prior written consent. This software contains code, techniques and know-how which is confidential and proprietary to Havok.
 * Product and Trade Secret source code contains trade secrets of Havok. Havok Software (C) Copyright 1999-2013 Telekinesys Research Limited t/a Havok. All Rights Reserved. Use of this software is subject to the terms of an end user license agreement.
 *
 */

/// \file VisApiStaticMeshInstance.hpp

#ifndef DEFINE_VISAPISTATICMESHINSTANCE
#define DEFINE_VISAPISTATICMESHINSTANCE

#include <Vision/Runtime/Engine/SceneElements/VisApiStaticGeometryInstance.hpp>

class VisStaticSubmeshInstance_cl;

/// \brief
///   Class representing an instance of static geometry (i.e., typically an instance of the
///   geometry contained in a vmesh file).
/// 
/// A VisStaticMeshInstance_cl object can be created by calling VisStaticMesh_cl::CreateInstance.
/// 
/// VisStaticMeshInstance_cl are the "typical" static scene elements in the Vision engine which
/// make up most of the static part of a scene. 
/// 
/// Additional instances of the same mesh typically take almost no additional memory.
/// 
/// For better rendering and management performance, static mesh instances are split into
/// VisStaticSubmeshInstance_cl objects (each of which corresponds to a VisStaticSubmesh_cl). Only
/// the submesh instances, not the mesh instances, can be rendered and used in visibility
/// determination. This is due to the fact that VisStaticMeshInstance_cl objects can be huge and
/// hold a lot of geometry and materials.
class VisStaticMeshInstance_cl : public VisTypedEngineObject_cl, public VRefCounter, 
  public VisObjectKey_cl, public VUserDataObj, public VisElementManager_cl<class VisStaticMeshInstance_cl *>
{
  V_DECLARE_SERIAL_DLLEXP( VisStaticMeshInstance_cl, VISION_APIDATA )

public:

  enum VisCollisionBehavior_e
  {
    VIS_COLLISION_BEHAVIOR_FORCENOCOLLISION = 0,
    VIS_COLLISION_BEHAVIOR_FROMFILE = 1,
    VIS_COLLISION_BEHAVIOR_CUSTOM = 2
  };

  ///
  /// @name Construction and Destruction
  /// @{
  ///

  /// \brief
  ///   Virtual destructor of the static mesh instance class.
  VISION_APIFUNC virtual ~VisStaticMeshInstance_cl();

  /// \brief
  ///   Overridden VisTypedEngineObject_cl function to remove this instance from the scene
  VISION_APIFUNC VOVERRIDE void DisposeObject();

  /// \brief
  ///   Non-virtual overload of Release
  VISION_APIFUNC void Release();

  ///
  /// @}
  ///

  ///
  /// @name Bounding Box and Transformation
  /// @{
  ///

  /// \brief
  ///   Sets the world-space bounding box for this static mesh instance (i.e., including all the
  ///   submesh instances, after transformation to world space).
  inline void SetBoundingBox(const hkvAlignedBBox &box) { m_BoundingBox = box; }

  /// \brief
  ///   Returns the world-space bounding box for this static mesh instance.
  inline const hkvAlignedBBox &GetBoundingBox() const { return m_BoundingBox; }

  /// \brief
  ///   Recomputes the world-space bounding box for this static mesh instance. Call this method whenever the transformation of a mesh instance changes.
  ///
  /// \param bAccurate
  ///   If set to false (default) the bounding boxes are calculated in a performant way by rotating the mesh resource's boxes. In the accurate version
  ///   the boxes are generated by the rotated vertices. Naturally, this path is much slower. This is however done by vForge at scene export time so bounding boxes are stored in the most accurate way.
  VISION_APIFUNC void ReComputeBoundingBoxes(bool bAccurate=false);

  /// \brief
  ///   Sets the world-space transformation matrix for this static mesh instance.
  inline void SetTransform(const hkvMat4& mTransform) 
  { 
    m_Transformation = mTransform; 
    m_bTransformIsIdentity = m_Transformation.isIdentity ();
  }

  /// \brief
  ///   Returns the world-space transformation matrix of this static mesh instance.
  inline const hkvMat4& GetTransform() const { return m_Transformation; }

  /// \brief
  ///   Overridden function to handle zone repositioning
  VISION_APIFUNC VOVERRIDE void OnReposition(const VisZoneRepositionInfo_t &info, const hkvVec3 &vLocalPos);

  /// \brief
  ///   Overridden function return the position locally to the parent zone
  VISION_APIFUNC VOVERRIDE bool GetZoneLocalSpacePosition(hkvVec3& vDest);

  ///
  /// @}
  ///

  ///
  /// @name Submesh Handling
  /// @{
  ///

  /// \brief
  ///   Allocates the specified number of submesh instances. 
  /// 
  /// Use this function if you manually want to create and assign the submesh instances.
  /// 
  /// Do NOT call this function on instances of static meshes loaded from .vmesh files!
  /// 
  /// \param iNumInstances
  ///   Number of submesh instances to allocate.
  VISION_APIFUNC void AllocateMeshInstances(int iNumInstances);

  /// \brief
  ///   Links the submesh instances to the corresponding submeshes and surfaces.
  ///
  /// Use this function if the references mesh has been reloaded. In this case
  /// surfaces and submeshes will have been recreated.
  VISION_APIFUNC void LinkSubmeshInstances();

  /// \brief
  ///   Frees previously allocated submesh instances.
  /// 
  /// Use this function if you manually want to release the submesh instances.
  /// 
  /// Do NOT call this function on instances of static meshes loaded from .vmesh files!
  VISION_APIFUNC void FreeSubmeshInstances();

  /// \brief
  ///   Returns the number of submesh instances in this mesh instance. Has to be identical to the
  ///   number of submeshes in the mesh this instance was created from.
  inline int GetSubmeshInstanceCount() const { return m_iNumSubmeshInstances; }

  /// \brief
  ///   Returns the submesh instance with the specified index.
  inline VisStaticSubmeshInstance_cl *GetSubmeshInstance(int iInstanceIndex) const;
  
  
  ///
  /// @}
  ///

  ///
  /// @name Visibility
  /// @{
  ///

  /// \brief
  ///   Assigns all submesh instances of this static mesh instance to visibility zones.
  /// 
  /// Note that the submesh instance may end up in different visibility zones.
  /// 
  /// Also note that this is only an approximation of the "correct" assignment. Unlike for dynamic
  /// scene elements which can rely on their spatial relation to static scene elements for their
  /// visibility assignment, this is not always possible for static geometry!
  /// 
  /// In order to get correct results, manually assign static mesh instances to visibility zones
  /// using the functionality in the VisVisibilityZone_cl class.
  VISION_APIFUNC void AssignToVisibilityZones();

  /// \brief
  ///   Removes all submesh instances of this static mesh instance from their respective visibility
  ///   zones.
  VISION_APIFUNC void RemoveFromVisibilityZones();

  /// \brief
  ///   calls SetClipSettings on all submesh instances
  inline void SetClipSettings(float fNear, float fFar, const hkvVec3* pvClipRefPosition);

  /// \brief
  ///   calls SetClipMode on all submesh instances
  inline void SetClipMode(int iFlags=VIS_LOD_TEST_CLIPPOSITION);

  /// \brief
  ///   Restore the clip settings that were in the vmesh file
  inline void SetDefaultClipSettings(const hkvVec3* pClipRefOffset=NULL);

  /// \brief
  ///   Helper function to call VisStaticGeometryInstance_cl::SetVisibleBitmask on all submeshes. 
  ///
  /// In general the visibility bitmask is used to enable/disable the visibility of geometry in specific render contexts. Each render context
  /// has a render filter bitmask (see VisRenderContext_cl::SetRenderFilterMask). Geometry is only rendered when the logical AND operation between these 
  /// two masks is non-zero. Accordingly setting this visible bitmask to 0 will hide geometry in all contexts.
  /// This is the most efficient way to hide objects.
  /// The visible bitmask is a property of each submesh instance (which inherits VisStaticGeometryInstance_cl::SetVisibleBitmask).
  /// This is a helper function to loop through all submeshes and assign a new bitmask to each. But in addition the bitmask for each submesh is ANDed
  /// with the default visibility bitmask that is defined in the submesh resource. This however is 0xffffffff by default, so usually the mask passed
  /// to this function is applied to each submesh. See inline function implementation at the end of this header file.
  /// This is what happens in vForge when the shape property "VisibleBitmask" changes.
  /// Since this bitmask is not stored in this class, there is no getter for the bitmask.
  ///
  /// \param iMask
  ///   New bitmask applied to all submeshes
  ///
  /// \sa VisRenderContext_cl::SetRenderFilterMask
  /// \sa VisStaticGeometryInstance_cl::SetVisibleBitmask
  inline void SetVisibleBitmask(unsigned int iMask);

  ///
  /// @}
  ///

  ///
  /// @name Collision
  /// @{
  ///

  /// \brief
  ///   Specifies the collision bitmask/ collision behavior for the static mesh instance.
  ///   (eCollisionBehavior currently only used for Havok Physics.)
  VISION_APIFUNC void SetCollisionBitmask(unsigned int iCollisionMask, VisCollisionBehavior_e eCollisionBehavior=VIS_COLLISION_BEHAVIOR_FROMFILE);

  /// \brief
  ///   Returns the collision bitmask for the static mesh instance.
  inline unsigned int GetCollisionBitmask() const { return m_iCollisionMask; }

  /// \brief
  ///   Specifies the collision behavior for the static mesh instance. Please note that this method will only reset the member variable.
  ///   Use the method SetCollisionBitmask() to also apply the value to the engine. 
  ///   (eCollisionBehavior currently only used for Havok Physics.)
  VISION_APIFUNC void SetCollisionBehavior(VisCollisionBehavior_e eCollisionBehavior);

  /// \brief
  ///   Returns the collision behavior for the static mesh instance.
  ///   (Currently only used for Havok Physics.)
  inline VisCollisionBehavior_e GetCollisionBehavior() const { return m_eCollisionBehavior; }

  /// \brief
  ///   Specifies the welding type for the static mesh instance. 
  ///   (eWeldigType currently only used for Havok Physics.)
  VISION_APIFUNC void SetWeldingType(VisWeldingType_e eWeldingType);

  /// \brief
  ///   Returns the welding type for the static mesh instance.
  ///   (Currently only used for Havok Physics.)
  inline VisWeldingType_e GetWeldingType() const { return m_eWeldingType; }

  ///
  /// @}
  ///

  ///
  /// @name Lighting and Shadowing
  /// @{
  ///

  /// \brief
  ///   Internal function used by vForge/vLux.
  VISION_APIFUNC virtual bool ApplyLightmapInfo(VLightmapSceneInfo &sceneInfo, VLightmapPrimitive *pPrim);

  /// \brief
  ///   Internal function used by vForge/vLux.
  VISION_APIFUNC virtual bool GatherLightmapInfo(VLightmapSceneInfo &sceneInfo);

  /// \brief
  ///   Removes static lightmap information from this
  VISION_APIFUNC virtual void ResetStaticLighting();

  /// \brief
  ///   Returns true if this static mesh instance is lightmapped.
  VISION_APIFUNC bool IsLightmapped() const;

  /// \brief
  ///   Invalidate the light grid information of this mesh instance. Call this function when the
  ///   transformation matrix of this static mesh instance changes.
  inline void InvalidateLightGridInfo() { m_LightGridData.iLastUpdate = 0; }

  /// \brief
  ///   Internal function.
  VISION_APIFUNC void TrackLightGridInfo();

  /// \brief
  ///   Sets the light grid sample pivot (absolute, in worldspace). Does not invalidate the current
  ///   light grid colors.
  inline void SetLightGridSamplePosition(const hkvVec3& vPos) 
  {
    m_vLightGridPos.set(vPos.x,vPos.y,vPos.z, m_vLightGridPos.w); // preserve w because it stores the lightmap multiplier
  }

  /// \brief
  ///   Returns the current lightgrid pivot position
  inline const hkvVec3& GetLightGridSamplePosition() const {return (hkvVec3&) m_vLightGridPos;}

  /// \brief
  ///   Used by vForge to to set a relative lightmap scaling right before static lighting
  inline void SetLightmapMultiplier(float fValue) 
  {
    m_vLightGridPos.w=fValue;
  }

  /// \brief
  ///   Used by vForge to to set a relative lightmap scaling right before static lighting
  inline float GetLightmapMultiplier() const {return m_vLightGridPos.w;}


  /// \brief
  ///   Returns a pointer to the structure that holds lightgrid information. Future versions might
  ///   return NULL if the mesh does not use a lightgrid
  inline LightGridData_t* GetLightGridInfo() {return &m_LightGridData;}

  /// \brief
  ///   Returns whether any of the submeshes in this static mesh instance casts static shadows.
  inline bool GetCastStaticShadows() const {return m_bCastStaticShadows;}

  /// \brief
  ///   Specifies whether any of the submeshes in this static mesh instance casts static shadows.
  inline void SetCastStaticShadows(bool bStatus) {m_bCastStaticShadows=bStatus;}


  ///
  /// @}
  ///

  ///
  /// @name Physics Representation
  /// @{
  ///

  /// \brief
  ///   Returns a void pointer used to store a type-agnostic physics representation of this static
  ///   mesh instance. Used by physics modules.
  inline void *GetPhysicsObject() const { return m_pPhysicsObject; }

  /// \brief
  ///   Sets a void pointer used to store a type-agnostic physics representation of this static
  ///   mesh instance. Used by physics modules.
  inline void SetPhysicsObject(void *pPhysicsObject) { m_pPhysicsObject = pPhysicsObject; }

  inline void SetPhysicsHint(UBYTE iHint) {m_iPhysicsHint=iHint;}
  inline UBYTE GetPhysicsHint() const {return m_iPhysicsHint;}

  /// \brief
  ///   Manually fires the OnStaticMeshInstanceCreated method on the physics module
  ///
  /// Note that you usually should not fire this event manually, unless you explicitly 
  /// specified during VisStaticMesh_cl::CreateInstance that the event should not be sent
  /// automatically.
  VISION_APIFUNC void FirePhysicsStaticMeshInstanceCreatedEvent();


  ///
  /// @}
  ///

  ///
  /// @name Tagging
  /// @{
  ///

  /// \brief
  ///   Tags this static mesh instance
  inline void Tag() { m_iTagged = m_iTagCtr; }

  /// \brief
  ///   Returns whether this static mesh instance is tagged
  inline bool IsTagged() { return (m_iTagged == m_iTagCtr); }

  /// \brief
  ///   Resets the tags for all static mesh instances.
  static inline void ResetTags() { m_iTagCtr++; }


  ///
  /// @}
  ///

  ///
  /// @name Mesh Access
  /// @{
  ///

  /// \brief
  ///   Returns the static mesh this static mesh instance was created from.
  inline VisStaticMesh_cl *GetMesh() const { return m_spMesh; }

  /// \brief
  ///   Assigns a custom set of materials to this instance
  ///
  /// The passed set must be an array of surfaces where the surface count matches the number of surfaces in the original mesh GetMesh()->GetSurfaceCount().
  /// A compatible set can be created via VisSurfaceTextureSet_cl::CreateForMesh where the passed bCreateSrfInstances parameter must be set to true (unlike for entities).
  /// A NULL poiner can be passed to reset to the materials that are defined by the mesh. A material set can be shared across instances.
  /// This feature is just a higher level convenience function for setting surface pointers on the submesh instances directly, which is also possible through VisStaticGeometryInstance_cl::SetSurface.
  /// The applied set is serialized along with static meshes when serializing to VArchive.
  ///
  /// \param pSet
  ///   A custom surface set that is compatible with the owner mesh resource of this instance
  ///
  /// \sa VisSurfaceTextureSet_cl
  /// \sa VisSurfaceTextureSet_cl::CreateForMesh
  /// \sa VisStaticGeometryInstance_cl::SetSurface
  VISION_APIFUNC void SetCustomSurfaceSet(VisSurfaceTextureSet_cl *pSet);

  /// \brief
  ///   Returns the custom surface set instance that has been set via SetCustomSurfaceSet. By default this is NULL which means this instance uses the materials defined by the mesh
  inline VisSurfaceTextureSet_cl* GetCustomSurfaceSet() const {return m_spCustomSurfaceSet;}

  ///
  /// @}
  ///

  // Internal
  VISION_APIFUNC VOVERRIDE void Serialize( VArchive& ar );
  VISION_APIFUNC VOVERRIDE void OnSerialized(VArchive& ar);

  void DiscardSubmeshInstances(VArchive &ar, int iCount);
  VISION_APIFUNC VOVERRIDE void MessageFunction(int iID, INT_PTR iParamA, INT_PTR iParamB);

#ifdef SUPPORTS_SNAPSHOT_CREATION
  VISION_APIFUNC VOVERRIDE void GetDependencies(VResourceSnapshot &snapshot);
#endif
protected:
  void Init();
  void DeInit();
  void ReInit();

  VISION_APIFUNC VisStaticMeshInstance_cl();

  friend class VisStaticMesh_cl;
  friend class VisStaticSubmeshInstance_cl;

  // TODO (Dag): We could move this into the element manager (or a general base class), 
  // since tagging functionality is shared by a lot of classes.
  static unsigned int m_iTagCtr;
  unsigned int m_iTagged;

  int m_iNumSubmeshInstances;
  VisStaticSubmeshInstance_cl *m_pSubmeshInstances;
  hkvMat4 m_Transformation;
  bool m_bTransformIsIdentity, m_bCastStaticShadows;
  UBYTE m_iPhysicsHint; ///< arbitrary use in the physics binding. Gets serialized
  VisStaticMeshPtr m_spMesh;
  hkvAlignedBBox m_BoundingBox;

  LightGridData_t m_LightGridData;
  hkvVec4 m_vLightGridPos; // .w is used for lightmap scaling

  void *m_pPhysicsObject;
  VisSurfaceTextureSetPtr m_spCustomSurfaceSet;

  unsigned int m_iCollisionMask;
  VisCollisionBehavior_e m_eCollisionBehavior;
  VisWeldingType_e m_eWeldingType;

  #if defined(_VR_DX11)
    VShaderConstantBuffer m_LightGridConstantBuffer;
  #endif

  hkvVec3 m_vLocalZonePosition; // for repositioning
};

/// \brief
///   Class representing a renderable subset of a static mesh instance (VisStaticMeshInstance_cl).
/// 
/// Unlike mesh instances, submesh instances may only use a single material ("surface") and a
/// single lightmap. Each submesh has to be renderable with a single graphics API rendering call
/// and may only reference a range of up to 32767 vertices in the static mesh instance.
/// 
/// Each submesh instance references a submesh (VisStaticSubmesh_cl).
/// 
/// All the visibility determination and rendering is performed on VisStaticSubmeshInstance_cl
/// objects, NOT on VisStaticMeshInstance_cl objects. Thus, it is possible that only part of a
/// VisStaticMeshInstance_cl is considered visible and is therefore rendered.
/// 
/// VisStaticSubmeshInstance_cl objects can not be created directly, but are implicitly created
/// upon a call to VisStaticMesh_cl::CreateInstance as part of the VisStaticMeshInstance_cl.
/// 
/// Note that, unlike for scene elements derived from VisObject3D_cl, visibility zone assignment
/// will have to be done manually for VisStaticSubmeshInstance_cl objects.
class VisStaticSubmeshInstance_cl : public VisStaticGeometryInstance_cl
{
  V_DECLARE_SERIALX( VisStaticSubmeshInstance_cl, VISION_APIFUNC )

public:

  /// \brief
  ///   Virtual destructor of a static submesh instance.
  VISION_APIFUNC virtual ~VisStaticSubmeshInstance_cl();

  /// \brief
  ///   Returns a pointer to the submesh this instance was created from.
  inline VisStaticSubmesh_cl *GetSubmesh() const { return m_pSubmesh; }

  /// \brief
  ///   Returns a pointer to the static mesh instance this submesh instance is part of.
  inline VisStaticMeshInstance_cl *GetMeshInstance() const { return m_pMeshInstance; }

  /// \brief
  ///   Overridden function. See base class (VisStaticGeometryInstance_cl).
  VISION_APIFUNC VOVERRIDE int TraceTest(const hkvVec3& startOfLine, const hkvVec3& endOfLine, int iStoreResultCount=0, VisTraceLineInfo_t *pFirstTraceInfo=NULL);

#ifdef SUPPORTS_SNAPSHOT_CREATION
  /// \brief
  ///   Overridden function. See base class (VisStaticGeometryInstance_cl).
  VISION_APIFUNC VOVERRIDE void GetDependencies(VResourceSnapshot &snapshot);
#endif

  /// \brief
  ///   Overridden function. See base class (VisStaticGeometryInstance_cl).
  VISION_APIFUNC VOVERRIDE void ComputeSortingKey();  

  /// \brief
  ///   Overridden function. See base class (VisStaticGeometryInstance_cl).
  VISION_APIFUNC VOVERRIDE int GetNumPrimitives();

  /// \brief
  ///   Overridden function. See base class (VisStaticGeometryInstance_cl).
  VISION_APIFUNC VOVERRIDE int GetSupportedStreamMask();

  /// \brief
  ///   Overridden function. See base class (VisStaticGeometryInstance_cl).
  VISION_APIFUNC VOVERRIDE void DebugRenderCollisionMesh(VColorRef iMeshColor, VColorRef iNormalColor, float fNormalLength);

  // Internal function
  VISION_APIFUNC void SerializeX( VArchive &ar );

  /// \brief
  ///   Overridden function
  VISION_APIFUNC VOVERRIDE VisZoneResource_cl *GetParentZone(); 

private:
  VisStaticSubmeshInstance_cl();

  friend class VisStaticMeshInstance_cl;
  friend class VisStaticMesh_cl;

  VisStaticSubmesh_cl *m_pSubmesh;
  VisStaticMeshInstance_cl *m_pMeshInstance;
};


VISION_ELEMENTMANAGER_TEMPLATE_DECL(VisStaticMeshInstance_cl)


////////////////////////////////////////////////////////////////////////////////////////////////////
// inlines
////////////////////////////////////////////////////////////////////////////////////////////////////

inline VisStaticSubmeshInstance_cl *VisStaticMeshInstance_cl::GetSubmeshInstance(int iInstanceIndex) const
{
  VASSERT(iInstanceIndex>=0 && iInstanceIndex < m_iNumSubmeshInstances);
  return &(m_pSubmeshInstances[iInstanceIndex]);
}


inline void VisStaticMeshInstance_cl::SetClipSettings(float fNear, float fFar, const hkvVec3* pvClipRefPosition)
{
  for (int i=0; i<m_iNumSubmeshInstances; i++)
    m_pSubmeshInstances[i].SetClipSettings(fNear, fFar, pvClipRefPosition);
}

inline void VisStaticMeshInstance_cl::SetClipMode(int iFlags)
{
  for (int i=0; i<m_iNumSubmeshInstances; i++)
    m_pSubmeshInstances[i].SetClipMode(iFlags);
}

inline void VisStaticMeshInstance_cl::SetDefaultClipSettings(const hkvVec3* pClipRefOffset)
{
  for (int i=0; i<m_iNumSubmeshInstances; i++)
  {
    VisStaticSubmesh_cl *pSM = m_pSubmeshInstances[i].GetSubmesh();
    VBaseGeometryInfo &data = pSM->GetGeometryInfo();
    if (data.m_fFarClipDistance>data.m_fNearClipDistance)
    {
      hkvVec3 vOfs = data.m_vClipReference;
      if (pClipRefOffset) 
        vOfs += (*pClipRefOffset);
      m_pSubmeshInstances[i].SetClipSettings(data.m_fNearClipDistance,data.m_fFarClipDistance, &vOfs);
    } else
    {
      m_pSubmeshInstances[i].SetClipSettings(data.m_fNearClipDistance,data.m_fFarClipDistance, NULL);
    }
  }
}


inline void VisStaticMeshInstance_cl::SetVisibleBitmask(unsigned int iMask)
{
  for (int i=0; i<m_iNumSubmeshInstances; i++)
  {
    unsigned int iFinal = GetMesh()->GetSubmesh(i)->GetGeometryInfo().m_iVisibleMask & iMask; // additionally filter with the mask that is part of the resource. This is 0xffffffff by default
    m_pSubmeshInstances[i].SetVisibleBitmask(iFinal);
  }
}


#endif

/*
 * Havok SDK - Base file, BUILD(#20130624)
 * 
 * Confidential Information of Havok.  (C) Copyright 1999-2013
 * Telekinesys Research Limited t/a Havok. All Rights Reserved. The Havok
 * Logo, and the Havok buzzsaw logo are trademarks of Havok.  Title, ownership
 * rights, and intellectual property rights in the Havok software remain in
 * Havok and/or its suppliers.
 * 
 * Use of this software for evaluation purposes is subject to and indicates
 * acceptance of the End User licence Agreement for this product. A copy of
 * the license is included with this software and is also available from salesteam@havok.com.
 * 
 */
