/*
 *
 * Confidential Information of Telekinesys Research Limited (t/a Havok). Not for disclosure or distribution without Havok's
 * prior written consent. This software contains code, techniques and know-how which is confidential and proprietary to Havok.
 * Product and Trade Secret source code contains trade secrets of Havok. Havok Software (C) Copyright 1999-2013 Telekinesys Research Limited t/a Havok. All Rights Reserved. Use of this software is subject to the terms of an end user license agreement.
 *
 */

/// \file VisionVisibilityCollector.hpp

#ifndef DEFINE_VISAPIVISIBILITYCOLLECTOR
#define DEFINE_VISAPIVISIBILITYCOLLECTOR

#include <Vision/Runtime/Engine/Visibility/VisApiObject3DVis.hpp>
#include <Vision/Runtime/Engine/Visibility/VisApiPortal.hpp>
#include <Vision/Runtime/Engine/Visibility/StreamProcessVisibilityJob.hpp>

// Forward declarations
class VisVisibilityCollectorTask_cl;
class VStreamProcessingWorkflow;
class VLODHysteresisManager;

/// \brief
///   Enumeration used to specify which scene element types a visibility collector will take into
///   account.
enum VisSceneElementTypes_e
{
  VIS_SCENEELEMENT_WORLDGEOMETRY = 1,
  VIS_SCENEELEMENT_ENTITIES = 2,
  VIS_SCENEELEMENT_LIGHTS = 4,
  VIS_SCENEELEMENT_VISOBJECTS = 8,
  VIS_SCENEELEMENT_ALL = 0xFFFFFFFF
};

/// \brief
///   Enumeration used to specify different behavior settings for visibility collectors.
/// 
/// Enumeration used to specify different behavior flags for visibility collectors.
/// 
/// VIS_VISCOLLECTOR_USEFOV: Specify this flag if view frustum tests should be performed. This is
/// used most of the time, unless point visibility (i.e. all scene elements visible from, say, an
/// omni light source) is desired.
/// 
/// VIS_VISCOLLECTOR_USEPORTALS: Specify this flag if portal tests whould be used.
/// 
/// VIS_VISCOLLECTOR_USEZONEOCCLUSIONQUERY: Specify this flag if occlusion queries should be
/// performed for portals and visibility zone bounding boxes.
/// 
/// VIS_VISCOLLECTOR_DEFAULTS_CAMERA: Defaults typically used for cameras/render contexts.
/// 
/// VIS_VISCOLLECTOR_DEFAULTS_LIGHT: Defaults typically used for omni lights.
enum VisVisibilityCollectorBehavior_e
{
  VIS_VISCOLLECTOR_USEFOV = 1,
  VIS_VISCOLLECTOR_USEPORTALS = 8,
  VIS_VISCOLLECTOR_USEZONEOCCLUSIONQUERY = 16,
  VIS_VISCOLLECTOR_DEFAULTS_CAMERA = VIS_VISCOLLECTOR_USEPORTALS | VIS_VISCOLLECTOR_USEFOV,
  VIS_VISCOLLECTOR_DEFAULTS_LIGHT = VIS_VISCOLLECTOR_USEPORTALS
};

/// \brief
///   Enumeration reflecting the state transitions.
/// 
/// This is important to avoid executing identical steps multiple times, e.g. when the same
/// visibility collector is registered with multiple render contexts.
/// 
/// VIS_VISIBILITYSTATUS_READY: This state should be set before OnDoVisibilityDetermination is
/// called, and when PostProcessVisibilityResults finishes executing.
/// 
/// VIS_VISIBILITYSTATUS_VISIBILITYDETERMINATION: This state should be set when
/// OnDoVisibilityDetermination starts executing.
/// 
/// VIS_VISIBILITYSTATUS_POSTPROCESS: This state should be set when PostProcessVisibilityResults
/// starts executing.
enum VisVisibilityStatus_e
{
  VIS_VISIBILITYSTATUS_READY = 1,
  VIS_VISIBILITYSTATUS_VISIBILITYDETERMINATION = 2,
  VIS_VISIBILITYSTATUS_POSTPROCESS = 3
};

#define VIS_TRAVERSALPROTOCOL_PORTAL       1
#define VIS_TRAVERSALPROTOCOL_REMOVEPORTAL 2
#define VIS_TRAVERSALPROTOCOL_ZONE         3


/// \brief
///   Interface exposing basic functionality for visibility determination.
/// 
/// Visibility collectors are used in the Vision engine to perform visibility determination.
/// 
/// Visibility collectors can be registered with VisRenderContext_cl objects, and visibility
/// collectors can be shared across render contexts. 
/// 
/// Visibility processing typically occurs in two methods: OnDoVisibilityDetermination is called in
/// the VisionApp's Run function and typically performs raw portal- or frustum-based culling.
/// PostProcessVisibilityResults is called from inside the Vision engine just before rendering
/// starts and can be used to postprocess the data generated by OnDoVisibilityDetermination, taking
/// e.g. results of occlusion queries into account.
/// 
/// By default, the main render context in the Vision engine creates and uses a
/// VisionVisibilityCollector_cl object, though other implementations of IVisVisibilityCollector_cl
/// can be used instead.
/// 
/// Registering a visibility collector with a custom-created render context is required; otherwise,
/// all scene elements in this render context will be considered invisible.
/// 
/// To hook in custom visibility checks without writing a derived class, components of type
/// IVisVisibilityCollectorComponent_cl can be attached to a collector instance via AddComponent.
/// See terrain rendering implementation.
class IVisVisibilityCollector_cl : public VRefCounter, public VisTypedEngineObject_cl
{
public:


  ///
  /// @name Constructor/Destructor
  /// @{
  ///


  /// \brief
  ///   Constructor of the visibility collector base class. Triggers the static
  ///   OnVisibilityCollectorCreated callback with VisVisibilityCollectorDataObject_cl.
  VISION_APIFUNC IVisVisibilityCollector_cl();


  /// \brief
  ///   Destructor of the visibility collector base class. Triggers the static
  ///   OnVisibilityCollectorDestroyed callback with VisVisibilityCollectorDataObject_cl.
  VISION_APIFUNC VOVERRIDE ~IVisVisibilityCollector_cl();


  ///
  /// @}
  ///


  ///
  /// @name Main Visibility Functions
  /// @{
  ///


  /// \brief
  ///   Virtual function for handling visibility determination.
  /// 
  /// This function is typically called from the VisionApp::Run function after executing the game
  /// loop. Thus this function is always called from the main thread.
  /// 
  /// Since visibility results will not be queried by the Vision engine before
  /// PostProcessVisibilityResults is called, this method does not yet have to deliver the final
  /// visibility determination results, i.e. IsXXXVisible and GetVisibleXXX do not yet have to
  /// return the correct information.
  /// 
  /// Has to be implemented in derived classes. See VisionVisibilityCollector_cl for a reference
  /// implementation.
  /// 
  /// This function should trigger the global Vision::Callbacks.OnStartVisibilityDetermination
  /// callback and also call the virtual BeginVisibility function on all components of type
  /// IVisVisibilityCollectorComponent_cl that are attached to this collector via AddComponent. See
  /// default implementation.
  /// 
  /// \param iFilterBitmask
  ///   Bitmask used for filtering scene elements. For visibility collectors which are attached to
  ///   a render context, the render filter mask of the render context is passed by Vision's
  ///   default implementation of the VisionApp::Run function.
  /// 
  /// \sa VisRenderContext_cl::SetRenderFilterMask
  VISION_APIFUNC virtual void OnDoVisibilityDetermination(int iFilterBitmask = 0xFFFFFFFF) = 0;


  /// \brief
  ///   Virtual function generating the final visibility determination results.
  /// 
  /// This function is called by the main thread.
  /// 
  /// After this method has been called, the IsXXXVisible and GetVisibleXXX methods will have to
  /// return the desired (correct) results.
  /// 
  /// PostProcessVisibilityResults is often the right place to re-classify scene element visibility
  /// based on occlusion query results. For asynchronous visibility determination (i.e. kicking off
  /// visibility determination for multiple visibility collectors at once, then doing something
  /// else in between, and picking up the results at a later point), this is the place where you
  /// would typically pick up the visibility determination results.
  /// 
  /// Has to be implemented in derived classes. See VisionVisibilityCollector_cl for a reference
  /// implementation.
  /// 
  /// This function should trigger the global Vision::Callbacks.OnFinishVisibilityDetermination
  /// callback and also call the virtual EndVisibility function on all components of type
  /// IVisVisibilityCollectorComponent_cl that are attached to this collector via AddComponent. See
  /// default implementation.
  VISION_APIFUNC virtual void PostProcessVisibilityResults() = 0;


  /// \brief
  ///   Virtual function returning whether the passed static geometry instance is visible.
  VISION_APIFUNC virtual bool IsStaticGeometryInstanceVisible(VisStaticGeometryInstance_cl *pGeomInstance) = 0;


  /// \brief
  ///   Virtual function returning whether the specified entity is visible.
  VISION_APIFUNC virtual bool IsEntityVisible(const VisBaseEntity_cl *pEntity) = 0;


  /// \brief
  ///   Virtual function returning whether the specified visibility object is visible.
  VISION_APIFUNC virtual bool IsVisObjectVisible(const VisVisibilityObject_cl *pVisObject) = 0;


  /// \brief
  ///   Virtual function returning whether the specified light source is visible.
  VISION_APIFUNC virtual bool IsLightVisible(const VisLightSource_cl *pLight) = 0;


  /// \brief
  ///   Virtual function returning whether the specified visibility zone is visible.
  VISION_APIFUNC virtual bool IsVisibilityZoneVisible(const VisVisibilityZone_cl *pZone) = 0;


  /// \brief
  ///   Virtual function returning a pointer to a collection containing all visible static geometry
  ///   instances.
  /// 
  /// Depending on the passed blend mode flags (see VisBlendModeFlags_e), the returned collection
  /// either contains only opaque, only translucent, or all visible static geometry instances.
  /// 
  /// \return
  ///   VisStaticGeometryInstanceCollection_cl*: Pointer to the collection of visible static
  ///   geometry instances.
  VISION_APIFUNC virtual const VisStaticGeometryInstanceCollection_cl* GetVisibleStaticGeometryInstances() const = 0;

  /// \brief
  ///   Virtual function returning a pointer to a collection containing all visible static geometry
  ///   instances for a certain pass
  /// 
  /// Depending on the passed pass type the returned collection only contains static geometry instances
  /// which have to be rendered in that pass
  /// 
  /// \param ePass
  ///   the pass type to get all static geometry instances for
  /// 
  /// \return
  ///   VisStaticGeometryInstanceCollection_cl*: Pointer to the collection of visible static
  ///   geometry instances.
  VISION_APIDATA virtual const VisStaticGeometryInstanceCollection_cl* GetVisibleStaticGeometryInstancesForPass(VPassType_e ePass) const = 0;


  /// \brief
  ///   Virtual function returning a pointer to a collection containing all visible entities. Note
  ///   that the collection may not contain duplicate entries!
  VISION_APIFUNC virtual const VisEntityCollection_cl* GetVisibleEntities() const = 0;

  /// \brief
  ///   Virtual function returning a pointer to a collection containing all visible entities for a given pass type. Note
  ///   that the collection may not contain duplicate entries! 
  ///
  /// \param ePass
  ///   the pass type to get all visible entities for
  VISION_APIFUNC virtual const VisEntityCollection_cl* GetVisibleEntitiesForPass(VPassType_e ePass) const = 0;

  /// \brief
  ///   Virtual function returning a pointer to a collection containing all visible foreground entities. See VisBaseEntity_cl::SetAlwaysInForeGround
  VISION_APIFUNC virtual const VisEntityCollection_cl* GetVisibleForeGroundEntities() const = 0;


  /// \brief
  ///   Virtual function returning a pointer to a collection containing all visible visibility
  ///   objects. Note that the collection may not contain duplicate entries!
  VISION_APIFUNC virtual const VisVisibilityObjectCollection_cl* GetVisibleVisObjects() const = 0;


  /// \brief
  ///   Virtual function returning a pointer to a collection containing all visible light sources.
  ///   Note that the collection may not contain duplicate entries!
  VISION_APIFUNC virtual const VisLightSrcCollection_cl* GetVisibleLights() const = 0;


  /// \brief
  ///   Virtual function returning a pointer to a collection containing all visible visibility
  ///   zones. Note that the collection may not contain duplicate entries!
  VISION_APIFUNC virtual const VisVisibilityZoneCollection_cl* GetVisibleVisibilityZones() = 0;


  ///
  /// @}
  ///


  ///
  /// @name Visibility Collector Properties
  /// @{
  ///


  /// \brief
  ///   Sets the properties of this visibility collector (e.g. FOV, field of view) to the
  ///   corresponding values in the passed render context.
  /// 
  /// In the default VisionApp implementation, this method is called inside the Run function for
  /// all visibility collectors attached to render contexts. This happens before the
  /// OnDoVisibilityDetermination method is called.
  /// 
  /// The exact properties to copy from the render context depend on the individual visibility
  /// collector implementation.
  /// 
  /// \param pContext
  ///   render context from which to obtain the visibility collector properties.
  VISION_APIFUNC virtual void SetPropertiesFromRenderContext(VisRenderContext_cl *pContext) = 0;


  /// \brief
  ///   Virtual function returning the camera's view frustum before applying any portal clipping.
  /// 
  /// The default implementation of this function returns NULL. NULL is generally a valid return
  /// value for implementations of this function; however, this may lead to an overestimation of
  /// visible scene elements. Determination of visible sky faces, for instance, relies on this
  /// function returning a valid frustum, and will consider all sky faces as visible if
  /// GetBaseFrustum returns NULL.
  /// 
  /// \return
  ///   VisFrustum_cl *: View frustum prior to any portal clipping operations.
  /// 
  /// \sa VisRenderContext_cl::GetViewFrustum
  VISION_APIFUNC virtual const VisFrustum_cl *GetBaseFrustum();


  /// \brief
  ///   Sets the render context to be used for occlusion query functionality.
  /// 
  /// Since visibility collectors have to be able to take occlusion query results into account, but
  /// occlusion query is inherently a rendering-related function and therefore part of the render
  /// context class, this method allows you to specify which render context will be used for
  /// occlusion queries in this visibility collector.
  /// 
  /// Note that the render context has to support occlusion query in order for this feature to work
  /// correctly (see VisRenderContext_cl::SetRenderFlags).
  /// 
  /// \param pContext
  ///   Render context to be used for occlusion queries.
  /// 
  /// \sa VisRenderContext_cl::SetRenderFlags
  inline void SetOcclusionQueryRenderContext(VisRenderContext_cl *pContext) { m_pOQContext = pContext; }


  /// \brief
  ///   Returns the render context used for occlusion queries as previously set with
  ///   SetOcclusionQueryRenderContext.
  inline VisRenderContext_cl *GetOcclusionQueryRenderContext() const { return m_pOQContext; }


  /// \brief
  ///   Returns the render context that should be used for LOD computation. The return value is
  ///   always !=NULL.
  inline VisRenderContext_cl *GetLODReferenceRenderContext() const {return m_pLODContext;}


  /// \brief
  ///   Sets the source object (typically a camera or light source) for visibility determination.
  /// 
  /// Visibility determination typically starts in a single visibility zone, starting from which
  /// the scene is then traversed. This is typically the visibility zone the camera (or a light
  /// source, for light source visibility tests) is currently in. Since dynamically computing the
  /// initial visibility zone for traversal may take a significant amount of time, and scene
  /// elements like cameras and lights track visibility zone assignment anyway, it is mandatory to
  /// provide this "source object" to the visibility collector.
  /// 
  /// For render context visibility, you can typically simply pass the context's
  /// VisContextCamera_cl object.
  /// 
  /// \param pObject
  ///   Source object from which to start scene traversal.
  inline void SetSourceObject(VisObject3D_cl *pObject) 
  { 
    m_pSourceObject = pObject; 
  }

  /// \brief
  ///   Returns the VisObject3D_cl used as source object as previously set with SetSourceObject.
  inline VisObject3D_cl *GetSourceObject() 
  { 
    return m_pSourceObject; 
  }

  /// \brief
  ///   Sets the flags specifying which scene elements should be considered in this visibility
  ///   collector.
  /// 
  /// Note that by default, this function is called automatically for visibility collectors tied to
  /// a render context through the SetPropertiesFromRenderContext method (see VisionApp_cl for
  /// reference).
  /// 
  /// \param eFlags
  ///   Any combination of scene element flags as specified in the VisSceneElementTypes_e enum.
  /// 
  /// \sa VisionApp_cl::Run
  /// \sa IVisVisibilityCollector_cl::SetPropertiesFromRenderContext
  inline void SetSceneElementFlags(VisSceneElementTypes_e eFlags) 
  { 
    m_eSceneElementFlags = eFlags; 
  }


  /// \brief
  ///   Returns the scene element flags as previously set with SetSceneElementFlags.
  inline VisSceneElementTypes_e GetSceneElementFlags() const 
  { 
    return m_eSceneElementFlags; 
  }


  /// \brief
  ///   Sets the usage hints from the source context. This is called internally by SetPropertiesFromRenderContext.
  inline void SetSourceContextUsageHint(VisContextUsageHint_e eHint) 
  { 
    m_eContextHint = eHint; 
  }


  /// \brief
  ///   Returns the usage hints from the source context.
  inline VisContextUsageHint_e GetSourceContextUsageHint() const 
  { 
    return m_eContextHint; 
  }


  /// \brief
  ///   Sets the field of view for this visibility collector.
  /// 
  /// Note that by default, this function is called automatically for visibility collectors tied to
  /// a render context through the SetPropertiesFromRenderContext method (see VisionApp_cl for
  /// reference).
  /// 
  /// \param fFovX
  ///   Horizontal field of view in degrees.
  /// 
  /// \param fFovY
  ///   Vertical field of view in degrees.
  /// 
  /// \sa VisionApp_cl::Run
  /// \sa IVisVisibilityCollector_cl::SetPropertiesFromRenderContext
  /// \sa VisRenderContext_cl::SetFOV
  inline void SetFOV(float fFovX, float fFovY)
  { 
    m_fFov[0] = fFovX; 
    m_fFov[1] = fFovY; 
  }


  /// \brief
  ///   Returns the field of view previously set with SetFOV.
  inline void GetFOV(float &fFovX, float &fFovY) 
  { 
    fFovX = m_fFov[0]; 
    fFovY = m_fFov[1]; 
  }


  /// \brief
  ///   Sets the near and far clip planes for this visibility collector.
  /// 
  /// Note that by default, this function is called automatically for visibility collectors tied to
  /// a render context through the SetPropertiesFromRenderContext method (see VisionApp_cl for
  /// reference).
  /// 
  /// \param fNearClip
  ///   Near clip plane.
  /// 
  /// \param fFarClip
  ///   Far clip plane.
  /// 
  /// \sa VisionApp_cl::Run
  /// \sa IVisVisibilityCollector_cl::SetPropertiesFromRenderContext
  /// \sa VisRenderContext_cl::SetClipPlanes
  inline void SetClipPlanes(float fNearClip, float fFarClip) 
  { 
    m_fClipPlanes[0] = fNearClip; 
    m_fClipPlanes[1] = fFarClip; 
  }


  /// \brief
  ///   Returns the clip planes previously set with GetClipPlanes.
  inline void GetClipPlanes(float &fNearClip, float &fFarClip) 
  { 
    fNearClip = m_fClipPlanes[0]; 
    fFarClip = m_fClipPlanes[1]; 
  }


  /// \brief
  ///   Should not be used as this value will be set by OnDoVisibilityDetermination.
  inline void SetFilterBitmask(int iBitmask) 
  { 
    m_iFilterBitmask = iBitmask; 
  }


  /// \brief
  ///   Returns the bitmask that has been passed to OnDoVisibilityDetermination.
  inline int GetFilterBitmask() const 
  { 
    return m_iFilterBitmask; 
  }


  /// \brief
  ///   Overridable that must call WaitForTask on all tasks that are involved into visibility
  ///   determination.
  /// 
  /// The default implementation does not do anything.
  VISION_APIFUNC virtual void WaitForAllTasks() {}


  ///
  /// @}
  ///


  ///
  /// @name Global Callbacks
  /// @{
  ///


  /// \brief
  ///   This global callback is triggered from inside each collector's constructor passing the
  ///   collector pointer as an argument (VisVisibilityCollectorDataObject_cl class).
  /// 
  /// Custom geometry systems can use it to attach visibility components to each collector.
  /// 
  /// See Terrain system.
  VISION_APIDATA static VisCallback_cl OnVisibilityCollectorCreated;


  /// \brief
  ///   This global callback is triggered from inside each collector's destructor passing the
  ///   collector pointer as an argument (VisVisibilityCollectorDataObject_cl class).
  VISION_APIDATA static VisCallback_cl OnVisibilityCollectorDestroyed;

protected:
  VisSceneElementTypes_e m_eSceneElementFlags;
  VisRenderContext_cl *m_pOQContext;
  VisRenderContext_cl *m_pLODContext;
  VisObject3D_cl *m_pSourceObject;

  VisContextUsageHint_e m_eContextHint;
  VisProjectionType_e m_eProjectionType;
  float m_fFov[2];
  float m_fClipPlanes[2];
  float m_fOrthographicSize[2];
  int m_iFilterBitmask;


  ///
  /// @}
  ///


public:
  V_DECLARE_DYNAMIC_DLLEXP(IVisVisibilityCollector_cl,VISION_APIDATA)

};


/// \brief
///   Default visibility collector implementation for the vision engine.
/// 
/// This visibility collector covers a wide range of features, including view frustum culling,
/// portal tests, occlusion query, custom view frustums, and sorting of scene elements according to
/// various criteria.
/// 
/// View frustum/portal culling is performed in the OnDoVisibilityDetermination function. The
/// OnDoVisibilityDetermination method takes care of eliminating duplicates from the collections of
/// visible scene elements, reading back occlusion query results, eliminating scene elements which
/// did not pass occlusion query, and sorting visible scene elements.
/// 
/// This visibility collector will be sufficient for most needs. However, more specific approaches
/// and special-purpose optimizations are possible in many cases (e.g. for static cameras/lights,
/// limited freedom of movement, etc.). Similarly, more advanced implementations are possible.
/// 
/// The VisionVisibilityCollector_cl supports multi-threaded visibility determination. On PC and
/// Xbox360, each Visibility Collector is processed in a separate VThreadedTask by default. On
/// Playstation 3, the default path uses VStreamProcessor to kick off individual stream processing
/// tasks on the SPU for each visibility zone which is visited.
/// 
/// By default, the main render context in the Vision engine creates and uses a
/// VisionVisibilityCollector_cl object, though other implementations of IVisVisibilityCollector_cl
/// can be used instead.
/// 
/// Registering a visibility collector with a custom-created render context is required; otherwise,
/// all scene elements in this render context will be considered invisible.
class VisionVisibilityCollector_cl : public IVisVisibilityCollector_cl
{
public:


  ///
  /// @name Constructor / Destructor
  /// @{
  ///


  /// \brief
  ///   Constructor of the visibility collector.
  /// 
  /// \param eSceneElementTypes
  ///   Combimation of flags specifying which scene elements this visibility collector will handle.
  VISION_APIFUNC VisionVisibilityCollector_cl(VisSceneElementTypes_e eSceneElementTypes = VIS_SCENEELEMENT_ALL);


  /// \brief
  ///   virtual destructor of the VisionVisibilityCollector_cl class.
  VISION_APIFUNC virtual ~VisionVisibilityCollector_cl();


  ///
  /// @}
  ///


  ///
  /// @name Main Visibility Functions
  /// @{
  ///


  /// \brief
  ///   Performs scene traversal and basic view frustum/portal visibility determination.
  /// 
  /// Overridden function which performs scene traversal and basic view frustum/portal visibility
  /// determination.
  /// 
  /// Scene elements will additionally be filtered according to the filter mask passed to this
  /// method.
  /// 
  /// Internally calls PerformVisibilityDetermination to do the actual work.
  /// 
  /// This function is called by the VisionApp::Run function after executing the game loop.
  /// 
  /// \param iFilterBitmask
  ///   Bitmask used for filtering scene elements. For visibility collectors which are attached to
  ///   a render context, the render filter mask of the render context is passed by Vision's
  ///   default implementation of the VisionApp::Run function.
  /// 
  /// \sa VisionApp_cl::Run
  /// \sa IVisVisibilityCollector_cl::SetPropertiesFromRenderContext
  /// \sa VisRenderContext_cl::SetClipPlanes
  /// \sa IVisVisibilityCollector_cl::PerformVisibilityDetermination
  VISION_APIFUNC virtual void OnDoVisibilityDetermination(int iFilterBitmask = 0xFFFFFFFF) HKV_OVERRIDE;


  /// \brief
  ///   Performs scene traversal and basic view frustum/portal visibility determination.
  /// 
  /// Scene elements will additionally be filtered according to the filter mask passed to this
  /// method.
  /// 
  /// This method is either called by OnDoVisibilityDetermination (single-threaded execution)  or
  /// by the VisVisibilityCollectorTask_cl::Run method (multi-threaded execution).
  /// 
  /// This function is called by the VisionApp::Run function after executing the game loop.
  /// 
  /// \param iFilterBitmask
  ///   Bitmask used for filtering scene elements. For visibility collectors which are attached to
  ///   a render context, the render filter mask of the render context is passed by Vision's
  ///   default implementation of the VisionApp::Run function.
  /// 
  /// \sa VisionApp_cl::Run
  /// \sa IVisVisibilityCollector_cl::SetPropertiesFromRenderContext
  /// \sa VisRenderContext_cl::SetClipPlanes
  /// \sa IVisVisibilityCollector_cl::OnDoVisibilityDetermination
  VISION_APIFUNC void PerformVisibilityDetermination(int iFilterBitmask = 0xFFFFFFFF);


  /// \brief
  ///   Generates the final visibility determination results based on occlusion query results and
  ///   the data generated by OnDoVisibilityDetermination.
  /// 
  /// After this method has been called, the IsXXXVisible and GetVisibleXXX methods will  return
  /// the correct results.
  /// 
  /// Since the visibility results after OnDoVisibilityDetermination do not yet take occlusion
  /// query into account, may still contain duplicate scene elements, and are unsorted, this method
  /// takes care of removing duplicates, modifying the visibility status of scene elements
  /// according to occlusion query results, and sorting scene elements.
  VISION_APIFUNC virtual void PostProcessVisibilityResults() HKV_OVERRIDE;


  /// \brief
  ///   Virtual function returning a collection of visible static geometry instances. See
  ///   description of base class for details.
  VISION_APIFUNC virtual const VisStaticGeometryInstanceCollection_cl* GetVisibleStaticGeometryInstances() const HKV_OVERRIDE;

  /// \brief
  ///   Returns a pointer to a collection containing all visible static geometry instances for a given pass type
  ///
  /// \param ePassType
  ///   The pass type to get the static geometry instances for
  VISION_APIFUNC virtual const VisStaticGeometryInstanceCollection_cl* GetVisibleStaticGeometryInstancesForPass(VPassType_e ePassType) const HKV_OVERRIDE;

  /// \brief
  ///   Returns a pointer to a collection containing all visible entities. Note that the collection
  ///   may not contain duplicate entries!
  VISION_APIFUNC virtual const VisEntityCollection_cl* GetVisibleEntities() const HKV_OVERRIDE;


  /// \brief
  ///   Returns all visible entities for a given pass type
  ///
  /// \param ePassType
  ///   The pass type to get the entities for
  VISION_APIFUNC virtual const VisEntityCollection_cl* GetVisibleEntitiesForPass(VPassType_e ePassType) const HKV_OVERRIDE;

  /// \brief
  ///   Virtual function returning a pointer to a collection containing all visible foreground entities. See VisBaseEntity_cl::SetAlwaysInForeGround
  VISION_APIFUNC virtual const VisEntityCollection_cl* GetVisibleForeGroundEntities() const HKV_OVERRIDE;


  /// \brief
  ///   Returns a pointer to a collection containing all visible visibility objects. Note that the
  ///   collection may not contain duplicate entries!
  VISION_APIFUNC virtual const VisVisibilityObjectCollection_cl* GetVisibleVisObjects() const HKV_OVERRIDE;


  /// \brief
  ///   Returns a pointer to a collection containing all visible light sources. Note that the
  ///   collection may not contain duplicate entries!
  VISION_APIFUNC virtual const VisLightSrcCollection_cl* GetVisibleLights() const HKV_OVERRIDE;


  /// \brief
  ///   Returns a pointer to a collection containing all visible visibility zones. Note that the
  ///   collection may not contain duplicate entries!
  VISION_APIFUNC virtual VisVisibilityZoneCollection_cl* GetVisibleVisibilityZones() HKV_OVERRIDE;


  /// \brief
  ///   Returns whether the passed static geometry instance is visible
  VISION_APIFUNC VOVERRIDE bool IsStaticGeometryInstanceVisible(VisStaticGeometryInstance_cl *pGeomInstance);


  /// \brief
  ///   Returns whether the specified entity is visible.
  VISION_APIFUNC VOVERRIDE bool IsEntityVisible(const VisBaseEntity_cl *pEntity);


  /// \brief
  ///   Returns whether the specified visibility object is visible.
  VISION_APIFUNC VOVERRIDE bool IsVisObjectVisible(const VisVisibilityObject_cl *pVisObject);


  /// \brief
  ///   Returns whether the specified light source is visible.
  VISION_APIFUNC VOVERRIDE bool IsLightVisible(const VisLightSource_cl *pLight);


  /// \brief
  ///   Returns whether the specified visibility zone is visible.
  VISION_APIFUNC VOVERRIDE bool IsVisibilityZoneVisible(const VisVisibilityZone_cl *pZone);

  ///
  /// @}
  ///


  ///
  /// @name Visibility Collector Properties
  /// @{
  ///


  /// \brief
  ///   Sets the properties of this visibility collector to the corresponding values in the passed
  ///   render context.
  /// 
  /// In the default VisionApp implementation, this method is called inside the Run function for
  /// all visibility collectors attached to render contexts. This happens before the
  /// OnDoVisibilityDetermination method is called.
  /// 
  /// The following properties are copied from the render context: field of view, near and far clip
  /// plane,  and scene element flags.
  /// 
  /// \param pContext
  ///   render context from which to obtain the visibility collector properties.
  VISION_APIFUNC VOVERRIDE void SetPropertiesFromRenderContext(VisRenderContext_cl *pContext);


  /// \brief
  ///   Clears the scene elements' visibiliy status in this visibility collector as well as the
  ///   collections of visible scene elements.
  VISION_APIFUNC void ClearVisibilityData();


  /// \brief
  ///   Internal function. Determines which of the scene elements in the passed visibility zone
  ///   overlap the passed view frustum and adds them to the collections of visibile scene
  ///   elements.
  VISION_APIFUNC void CollectVisibleSceneElements(VisVisibilityZone_cl *pZone, VisFrustum_cl *pFrustum);


  /// \brief
  ///   Sets an alternate view frustum (replacing the automatically generated camera view frustum).
  /// 
  /// When an override frustum is set, the view frustum will not be generated automatically
  /// (through camera position and fov/clip plane information) any more, but instead, this frustum
  /// will be used for all further tests. Portal clipping of the view frustum will still occur,
  /// though.
  /// 
  /// Note that the source object has to be set even if an override frustum is specified.
  /// 
  /// \param pFrustum
  ///   The frustum with which to override the view frustum computation.
  /// 
  /// \sa IVisVisibilityCollector_cl::SetSourceObject
  inline void SetOverrideFrustum(VisFrustum_cl *pFrustum) { m_pOverrideFrustum = pFrustum; }


  /// \brief
  ///   Returns the override frustum previously set with SetOverrideFrustum, or NULL if no override
  ///   frustum is set.
  inline VisFrustum_cl *GetOverrideFrustum() const { return m_pOverrideFrustum; }


  /// \brief
  ///   Sets the behavior flags for this visibility collector.
  /// 
  /// \param iBehaviorFlags
  ///   Any combination of the flags specified in the VisVisibilityCollectorBehavior_e enumeration.
  inline void SetBehaviorFlags(unsigned int iBehaviorFlags) 
  { 
    m_iBehaviorFlags = iBehaviorFlags; 
  }


  /// \brief
  ///   Returns the behavior flags previously set with SetBehaviorFlags.
  inline unsigned int GetBehaviorFlags() const 
  { 
    return m_iBehaviorFlags; 
  }

  /// \brief
  ///   Sets the minimum triangle count required to consider an entity for occlusion queries.
  /// 
  /// Since hardware occlusion queries have a noticeable CPU and GPU impact, it is sometimes
  /// faster to simply render an entity instead of performing hardware occlusion query for it. This
  /// is typically the case for low-polygon entities. Using this function, you can set the minimum
  /// number of triangles an entity's model must have in order for it to be considered for
  /// occlusion queries.
  /// 
  /// \param iNumTris
  ///   Minimum triangle count.
  inline void SetOcclusionQueryTriangleCountThreshold(int iNumTris = 50) { m_iOcclusionQueryMinTriangles=iNumTris; }


  /// \brief
  ///   Returns the occlusion query triangle count threshold previously set with
  ///   SetOcclusionQueryTriangleCountThreshold.
  inline int GetOcclusionQueryTriangleCountThreshold() const { return m_iOcclusionQueryMinTriangles; }


  /// \brief
  ///   Returns the camera's view frustum before applying any portal clipping.
  /// 
  /// Since the frustum itself is generated when OnDoVisibilityDetermination is called, this method
  /// won't return a valid result before OnDoVisibilityDetermination has been called at least once.
  /// 
  /// Note that this function is almost equivalent to VisRenderContext_cl::GetViewFrustum, but
  /// significantly faster, since it just returns a previously computed frustum rather than
  /// calculating it from scratch.
  /// 
  /// \return
  ///   VisFrustum_cl *: View frustum prior to any portal clipping operations.
  /// 
  /// \sa VisRenderContext_cl::GetViewFrustum
  VISION_APIFUNC VOVERRIDE const VisFrustum_cl *GetBaseFrustum();


  /// \brief
  ///   Overridden function that calls WaitForTask on the m_pTask member
  VISION_APIFUNC VOVERRIDE void WaitForAllTasks();


  /// \brief
  ///   Enables/disables multi-threaded visibility determination
  static inline void SetMultithreaded(bool bStatus) { s_bMultithreaded = bStatus; }


  /// \brief
  ///   Returns whether multi-threaded visibility determination is enabled or disabled.
  static inline bool GetMultithreaded() { return s_bMultithreaded; }

  inline void SetOverrideStartZone(VisVisibilityZone_cl *pZone) { m_pStartZone = pZone; }
  inline VisVisibilityZone_cl *GetOverrideStartZone() const { return m_pStartZone; }


  /// \brief
  ///   Forces the visibility collector to trace through all terrain visibility zones.
  /// 
  /// When the camera of a visibility collector is outside of all visibility zones, it is possible that the early-out
  /// mechanism for terrain visibility zones exits too early. This can happen due to the fact that individual terrain
  /// sector heights can vary, and it is possible that a zone which would actually be visible is erroneously considered
  /// invisible. Therefore, if you expect the camera of a visibility collector to be outside all visibility zones of
  /// a scene all or most of the time, you can use this function to force the visibility collector to trace through all
  /// the terrain visibility zones all of the time. Note that this can produce some calculation overhead.
  /// A typical application for this is a shadow map renderer for directional lights.
  ///
  /// \param bStatus
  ///   true to enable, false to disable this functionality. Default is false.
  inline void SetTraceAllTerrainZones(bool bStatus) { m_bTraceAllTerrainZones = bStatus; }

  /// \brief
  ///   Returns the value previously set with SetTraceAllTerrainZones (false is the default value).
  inline bool GetTraceAllTerrainZones() const { return m_bTraceAllTerrainZones; }

  #ifdef SUPPORTS_LOD_HYSTERESIS_THRESHOLDING
    /// \brief
    ///   Returns the LOD hysteresis manager.
    inline VLODHysteresisManager* GetLODHysteresisManager() const { return m_pLODHysteresisManager; }
  #endif //SUPPORTS_LOD_HYSTERESIS_THRESHOLDING

  ///
  /// @}
  ///

protected:


  ///
  /// @name Internal Functions
  /// @{
  ///


  /// \brief
  ///   Internal function performing the actual scene traversal. Called by
  ///   OnDoVisibilityDetermination.
  VISION_APIFUNC void TraverseScene(VisVisibilityZone_cl *pZone, int iRecursionDepth=0);


  /// \brief
  ///   Clears various flags set for the scene elements.
  VISION_APIFUNC void ClearSceneElementFlags();


  /// \brief
  ///   Ensures that the flag array for visibility zones is large enough.
  VISION_APIFUNC void EnsureVisibilityZoneFlagsSize();


  /// \brief
  ///   Clears the flag array for visibility zones.
  VISION_APIFUNC void ClearVisibilityZoneFlags();


  /// \brief
  ///   Returns whether a scene element is contained in any visible visibility zone.
  inline bool IsInVisibleZone(VisObject3D_cl *pObject3D);


  /// \brief
  ///   Traversal Protocol: Add zone.
  inline void ProtocolAddZone(VisVisibilityZone_cl *pZone)
  {
    m_TraversalProtocol[m_iTraversalProtocolSize++] = VIS_TRAVERSALPROTOCOL_ZONE;
    m_TraversalProtocol[m_iTraversalProtocolSize++] = (UINT_PTR)pZone;
  }


  /// \brief
  ///   Traversal Protocol: Add portal.
  inline void ProtocolAddPortal(VisPortal_cl *pPortal)
  {
    m_TraversalProtocol[m_iTraversalProtocolSize++] = VIS_TRAVERSALPROTOCOL_PORTAL;
    m_TraversalProtocol[m_iTraversalProtocolSize++] = (UINT_PTR)pPortal;
  }


  /// \brief
  ///   Traversal Protocol: Remove portal.
  inline void ProtocolRemovePortal(VisPortal_cl *pPortal) 
  { 
    m_TraversalProtocol[m_iTraversalProtocolSize++] = VIS_TRAVERSALPROTOCOL_REMOVEPORTAL;
  }


  /// \brief
  ///   Internal method handling the results of portal/visibility zone occlusion query.
  VISION_APIFUNC void HandlePortalOcclusionQueryResults();

#if defined(SUPPORTS_MULTITHREADING)
 
  /// \brief
  ///   This method is called internally to kick off visibility workflows in the stream processor.
  VISION_APIFUNC void KickoffVisibilityWorkflow();


  /// \brief
  ///   This method is called internally to postprocess the results from the visibility workflow.
  VISION_APIFUNC void FinishVisibilityWorkflow();

#endif


  /// \brief
  ///   Initializes a new task in the visibility workflow.
  VISION_APIFUNC VStreamProcessingTask *InitVisibilityTask();


  /// \brief
  ///   Deinitializes a new task in the visibility workflow.
  VISION_APIFUNC void DeInitVisibilityTask(VStreamProcessingTask *pTask);

  /// \brief
  ///   Performs visibility collection for world geometry
  VISION_APIFUNC void CollectWorldGeometry(VisVisibilityZone_cl* pZone, int iNumGeomInstancesInZone, VisFrustum_cl* pFrustum, int iPlaneFlags,
                                           const hkvVec3& vCameraPos, float fLODScaleSqr, VisClippingResult_e eClipResult);

  /// \brief
  ///   Performs visibility collection for entities
  VISION_APIFUNC void CollectEntities(VisVisibilityZone_cl* pZone, int iNumEntitiesInNode, VisFrustum_cl* pFrustum, int iPlaneFlags,
                                      const hkvVec3& vCameraPos, float fLODScaleSqr, VisClippingResult_e eClipResult);

  /// \brief
  ///   Performs visibility collection for visbility elements
  VISION_APIFUNC void CollectVisElements(VisVisibilityZone_cl* pZone, int iNumVisObjectsInNode, VisFrustum_cl* pFrustum, int iPlaneFlags,
                                         const hkvVec3& vCameraPos, float fLODScaleSqr, VisClippingResult_e eClipResult);

  #ifdef SUPPORTS_LOD_HYSTERESIS_THRESHOLDING
    /// \brief
    ///   Performs visibility collection for world geometry; version using LOD hysteresis feature (slower)
    VISION_APIFUNC void CollectWorldGeometry_LODHysteresis(VisVisibilityZone_cl* pZone, int iNumGeomInstancesInZone, VisFrustum_cl* pFrustum, int iPlaneFlags,
                                                           const hkvVec3& vCameraPos, float fLODScaleSqr, VisClippingResult_e eClipResult);

    /// \brief
    ///   Performs visibility collection for entities; version using LOD hysteresis feature (slower)
    VISION_APIFUNC void CollectEntities_LODHysteresis(VisVisibilityZone_cl* pZone, int iNumEntitiesInNode, VisFrustum_cl* pFrustum, int iPlaneFlags,
                                                      const hkvVec3& vCameraPos, float fLODScaleSqr, VisClippingResult_e eClipResult);
  #endif //SUPPORTS_LOD_HYSTERESIS_THRESHOLDING

protected:
  int m_iOcclusionQueryMinTriangles;

  VisFrustum_cl *m_pOverrideFrustum;
  VisVisibilityZone_cl *m_pStartZone;

  VisEntityCollection_cl *m_pVisibleEntities;
  VisEntityCollection_cl *m_pVisiblePrimaryOpaquePassEntities;
  VisEntityCollection_cl *m_pVisibleSecondaryOpaquePassEntities;
  VisEntityCollection_cl *m_pVisibleTransparentPassEntities;
  VisEntityCollection_cl *m_pVisibleForeGroundEntities;
  VisVisibilityObjectCollection_cl *m_pVisibleVisObjects;
  VisLightSrcCollection_cl *m_pVisibleLights;
  VisStaticGeometryInstanceCollection_cl *m_pVisibleStaticGeometryInstances;
  VisStaticGeometryInstanceCollection_cl *m_pVisiblePrimaryOpaquePassStaticGeometryInstances;
  VisStaticGeometryInstanceCollection_cl *m_pVisibleSecondaryOpaquePassStaticGeometryInstances;
  VisStaticGeometryInstanceCollection_cl *m_pVisibleTransparentPassStaticGeometryInstances;

  VisVisibilityZoneCollection_cl m_VisibleVisibilityZones;

  unsigned int m_iBehaviorFlags;

  VisVisibilityStatus_e m_eStatus;

  bool m_bUseCameraBBox;
  bool m_bUsedWorkflow;
  hkvAlignedBBox m_CameraBBox;

  DynObjArray_cl<VisFrustum_cl> m_FrustumStack;
  unsigned int m_iFrustumStackDepth;

  bool m_bTraceAllTerrainZones;

  DynArray_cl<char> m_StaticGeometryInstanceFlags;
  DynArray_cl<char> m_EntityFlags;
  DynArray_cl<char> m_VisObjectFlags;
  DynArray_cl<char> m_LightFlags;
  DynArray_cl<char> m_VisibilityZoneVisitedFlags;
  DynArray_cl<char> m_VisibilityZoneFlags;

  DynArray_cl<UINT_PTR> m_TraversalProtocol;
  unsigned int m_iTraversalProtocolSize;

  VisVisibilityCollectorTask_cl *m_pTask;

  // Relevant for stream processing only:
  VStreamProcessingWorkflow *m_pWorkflow;
  int m_iStreamConfigCount;
  DynArray_cl<VisVisibilityStreamConfig_t> m_StreamConfigs;
  int m_iFrustumCount;
  DynObjArray_cl<VisFrustum_cl> m_Frusta;

  VISION_APIDATA static bool s_bMultithreaded;         ///< If true, multi-threading is used (can be used in conjunction with stream processing)
  VISION_APIDATA static bool s_bUseWorkflow;           ///< If true, stream processing variant is used
  int m_iContextRenderFlags;

  #ifdef SUPPORTS_LOD_HYSTERESIS_THRESHOLDING
    VLODHysteresisManager* m_pLODHysteresisManager;
  #endif //SUPPORTS_LOD_HYSTERESIS_THRESHOLDING

  #if defined(WIN32)
    // Internal code for dissolve feature in simulation package
    template <typename, typename> friend class DissolveFadingHandler;
    friend class VDissolveCollector;

    /// \brief
    ///   State class that contains the current and last LOD level index next to the current near and far clip plane distance for a single entity.
    class VLODState
    {
    public:
      VLODState() :
        m_iLastLODLevel(0xffff),
        m_iCurLODLevel(0xffff),
        m_fNear(0.0f),
        m_fFar(0.0f)
      {}

      unsigned short m_iLastLODLevel; ///< LOD level in last frame (0xffff when instance was not visible in last frame)
      unsigned short m_iCurLODLevel;  ///< LOD level in current frame (0xffff when instance is not visible in current frame)
      float m_fNear;                  ///< Near clip plane distance for current frame
      float m_fFar;                   ///< Far clip plane distance for current frame
    };

    /// \brief
    ///   Returns the LOD state of the entity with the given index
    ///
    /// \param iIndex
    ///   Index of the entity instance
    ///
    /// \return
    ///   Current LOD state of the entity
    ///
    /// \sa VisBaseEntity_cl::GetNumber
    VLODState& GetLODState(int iIndex)
    {
      m_EntityLODStates.EnsureSize(iIndex + 1);
      return m_EntityLODStates.GetDataPtr()[iIndex];
    }

    DynObjArray_cl<VLODState> m_EntityLODStates;  ///< Collection that contains the LOD states for all entities that are handled by this collector
    int m_iEntityPlaneFlagsMask;                  ///< Mask that is applied in visibility frustum test (e.g. used to mask out far-clipping test)
  #endif

  // temp memory used inside the recursion (can't make it global because of MT and can't put it on the stack
  // because recursion depth might become too deep.)
  hkvVec3 vPos, vDir;
  hkvMat3 mOrientation;
  float tempMem1[4*64];
  float tempMem2[4*64];
  VisPortal_cl targetPortal;

  ///
  /// @}
  ///

public:
  V_DECLARE_DYNAMIC_DLLEXP(VisionVisibilityCollector_cl,VISION_APIDATA)

};

typedef VSmartPtr<IVisVisibilityCollector_cl> IVisVisibilityCollectorPtr;


/// \brief
///   Task class for visibility collectors. See implementation of VisionVisibilityCollector_cl
///   class
class VisVisibilityCollectorTask_cl : public VThreadedTask
{
public:
  VisVisibilityCollectorTask_cl(VisionVisibilityCollector_cl *pVisibilityCollector);
  inline void SetFilterBitmask(int iBitmask) { m_iFilterBitmask = iBitmask; }
  inline int  GetFilterBitmask() const { return m_iFilterBitmask; }

  virtual void Run(VManagedThread *pThread);

  /// \brief
  ///   RTTI macro
  V_DECLARE_DYNAMIC_DLLEXP(VisVisibilityCollectorTask_cl, VISION_APIFUNC);

private:
  VisionVisibilityCollector_cl *m_pVisibilityCollector;
  int m_iFilterBitmask;
};


/// \brief
///   Component class that can be attached to instances of IVisVisibilityCollector_cl via
///   AddComponent.
/// 
/// Rather than writing custom collector classes, user specific geometry can be tested by attaching
/// components to a collector. The collector instance is responsible for calling respective virtual
/// functions on each component.
/// 
/// The static IVisVisibilityCollector_cl::OnVisibilityCollectorCreated function could be used to
/// register a new component to a collector.
class IVisVisibilityCollectorComponent_cl : public IVObjectComponent
{
public:

  /// \brief
  ///   Empty Constructor.
  VISION_APIFUNC IVisVisibilityCollectorComponent_cl();

  /// \brief
  ///   Destructor, nothing to de-initialize.
  VISION_APIFUNC VOVERRIDE ~IVisVisibilityCollectorComponent_cl();

  /// \brief
  ///   Pure virtual overridable that is called by the collector's OnDoVisibilityDetermination
  ///   function when this component is attached to the collector.
  /// 
  /// Like OnDoVisibilityDetermination, this function is called by the main thread.
  ///
  /// \param pCollector
  ///  The visibility collector the function is called by.
  VISION_APIFUNC virtual void BeginVisibility(IVisVisibilityCollector_cl *pCollector) = 0;

  /// \brief
  ///   Pure virtual overridable that is called by the collector's PostProcessVisibilityResults
  ///   function when this component is attached to the collector.
  /// 
  /// Like PostProcessVisibilityResults, this function is called by the main thread.
  /// 
  /// \param pCollector
  ///  The visibility collector the function is called by.
  VISION_APIFUNC virtual void EndVisibility(IVisVisibilityCollector_cl *pCollector) = 0;

public:
  V_DECLARE_DYNAMIC_DLLEXP(IVisVisibilityCollectorComponent_cl,VISION_APIDATA)
};



#endif

/*
 * Havok SDK - Base file, BUILD(#20131019)
 * 
 * Confidential Information of Havok.  (C) Copyright 1999-2013
 * Telekinesys Research Limited t/a Havok. All Rights Reserved. The Havok
 * Logo, and the Havok buzzsaw logo are trademarks of Havok.  Title, ownership
 * rights, and intellectual property rights in the Havok software remain in
 * Havok and/or its suppliers.
 * 
 * Use of this software for evaluation purposes is subject to and indicates
 * acceptance of the End User licence Agreement for this product. A copy of
 * the license is included with this software and is also available from salesteam@havok.com.
 * 
 */
